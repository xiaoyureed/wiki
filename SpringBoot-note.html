<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Spring boot note - Xiaoyu Wiki</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="pre.html">pre page</a></li><li class="chapter-item expanded "><a href="SpringBoot-note.html" class="active"><strong aria-hidden="true">1.</strong> Spring boot note</a></li><li class="chapter-item expanded "><a href="springcloud-note.html"><strong aria-hidden="true">2.</strong> springcloud-note</a></li><li class="chapter-item expanded "><a href="java-concurrent.html"><strong aria-hidden="true">3.</strong> java-concurrent</a></li><li class="chapter-item expanded "><a href="java-memory-model-jmm-jvm.html"><strong aria-hidden="true">4.</strong> java-memory-model-jmm-jvm</a></li><li class="chapter-item expanded "><a href="java-note.html"><strong aria-hidden="true">5.</strong> java-note</a></li><li class="chapter-item expanded "><a href="rust-note.html"><strong aria-hidden="true">6.</strong> rust-note</a></li><li class="chapter-item expanded "><a href="git-note.html"><strong aria-hidden="true">7.</strong> git note</a></li><li class="chapter-item expanded "><a href="linux-note.html"><strong aria-hidden="true">8.</strong> linux-note</a></li><li class="chapter-item expanded "><a href="cross-gfw.html"><strong aria-hidden="true">9.</strong> cross gfw</a></li><li class="chapter-item expanded "><a href="react-note.html"><strong aria-hidden="true">10.</strong> react-note</a></li><li class="chapter-item expanded "><a href="cs-note.html"><strong aria-hidden="true">11.</strong> cs note</a></li><li class="chapter-item expanded "><a href="distributed-system.html"><strong aria-hidden="true">12.</strong> distributed system</a></li><li class="chapter-item expanded "><a href="message-queue.html"><strong aria-hidden="true">13.</strong> message-queue</a></li><li class="chapter-item expanded "><a href="data-structure-and-algorithm.html"><strong aria-hidden="true">14.</strong> data structure and algorithm</a></li><li class="chapter-item expanded "><a href="effective-java-reading-note.html"><strong aria-hidden="true">15.</strong> effective java reading note</a></li><li class="chapter-item expanded "><a href="docker-note.html"><strong aria-hidden="true">16.</strong> docker note</a></li><li class="chapter-item expanded "><a href="how-to-test-java-app.html"><strong aria-hidden="true">17.</strong> how-to-test-java-app</a></li><li class="chapter-item expanded "><a href="maven-note.html"><strong aria-hidden="true">18.</strong> maven-note</a></li><li class="chapter-item expanded "><a href="mac.html"><strong aria-hidden="true">19.</strong> mac</a></li><li class="chapter-item expanded "><a href="autohotkey.html"><strong aria-hidden="true">20.</strong> AHK collection</a></li><li class="chapter-item expanded "><a href="class-conflict-check.html"><strong aria-hidden="true">21.</strong> class conflict check</a></li><li class="chapter-item expanded "><a href="cpp.html"><strong aria-hidden="true">22.</strong> cpp</a></li><li class="chapter-item expanded "><a href="create-blog-by-react.html"><strong aria-hidden="true">23.</strong> create blog by react</a></li><li class="chapter-item expanded "><a href="css-note.html"><strong aria-hidden="true">24.</strong> css-note</a></li><li class="chapter-item expanded "><a href="css-pre-processor.html"><strong aria-hidden="true">25.</strong> css pre processor</a></li><li class="chapter-item expanded "><a href="defect-about-java-programmer-from-programming-thinking.html"><strong aria-hidden="true">26.</strong> from programming thinking</a></li><li class="chapter-item expanded "><a href="design-pattern-note.html"><strong aria-hidden="true">27.</strong> design pattern note</a></li><li class="chapter-item expanded "><a href="dev-resources.html"><strong aria-hidden="true">28.</strong> dev resources</a></li><li class="chapter-item expanded "><a href="eclipse.html"><strong aria-hidden="true">29.</strong> eclipse</a></li><li class="chapter-item expanded "><a href="extjs-note.html"><strong aria-hidden="true">30.</strong> extjs-note</a></li><li class="chapter-item expanded "><a href="FreeMarker-note.html"><strong aria-hidden="true">31.</strong> FreeMarker-note</a></li><li class="chapter-item expanded "><a href="go-note.html"><strong aria-hidden="true">32.</strong> golang</a></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">33.</strong> hexo</a></li><li class="chapter-item expanded "><a href="html-note.html"><strong aria-hidden="true">34.</strong> html-note</a></li><li class="chapter-item expanded "><a href="idea-note.html"><strong aria-hidden="true">35.</strong> idea-note</a></li><li class="chapter-item expanded "><a href="interview-system-design.html"><strong aria-hidden="true">36.</strong> interview-system-design</a></li><li class="chapter-item expanded "><a href="java-code-clean.html"><strong aria-hidden="true">37.</strong> java-code-clean</a></li><li class="chapter-item expanded "><a href="job-interview-cv.html"><strong aria-hidden="true">38.</strong> job-interview-cv</a></li><li class="chapter-item expanded "><a href="joke-collecting.html"><strong aria-hidden="true">39.</strong> joke-collecting</a></li><li class="chapter-item expanded "><a href="jquery-note.html"><strong aria-hidden="true">40.</strong> jquery-note</a></li><li class="chapter-item expanded "><a href="js-tutorial.html"><strong aria-hidden="true">41.</strong> js-tutorial</a></li><li class="chapter-item expanded "><a href="money.html"><strong aria-hidden="true">42.</strong> money</a></li><li class="chapter-item expanded "><a href="mongodb-note.html"><strong aria-hidden="true">43.</strong> mongodb-note</a></li><li class="chapter-item expanded "><a href="mvc-mvvm.html"><strong aria-hidden="true">44.</strong> mvc-mvvm</a></li><li class="chapter-item expanded "><a href="my-ioc.html"><strong aria-hidden="true">45.</strong> my-ioc</a></li><li class="chapter-item expanded "><a href="mybatis-note.html"><strong aria-hidden="true">46.</strong> mybatis-note</a></li><li class="chapter-item expanded "><a href="mysql-note.html"><strong aria-hidden="true">47.</strong> mysql-note</a></li><li class="chapter-item expanded "><a href="nodejs.html"><strong aria-hidden="true">48.</strong> nodejs</a></li><li class="chapter-item expanded "><a href="outline-about-cache.html"><strong aria-hidden="true">49.</strong> outline-about-cache</a></li><li class="chapter-item expanded "><a href="outline-about-db-design-note.html"><strong aria-hidden="true">50.</strong> outline-about-db-design-note</a></li><li class="chapter-item expanded "><a href="outline-about-http.html"><strong aria-hidden="true">51.</strong> outline-about-http</a></li><li class="chapter-item expanded "><a href="outline-about-rest-api.html"><strong aria-hidden="true">52.</strong> outline-about-rest-api</a></li><li class="chapter-item expanded "><a href="php-note.html"><strong aria-hidden="true">53.</strong> php-note</a></li><li class="chapter-item expanded "><a href="postgres-note.html"><strong aria-hidden="true">54.</strong> postgres-note</a></li><li class="chapter-item expanded "><a href="python-note.html"><strong aria-hidden="true">55.</strong> python-note</a></li><li class="chapter-item expanded "><a href="redis-login-limitation.html"><strong aria-hidden="true">56.</strong> redis-login-limitation</a></li><li class="chapter-item expanded "><a href="redis-note.html"><strong aria-hidden="true">57.</strong> redis-note</a></li><li class="chapter-item expanded "><a href="regex-js.html"><strong aria-hidden="true">58.</strong> regex-js</a></li><li class="chapter-item expanded "><a href="servlet.html"><strong aria-hidden="true">59.</strong> servlet</a></li><li class="chapter-item expanded "><a href="spring-note.html"><strong aria-hidden="true">60.</strong> spring-note</a></li><li class="chapter-item expanded "><a href="springboot-doc.html"><strong aria-hidden="true">61.</strong> springboot-doc</a></li><li class="chapter-item expanded "><a href="springmvc-note.html"><strong aria-hidden="true">62.</strong> springmvc-note</a></li><li class="chapter-item expanded "><a href="task-schedule-note.html"><strong aria-hidden="true">63.</strong> task-schedule-note</a></li><li class="chapter-item expanded "><a href="tcp-ip-note.html"><strong aria-hidden="true">64.</strong> tcp-ip-note</a></li><li class="chapter-item expanded "><a href="tomcat-jetty-nginx.html"><strong aria-hidden="true">65.</strong> tomcat-jetty-nginx</a></li><li class="chapter-item expanded "><a href="webpack-note.html"><strong aria-hidden="true">66.</strong> webpack-note</a></li><li class="chapter-item expanded "><a href="windows-sub-system-on-linux.html"><strong aria-hidden="true">67.</strong> windows-sub-system-on-linux</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Xiaoyu Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<p>title: SpringBoot
tags:</p>
<ul>
<li>springboot
date: 2017-12-30 16:06:29
categories: java web</li>
</ul>
<hr />
<div align="center">
记录springboot学习中的问题, 总结;
https://github.com/h2pl web 项目
https://github.com/dreamhead/moco mock 框架
<p>https://github.com/cloudfavorites/favorites-web 单体应用实例 hibernate jpa</p>
<p>https://github.com/xkcoding/spring-boot-demo springboot demos</p>
</div>
<!--more-->
<!-- TOC -->
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令</a></li>
<li><a href="#%E5%B7%A5%E5%85%B7%E7%B1%BB">工具类</a>
<ul>
<li><a href="#bean-%E5%A4%8D%E5%88%B6-%E5%85%8B%E9%9A%86">bean 复制 克隆</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E7%BC%96%E8%A7%A3%E7%A0%81">编解码</a></li>
<li><a href="#commons-lang3">commons-lang3</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">文件操作</a></li>
<li><a href="#commons-collections4">commons-collections4</a></li>
</ul>
</li>
<li><a href="#spring-boot%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3">Spring Boot中的注解</a>
<ul>
<li><a href="#configurationproperties-%E5%92%8C-value">@ConfigurationProperties 和 @Value</a></li>
<li><a href="#enableconfigurationproperties">@EnableConfigurationProperties</a></li>
<li><a href="#enableautoconfiguration">@EnableAutoConfiguration</a></li>
<li><a href="#componentscan">@ComponentScan</a></li>
<li><a href="#springbootapplication">@SpringBootApplication</a></li>
<li><a href="#component%E5%92%8Cbean%E5%92%8Cconfigration%E5%8C%BA%E5%88%AB">@Component和@Bean和@Configration区别</a></li>
<li><a href="#import%E5%92%8Cimportresource%E5%92%8Cpropertysource%E6%AF%94%E8%BE%83">@Import和@ImportResource和@PropertySource比较</a></li>
</ul>
</li>
<li><a href="#%E9%9D%99%E6%80%81%E6%B3%A8%E5%85%A5">静态注入</a>
<ul>
<li><a href="#set%E6%B3%A8%E5%85%A5">set注入</a></li>
<li><a href="#postconstruct-%E6%B3%A8%E5%85%A5">@PostConstruct 注入</a></li>
<li><a href="#%E9%80%9A%E8%BF%87-applicationcontext">通过 ApplicationContext</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8starter">使用starter</a>
<ul>
<li><a href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8Bor%E5%8E%9F%E7%90%86">加载过程or原理</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E4%BC%9A%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3">自动配置类会用到的一些注解</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B">自动配置类的实例</a>
<ul>
<li><a href="#spring-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">spring 动态代理</a></li>
</ul>
</li>
<li><a href="#conditional">@Conditional</a></li>
<li><a href="#%E5%B0%81%E8%A3%85%E7%BB%84%E5%90%88%E6%9D%A1%E4%BB%B6">封装组合条件</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-starter">创建自己的 starter</a></li>
<li><a href="#%E5%8F%8D%E7%88%AC%E8%99%AB-starter">反爬虫 starter</a></li>
</ul>
</li>
<li><a href="#%E7%9B%91%E6%8E%A7-and-%E5%AE%89%E5%85%A8">监控 and 安全</a>
<ul>
<li><a href="#spring-boot-actuator-%E7%9B%91%E6%8E%A7">spring-boot-actuator 监控</a></li>
<li><a href="#spring-boot-admin-%E7%9B%91%E6%8E%A7%E7%95%8C%E9%9D%A2">spring boot admin 监控界面</a></li>
<li><a href="#spring-boot-starter-security">spring-boot-starter-security</a>
<ul>
<li><a href="#security%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D">security组件介绍</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E5%92%8C-%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81">基本使用 和 配置用户名密码</a></li>
<li><a href="#%E7%A6%81%E7%94%A8%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81">禁用基本认证</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E4%B8%AD-websecurity-%E5%92%8C-httpsecurity-%E5%8C%BA%E5%88%AB">配置中 WebSecurity 和 HttpSecurity 区别</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F">配置跨域</a></li>
</ul>
</li>
<li><a href="#oauth2">oauth2</a></li>
</ul>
</li>
<li><a href="#%E6%97%A5%E5%BF%97">日志</a>
<ul>
<li><a href="#log4j2-marker-%E5%86%99%E5%85%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">Log4j2-Marker 写入到指定日志文件</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%B1%82">数据层</a>
<ul>
<li><a href="#mybatis-%E8%87%AA%E5%8A%A8%E5%BB%BA%E8%A1%A8%E6%8F%92%E4%BB%B6">mybatis 自动建表插件</a></li>
<li><a href="#mybatis-crud-%E5%A2%9E%E5%BC%BA%E6%8F%92%E4%BB%B6">mybatis crud 增强插件</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6">数据库迁移版本控制</a>
<ul>
<li><a href="#liquibase">liquibase</a></li>
<li><a href="#flyway">Flyway</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93-url-%E5%92%8C%E9%A9%B1%E5%8A%A8">数据库 url 和驱动</a></li>
<li><a href="#graphql%E9%9B%86%E6%88%90">graphql集成</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C-sql">启动执行 SQL</a>
<ul>
<li><a href="#sql-%E5%88%86%E9%9A%94%E7%AC%A6%E7%9A%84%E5%9D%91">SQL 分隔符的坑</a></li>
<li><a href="#spring-datasource-%E8%87%AA%E5%B8%A6">spring datasource 自带</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-jpa">使用 jpa</a></li>
<li><a href="#datasourceinitializer">DataSourceInitializer</a></li>
<li><a href="#maven-antrun-plugin">maven-antrun-plugin</a></li>
</ul>
</li>
<li><a href="#%E6%95%B4%E5%90%88-spring-jdbc">整合 spring jdbc</a></li>
<li><a href="#%E6%95%B4%E5%90%88-hibernate">整合 hibernate</a>
<ul>
<li><a href="#jpa%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93">jpa注解总结</a></li>
<li><a href="#%E5%AE%A1%E8%AE%A1-createddate">审计 createdDate</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%94%9F-sql">执行原生 SQL</a></li>
<li><a href="#%E5%8A%A8%E6%80%81-sql">动态 SQL</a></li>
<li><a href="#spring-data-rest-%E9%85%8D%E5%90%88-spring-data-jpa">spring-data-rest 配合 spring-data-jpa</a></li>
</ul>
</li>
<li><a href="#%E6%95%B4%E5%90%88-mybatis-plus">整合 mybatis-plus</a></li>
<li><a href="#%E6%95%B4%E5%90%88-mybatis">整合 mybatis</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">基本配置</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-%E6%8B%A6%E6%88%AA%E5%99%A8-interceptor-plugins">使用 拦截器 interceptor plugins</a>
<ul>
<li><a href="#principle-of-plugins">principle of plugins</a></li>
<li><a href="#use-scenarios">use scenarios</a></li>
<li><a href="#how-to-use-plugins">how to use plugins</a></li>
</ul>
</li>
<li><a href="#typehandler">typehandler</a></li>
<li><a href="#%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91">全注解开发</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E5%88%B7%E6%96%B0-sql-mapper-%E5%AE%9E%E7%8E%B0%E7%83%AD%E5%8A%A0%E8%BD%BD">动态定时刷新 SQL mapper 实现热加载</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E7%9B%AE%E5%BD%95-and-%E5%BC%80%E5%90%AF%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%BF%87%E6%BB%A4">自定义资源文件打包目录 and 开启占位符过滤</a></li>
</ul>
</li>
<li><a href="#springboot-%E4%BA%8B%E5%8A%A1">springboot 事务</a>
<ul>
<li><a href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">事务基本使用</a></li>
<li><a href="#spring-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%A4%B1%E6%95%88%E7%9A%84%E5%9D%91">spring 事务传播失效的坑</a></li>
<li><a href="#transactional-%E6%B3%A8%E8%A7%A3">Transactional 注解</a></li>
</ul>
</li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a>
<ul>
<li><a href="#springboot-starter-cache">springboot-starter-cache</a></li>
<li><a href="#caffeine">caffeine</a></li>
</ul>
</li>
<li><a href="#%E9%85%8D%E5%90%88-h2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91">配合 h2 数据库进行开发</a>
<ul>
<li><a href="#h2-%E5%92%8C-spring-data-jpa-%E9%85%8D%E5%90%88">h2 和 spring data jpa 配合</a></li>
<li><a href="#%E5%92%8C-mybatis-plus-%E9%85%8D%E5%90%88">和 mybatis-plus 配合</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90">多数据源</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE-%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91">基本配置 全注解开发</a></li>
<li><a href="#abstractroutingdatasource-%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2">AbstractRoutingDataSource 动态数据源切换</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B-databaseidprovider">多数据库类型 databaseIdProvider</a></li>
</ul>
</li>
<li><a href="#web-%E7%9B%B8%E5%85%B3">web 相关</a>
<ul>
<li><a href="#%E5%8A%A0%E8%A7%A3%E5%AF%86">加解密</a></li>
<li><a href="#springboot-%E5%8F%91%E9%80%81-https-%E6%88%96%E8%80%85-http-%E5%AE%A2%E6%88%B7%E7%AB%AF-client">springboot 发送 https 或者 http 客户端 client</a>
<ul>
<li><a href="#%E5%8F%91%E9%80%81-http-client">发送 http client</a></li>
<li><a href="#%E5%8F%91%E9%80%81-https-client">发送 https client</a></li>
</ul>
</li>
<li><a href="#requestcontextholder">RequestContextHolder</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3-api-%E7%89%88%E6%9C%AC%E5%85%B1%E5%AD%98">解决 api 版本共存</a>
<ul>
<li><a href="#requestmappinghandlermapping">RequestMappingHandlerMapping</a></li>
<li><a href="#request-matcher">request matcher</a></li>
<li><a href="#request-condition">request condition</a></li>
</ul>
</li>
<li><a href="#%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B3%A8%E8%A7%A3">接收参数相关的注解</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B">自定义接收参数类型</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%9B%BE%E7%89%87">返回图片</a></li>
<li><a href="#rest-api-%E6%96%87%E6%A1%A3">rest api 文档</a>
<ul>
<li><a href="#knife4j">knife4j</a></li>
<li><a href="#springdoc-openapi">springdoc-openapi</a></li>
<li><a href="#swagger3">swagger3</a></li>
<li><a href="#%E9%9B%86%E6%88%90swagger2">集成swagger2</a></li>
</ul>
</li>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8-%E5%92%8C-%E6%8B%A6%E6%88%AA%E5%99%A8">过滤器 和 拦截器</a>
<ul>
<li><a href="#%E5%8C%BA%E5%88%AB">区别</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-filter">使用 filter</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-interceptor">使用 interceptor</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8">基本使用拦截器</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E-url-%E6%8B%A6%E6%88%AA">基于 url 拦截</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%8B%A6%E6%88%AA">基于注解拦截</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-druid-%E7%9B%91%E6%8E%A7">servlet Druid 监控</a></li>
<li><a href="#aop-%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8">aop 整合使用</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a></li>
<li><a href="#%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F">切入点表达式</a></li>
</ul>
</li>
<li><a href="#controlleradvice-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">@controllerAdvice 异常处理</a></li>
<li><a href="#httpservletrequest-%E7%9A%84%E8%BE%93%E5%85%A5%E6%B5%81%E5%8F%AA%E8%83%BD%E8%AF%BB%E5%8F%96%E4%B8%80%E6%AC%A1%E7%9A%84%E9%97%AE%E9%A2%98">HttpServletRequest 的输入流只能读取一次的问题</a></li>
<li><a href="#%E8%B7%AF%E7%94%B1%E5%A4%84%E7%90%86">路由处理</a>
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%98%A0%E5%B0%84-%E6%9A%B4%E9%9C%B2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90">静态资源映射 暴露静态资源</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0-view-controller">添加 view controller</a></li>
</ul>
</li>
<li><a href="#spring-boot-starter-thymeleaf">spring-boot-starter-thymeleaf</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2">运维部署</a>
<ul>
<li><a href="#%E6%94%AF%E6%8C%81-https-ssl">支持 https ssl</a>
<ul>
<li><a href="#nginx-%E9%85%8D%E7%BD%AE-https">nginx 配置 https</a></li>
<li><a href="#%E6%94%AF%E6%8C%81-https-%E8%AE%BF%E9%97%AE">支持 https 访问</a></li>
<li><a href="#http-%E8%AF%B7%E6%B1%82%E8%87%AA%E5%8A%A8%E8%BD%AC%E4%B8%BA-https">http 请求自动转为 https</a></li>
<li><a href="#%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81-http-https">同时支持 http https</a></li>
</ul>
</li>
<li><a href="#%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2">容器化部署</a></li>
<li><a href="#nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">nginx 反向代理</a></li>
<li><a href="#%E5%86%85%E5%B5%8C-tomcat-%E8%B0%83%E4%BC%98">内嵌 tomcat 调优</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE-war-%E5%8C%85%E9%83%A8%E7%BD%B2%E5%88%B0-tomcat">配置 war 包部署到 Tomcat</a></li>
</ul>
</li>
<li><a href="#spring-boot-%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91">spring boot 中的并发</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81">实现乐观锁悲观锁</a></li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81">移动端消息推送</a></li>
<li><a href="#%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1-im%E7%B3%BB%E7%BB%9F">即时通信 IM系统</a></li>
<li><a href="#%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7">辅助工具</a>
<ul>
<li><a href="#lombok-notice">lombok notice</a></li>
<li><a href="#devtools">devtools</a></li>
<li><a href="#maven-wrapper">maven wrapper</a></li>
</ul>
</li>
<li><a href="#%E6%A0%A1%E9%AA%8C">校验</a>
<ul>
<li><a href="#%E6%A0%A1%E9%AA%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">校验配置文件</a></li>
<li><a href="#%E6%A0%A1%E9%AA%8C%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0">校验请求参数</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C">自定义校验</a></li>
<li><a href="#validated%E5%92%8Cvalid">@Validated和@Valid</a></li>
</ul>
</li>
<li><a href="#runner-%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">runner 获取命令行参数</a>
<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">获取命令行参数</a></li>
<li><a href="#applicationrunner-or-commandlinerunner"><code>ApplicationRunner</code> or <code>CommandLineRunner</code></a></li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8">开发命令行应用</a></li>
<li><a href="#%E6%95%B4%E5%90%88-grpc">整合 grpc</a></li>
<li><a href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6">任务调度</a>
<ul>
<li><a href="#%E6%95%B4%E5%90%88-xxl-job-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0">整合 XXL-JOB 任务调度平台</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1">异步任务</a></li>
<li><a href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1">定时任务</a>
<ul>
<li><a href="#springboot-%E5%86%85%E7%BD%AE">springboot 内置</a></li>
<li><a href="#%E9%9B%86%E6%88%90-quartz">集成 Quartz</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-and-%E7%8E%AF%E5%A2%83">配置文件 and 环境</a>
<ul>
<li><a href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">读取配置文件</a>
<ul>
<li><a href="#%E5%87%A0%E7%A7%8D%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95">几种读取配置文件的方法</a></li>
<li><a href="#%E6%B3%A8%E5%85%A5%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B">注入复杂类型</a></li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%98%E5%85%88%E7%BA%A7">配置文件优先级</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF">读取环境信息</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E5%BC%95%E5%85%A5-springboot-%E6%96%B9%E5%BC%8F">两种引入 springboot 方式</a></li>
</ul>
</li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">序列化 反序列化</a>
<ul>
<li><a href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-json">日期时间 json</a></li>
<li><a href="#jackson-%E4%BD%BF%E7%94%A8">jackson 使用</a>
<ul>
<li><a href="#jsoncomponent">@JsonComponent</a></li>
<li><a href="#jackson-%E5%9C%A8-springboot-%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE">Jackson 在 springboot 中的配置</a></li>
<li><a href="#jackson%E6%B3%A8%E8%A7%A3">jackson注解</a></li>
<li><a href="#objectmapper-%E5%AE%9A%E5%88%B6">objectmapper 定制</a></li>
<li><a href="#objectmapper-%E4%BD%BF%E7%94%A8">objectmapper 使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8B%BE%E9%81%97">拾遗</a>
<ul>
<li><a href="#bean-%E6%87%92%E5%8A%A0%E8%BD%BD">bean 懒加载</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1><a class="header" href="#常用命令" id="常用命令">常用命令</a></h1>
<pre><code class="language-sh">du -sh *.jar # jar size

# 打包时没有指定主类，执行可以用java -cp {xxx.jar} {主类名称（绝对路径）}。
# -cp 指定类运行所依赖其他类的路径，通常是类库和jar包, 
# 等价 -classpath
# 多个jar包之间连接符：window上分号“;”.Linux下使用“:”
# 
# win
java -cp .;d:\work\other.jar;d:\work\my.jar packname.mainclassname 
# linux
java -cp .:/hone/myuser/work/other.jar:/hone/myuser/work/my.jar packname.mainclassname 
# 表达式支持通配符
java -cp .;c:\work\my.jar;c:\work\*.jar packname.mainclassname 


# 打包时指定了主类，执行可以直接用java -jar {xxx.jar}。
# 会用到目录META-INF\MANIFEST.MF文件，在该文件中，有一个叫Main－Class的参数，它说明了java -jar命令执行的类
# java -jar方式不可以指定附加依赖jar包。
java -jar *.jar

# 依赖多个 jar 不使用通配符也可以这样执行
# -D 设置系统属性, 通过System.getProperty(&quot;conf1&quot;);获得这个值
java -Djava.ext.dirs=lib MyClass 

# 跳过测试
# -D 表示 maven 中的 properties
mvn -Dmaven.test.skip=true clean package # skip unit test
mvn -DskipTests clean package

mvn clean package -Pxxx # 指定要激活 maven profile 的 id

java -Dserver.port=8010 -jar xxx.jar # specific server port
java -jar *.jar --server.port=8010 # 同上

# 指定 profile
java -jar *.jar --spring.properties.active=dev
java -jar -Dspring.profiles.active=dev demo-0.0.1-SNAPSHOT.jar
mvn spring-boot:run -Drun.profiles=dev




</code></pre>
<h1><a class="header" href="#工具类" id="工具类">工具类</a></h1>
<h2><a class="header" href="#bean-复制-克隆" id="bean-复制-克隆">bean 复制 克隆</a></h2>
<pre><code class="language-java">beancopier

https://github.com/mapstruct/mapstruct
</code></pre>
<h2><a class="header" href="#字符串" id="字符串">字符串</a></h2>
<pre><code class="language-java">// &gt;&gt;&gt; springboot 自带

RandomStringUtils 生成随机字符串, 随机数字
StringUtils.isEmpty() 并非严格的空

</code></pre>
<h2><a class="header" href="#编解码" id="编解码">编解码</a></h2>
<pre><code class="language-java">// &gt;&gt;&gt; springboot 自带

public static String getMD5(String str) {
        String base = str + &quot;/&quot; + salt;
        String md5 = DigestUtils.md5DigestAsHex(base.getBytes());
        return md5;
    }

</code></pre>
<h2><a class="header" href="#commons-lang3" id="commons-lang3">commons-lang3</a></h2>
<h2><a class="header" href="#文件操作" id="文件操作">文件操作</a></h2>
<pre><code class="language-java">// springboot 原生 文件下载

@GetMapping(&quot;/download&quot;)
public ResponseEntity&lt;Resource&gt; download(HttpServletResponse httpServletResponse,
                                            @RequestParam(&quot;id&quot;) String objId) throws Exception {
    final MongoSysFileServiceImpl.DownloadFileVo downloadFileVo = sysFileService.downloadFile(objId);
    if (downloadFileVo == null) {
        throw new RuntimeException(&quot;指定文件不存在, objId = &quot; + objId);
    }

    return ResponseEntity.ok()
            .contentType(MediaType.parseMediaType(&quot;application/octet-stream&quot;))
            .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=\&quot;&quot; + downloadFileVo.getFilename() + &quot;\&quot;&quot;)
            .body(new InputStreamResource(downloadFileVo.getIs()));

}

//上传
 @PostMapping(value = &quot;upload&quot;)
public R&lt;SysFile&gt; upload(@RequestPart(&quot;file&quot;) MultipartFile file)
{
    try
    {
        // 上传并返回访问地址
        final MongoSysFileServiceImpl.UploadFileResp uploadFileResp = sysFileService.uploadFile(file);
        SysFile sysFile = new SysFile();
        sysFile.setObjId(uploadFileResp.getObjId());
        sysFile.setName(uploadFileResp.getGeneratedName());
        return R.ok(sysFile);
    }
    catch (Exception e)
    {
        log.error(&quot;上传文件失败&quot;, e);
        return R.fail(e.getMessage());
    }
}
//feign client 远程调用
@PostMapping(value = &quot;/upload&quot;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public R&lt;SysFile&gt; upload(@RequestPart(value = &quot;file&quot;) MultipartFile file);



// 传递 文件 , 同时传递请求参数
@PostMapping(&quot;/add&quot;)
    public AjaxResult add( EstimateFile estimateFile, @RequestPart(&quot;files&quot;) MultipartFile[] files)
    { //@RequestPart(&quot;estimateFile&quot;)
        return toAjax(estimateFileService.insertEstimateFile(estimateFile, files));
    }

</code></pre>
<h2><a class="header" href="#commons-collections4" id="commons-collections4">commons-collections4</a></h2>
<pre><code class="language-java">isSubCollection(smallColl, bigColl)


/**
    * 1、除非元素为null，否则向集合添加元素
    */
CollectionUtils.addIgnoreNull(personList,null);


// &gt;&gt;&gt; 合并

/**
    * 2、将两个已排序的集合a和b合并为一个已排序的列表，以便保留元素的自然顺序
    */
CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)
/**
    * 3、将两个已排序的集合a和b合并到一个已排序的列表中，以便保留根据Comparator c的元素顺序。
    */
CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b, Comparator&lt;? super O&gt; c)


// &gt;&gt;&gt; 判空

/**
    * 5、如果参数是null，则返回不可变的空集合，否则返回参数本身。（很实用 ,最终返回List EMPTY_LIST = new EmptyList&lt;&gt;()）
    */
CollectionUtils.emptyIfNull(Collection&lt;T&gt; collection)
/**
    * 6、空安全检查指定的集合是否为空
    */
CollectionUtils.isEmpty(Collection&lt;?&gt; coll)
/**
    * 7、 空安全检查指定的集合是否为空。
    */
CollectionUtils.isNotEmpty(Collection&lt;?&gt; coll)



// &gt;&gt; 判断是否包含 

/**
    * 4、返回该个集合中是否含有至少有一个元素
    */
CollectionUtils.containsAny(Collection&lt;?&gt; coll1, T... coll2)


// &gt;&gt;&gt; 翻转

/**
    * 8、反转给定数组的顺序。
    */
CollectionUtils.reverseArray(Object[] array);



/**
    * 9、差集   or   chaList.removeAll(listB);
    or          listA.stream().filter(item -&gt; !listB.contains(item)).collect(toList());
    */
CollectionUtils.subtract(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)
/**
    * 10、并集    or     先 bingList.removeAll(listB), 再bingList.addAll(listB); ((先做差集再做添加所有）)
    */
CollectionUtils.union(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)
/**
    * 11、交集   也可用 jiaoList.retainAll(listB); 返回 Boolean, 会改变原有集合
    or          listA.stream().filter(item -&gt; listB.contains(item)).collect(toList())
    */
CollectionUtils.intersection(Collection a, Collection b) // 返回新集合
/**
    *12、 交集的补集（析取）
    */
CollectionUtils.disjunction(Collection a, Collection b)
</code></pre>
<h1><a class="header" href="#spring-boot中的注解" id="spring-boot中的注解">Spring Boot中的注解</a></h1>
<h2><a class="header" href="#configurationproperties-和-value" id="configurationproperties-和-value">@ConfigurationProperties 和 @Value</a></h2>
<p>@Value 是core container的feature。不支持宽松绑定，不支持Meta-data。但支持spELl。
@ConfigurationProperties 则支持宽松绑定，支持Meta-data。但不支持spELl。</p>
<p>@ConfigurationProperties一般只用来处理环境信息，不用来注入自定义属性（这段不知道翻译得准不准，原文如下：Even if the configuration above will create a regular bean for FooProperties, we recommend that @ConfigurationProperties only deal with the environment and in particular does not inject other beans from the context. Having said that, The @EnableConfigurationProperties annotation is also automatically applied to your project so that any existing bean annotated with @ConfigurationProperties will be configured from the Environment.）</p>
<p>配置文件：</p>
<pre><code class="language-yml">myProps: #自定义的属性和值    
  simpleProp: simplePropValue    
  arrayProps: 1,2,3,4,5    
  listProp1:    
    - name: abc    
      value: abcValue    
    - name: efg    
      value: efgValue    
  listProp2:    
    - config2Value1    
    - config2Vavlue2    
  mapProps:    
    key1: value1    
    key2: value2  
</code></pre>
<p>创建一个bean来接受信息：(这里不推荐这么用, 应该使用 @value 老老实实属性写全)</p>
<pre><code class="language-java">// @Component    // 这个注解可选
@data
@ConfigurationProperties(prefix=&quot;myProps&quot;) //接收application.yml中的myProps下面的属性   (prefix 必须, 不可为&quot;&quot;, 需要在配置类中 enable config props class)
// 此时 idea 提示 spring boot config annotation processor not configured, 是因为他以为你要为配置文件指定自定义属性, 需要生成提示 
// 可以https://docs.spring.io/spring-boot/docs/2.3.4.RELEASE/reference/html/appendix-configuration-metadata.html#configuration-metadata-annotation-processor
public class MyProps {    
    private String simpleProp;    
    private String[] arrayProps;    
    private List&lt;Map&lt;String, String&gt;&gt; listProp1 = new ArrayList&lt;&gt;(); //接收prop1里面的属性值    
    private List&lt;String&gt; listProp2 = new ArrayList&lt;&gt;(); //接收prop2里面的属性值    
    private Map&lt;String, String&gt; mapProps = new HashMap&lt;&gt;(); //接收prop1里面的属性值    
}
</code></pre>
<p>除了可以使用@ConfigurationProperties注解一个类，还可以在@Bean方法上使用；需要绑定属性到不受你控制的第三方组件时，这种方式非常有用。</p>
<p>为了从环境属性配置一个bean，将@ConfigurationProperties添加到它的bean注册过程,任何以foo为前缀的属性定义都会被映射到FooComponent上：</p>
<pre><code class="language-java">@ConfigurationProperties(prefix = &quot;foo&quot;)
@Bean
public FooComponent fooComponent() {
...
}
</code></pre>
<p>对于无法转换的属性, 比如本来是一个 Boolean 类型, 但是配置文件中配置的是 string 类型, ignoreInvalidFields 可以决定是否抛出异常, 默认为 false, 表示要抛出异常</p>
<p>对于配置文件中多余的属性, ignoreUnknownFields 决定是否抛出异常, 默认 true, 表示不抛出异常</p>
<h2><a class="header" href="#enableconfigurationproperties" id="enableconfigurationproperties">@EnableConfigurationProperties</a></h2>
<p>配置哪些类是用来接受配置文件信息的bean,当@EnableConfigurationProperties注解应用到你的@Configuration时，任何被@ConfigurationProperties注解的beans将自动被Environment属性配置  , configBean 无需 @component</p>
<pre><code>@EnableConfigurationProperties({LiquibaseProperties.class, ApplicationProperties.class})
</code></pre>
<p>当一个 @ConfigurationProperties bean 像如上这样注册，这个bean就有了一个名字，规范是这样：<code>&lt;prefix&gt;-&lt;fqn&gt;</code>, 即：前缀-全限定名，如：</p>
<pre><code>myProps-com.xy.PropertiesBean
</code></pre>
<p>enableXXX 类注解原理就是 定义一个注解, 在注解上通过 @import 引入一个配置类</p>
<h2><a class="header" href="#enableautoconfiguration" id="enableautoconfiguration">@EnableAutoConfiguration</a></h2>
<p>根据添加的jar依赖猜测你想如何配置Spring，如果发现应用了你不想要的特定自动配置类，你可以使用 @EnableAutoConfiguration 注解的exclude属性来禁用它们</p>
<pre><code>@EnableAutoConfiguration(exclude = {MetricFilterAutoConfiguration.class, MetricRepositoryAutoConfiguration.class})
</code></pre>
<p>使用一般是@EnableAutoConfiguration加到一个主@configration类上，主配置类一般就是app的启动类</p>
<h2><a class="header" href="#componentscan" id="componentscan">@ComponentScan</a></h2>
<p>扫描所有Spring组件，通过@autowired注入使用</p>
<p>如果使用上面建议的结构组织代码（将应用类放到根包下），你可以添加 @ComponentScan 注解而不需要任何参数。你的所有应用程序组件（ @Component , @Service , @Repository , @Controller 等）将被自动注册为Spring Beans。</p>
<h2><a class="header" href="#springbootapplication" id="springbootapplication">@SpringBootApplication</a></h2>
<p>@SpringBootApplication 注解等价于以默认属性使用 @Configuration ， @EnableAutoConfiguration 和 @ComponentScan</p>
<h2><a class="header" href="#component和bean和configration区别" id="component和bean和configration区别">@Component和@Bean和@Configration区别</a></h2>
<p>@Configuration 注解本质上还是 @Component, </p>
<pre><code class="language-java">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Configuration {
    @AliasFor(
        annotation = Component.class
    )
    String value() default &quot;&quot;;

    boolean proxyBeanMethods() default true;// 默认为 true, config bean 中的方法被 cglib 代理, 表示 在同个 config bean 中嵌套调用方法, 返回的对象默认从 ioc container 中获取, 不会新创建对象
}

</code></pre>
<p>@Configuration一般和@bean合用, @component和@bean不能合用</p>
<p>Spring Boot提倡基于Java的配置，通常简易启动类作为主配置类，其他配置类通过@import导入到主配置类；@ComponentScan也会扫描配置类  ,如果不得不使用基于xml的配置，仍旧可以从一个@configration类开始，通过@ImportResource 注解加载XML配置文件。</p>
<p>@Component被用在要被自动扫描和装配的类上，Spring 注解@Component等效于@Service,@Controller,@Repository；@Bean只能用于方法(方法名作为ioc容器中的bean name)和注解上。用@Configuration注解该类，等价 与XML中配置beans；用@Bean标注方法等价于XML中配置bean。</p>
<p>在项目中，本工程的bean注册，使用@Component，通过web service取得的bean，通过@Bean标注在获取方法上注册；</p>
<h2><a class="header" href="#import和importresource和propertysource比较" id="import和importresource和propertysource比较">@Import和@ImportResource和@PropertySource比较</a></h2>
<ul>
<li>前两者都需要和@configuration配合使用(Both @Import @ImportResource work with @Configuration), 表示导入额外的配置
<ul>
<li>@import 导入某个配置类, 这个配置类可以不用标注 @configuration (一般会配合自定义注解使用: 自定义注解上通过 @import 导入多个未标注@configuration 的配置类使得这些配置类生效)</li>
</ul>
</li>
<li>@ImportResource用来引入外置的配置文件, 如@ImportResource({&quot;classpath:datasource.xml&quot;}), 一般用来导入Spring的配置文件，让配置文件里面功能生效</li>
<li>@Import引入另外的@configuration类</li>
<li>@PropertySource用于加载另外的属性配置文件, 如@PropertySource(value = {&quot;classpath:person.properties&quot;}), 一般和@ConfigurationProperties(prefix = &quot;person&quot;)一起用
springboot默认只会加载application.properties中的属性,</li>
</ul>
<p>例子:</p>
<pre><code class="language-java">@Configuration
@Import(AnotherConfig.class)
@ImportResource(“classpath:/com/acme/properties-config.xml”)
@PropertySource(“classpath:some.properties”)
public class AppConfig
{
// blah…
}

</code></pre>
<h1><a class="header" href="#静态注入" id="静态注入">静态注入</a></h1>
<p>为静态属性注入值, 使用通过 XXXClass.xxx 使用</p>
<h2><a class="header" href="#set注入" id="set注入">set注入</a></h2>
<pre><code class="language-java">@Component(value = &quot;MongoConfig&quot;)
@ConfigurationProperties(prefix = &quot;mongo.config&quot;)
public class MongoConfig {
 
 private static String chat_username;
 
 @Value(&quot;${mongo.config.username}&quot;)
 public void setChat_username(String chat_username) {
 MongoConfig.chat_username = chat_username;
 }
}
</code></pre>
<h2><a class="header" href="#postconstruct-注入" id="postconstruct-注入">@PostConstruct 注入</a></h2>
<pre><code class="language-java">@Component
public class ADUserUtils {
 
    @Resource
    private  ADConfig adc;
 
    private  static ADConfig adc1;
 
    @PostConstruct
    public void init() {
        this.adc1 = adc;
    }
 
    public static List&lt;User&gt; getADUsers() {
        adc1.readConf();
} 
</code></pre>
<h2><a class="header" href="#通过-applicationcontext" id="通过-applicationcontext">通过 ApplicationContext</a></h2>
<p>得到静态的 context, 然后通过 getBean(xxx.class) ...</p>
<pre><code class="language-java">@SpringBootApplication
@MapperScan({&quot;io.github.xiaoyureed.mockitomybatisplusdemo.mapper&quot;})
public class MockitoDemoApplication {

    private static ConfigurableApplicationContext context;

    public static void main(String[] args) {
        context = SpringApplication.run(MockitoDemoApplication.class, args);
    }

}
</code></pre>
<h1><a class="header" href="#使用starter" id="使用starter">使用starter</a></h1>
<p>servlet request wrapper</p>
<p>https://blog.csdn.net/weixin_43935907/article/details/98476935
https://www.cnblogs.com/JAYIT/p/10943155.html
https://www.cnblogs.com/exmyth/p/10332328.html</p>
<h2><a class="header" href="#加载过程or原理" id="加载过程or原理">加载过程or原理</a></h2>
<p>@SpringBootApplication包含了@EnableAutoConfiguration，这个注解又包含@Import(AutoConfigurationImportSelector.class)。</p>
<p>spring boot启动时，会调用AutoConfigurationImportSelector的回调函数，让其解析所有包下的&quot;META-INF/spring.factories&quot; (位于项目结构的 <code>resources/META-INF/spring.factories</code> 下), 并把key为&quot;...EnableAutoConfiguration&quot;对应的value里的类都加载为Bean，而那些类基本都是注解了@Configuration的配置类。这便是spring boot能自动配置的原因。</p>
<h2><a class="header" href="#自动配置类会用到的一些注解" id="自动配置类会用到的一些注解">自动配置类会用到的一些注解</a></h2>
<p>https://my.oschina.net/u/566591/blog/2250290</p>
<pre><code>@Configuration  表明是一个配置类
@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class}) 使用starter的时候排除自动配置


@ConditionalOnClass  当classpath下发现该类的情况下进行自动配置 (name, value 任选其一)
@ConditionalOnMissingClass 没有这个类时应用标注的配置类

@ConditionOnMissingBean 在spring容器中没找到 bean 时 (如果不指定, 默认 方法返回值类型/当前类)
@ConditionalOnBean  当容器中有指定的Bean的条件下
# 默认是检查bean的类型, 看看容器中是否有同类型 bean 存在, 不看 bean name;
# 开启按照 bean name 检查: 属性 name = {xxx&quot;}
# @ConditionalOnBean(name = {&quot;hah&quot;, &quot;hoo&quot;}): &quot;and&quot; 关系, 有 hah, 且有 hoo, return true. 任何一个缺失都return false
# @ConditionalOnMissingBean(name = {&quot;hah&quot;, &quot;hoo&quot;}): &quot;and &quot; 关系, 没hah 且 没 hoo, return true. 任何一个出现, return false


@EnableConfigurationProperties(XxxProperties.class)  使 @ConfigurationProperties(prefix=&quot;aaa.bbb&quot;) 注解生效
@ConditionalOnProperty:指定的属性有指定的值时
# ConditionalOnProperty
    name/value (value 用于指定某配置一定要出现), havingValue 指定配置文件中的属性, 为 null返回 false, 不匹配返回false
    matchIfMissing 配置项如果缺失, 是否匹配, 默认 false
# 优先级比 onBean, onClass 这些都高
@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)




@ConditionalOnSingleCandidate: (和 @ConditionalOnBean 类似)当指定的Bean在容器中只有一个，或者在有多个Bean的情况下，用来指定首选的Bean 
@ConditionalOnExpression:基于SpEL表达式作为判断条件
@ConditionalOnResource(resources = {&quot;/xxx.yml&quot;}):类路径下是否有指定的资源
@ConditionalOnJava(javaversion.eight):基于JVM/Java版本作为判断条件
@ConditionalOnJndi:在JNDI存在的条件下查找指定的位置, 必须存在一个.否则,返回不匹配

@ConditionalOnNotWebApplication:当前项目不是Web项目的条件下
@ConditionalOnWebApplication:当前项目是Web项目的条件下


@AutoConfigureAfter(A.class) 配置类将在 A.class 之后加载
@AutoConfigureBefore   ... 之前加载
@AutoConfigureOrder

</code></pre>
<h2><a class="header" href="#自动配置类的实例" id="自动配置类的实例">自动配置类的实例</a></h2>
<h3><a class="header" href="#spring-动态代理" id="spring-动态代理">spring 动态代理</a></h3>
<p>https://lolico.me/2020/05/03/SpringBoot2-AOP-uses-cglib-proxy-by-default/</p>
<pre><code class="language-java">//SpringBoot1.5.x中的这个自动配置类会发现默认是使用jdk动态代理，那么为什么在SpringBoot2.x中改为默认使用Cglib了
@Configuration(proxyBeanMethods = false)
@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
public class AopAutoConfiguration {

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(Advice.class)
    static class AspectJAutoProxyingConfiguration {

        @Configuration(proxyBeanMethods = false)
        @EnableAspectJAutoProxy(proxyTargetClass = false)
        @ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;,
                matchIfMissing = false)
        static class jdkDynamicAutoProxyConfiguration {

        }

        @Configuration(proxyBeanMethods = false)
        @EnableAspectJAutoProxy(proxyTargetClass = true)
        @ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,
                matchIfMissing = true) // 能够看出AOP默认使用Cglib代理
        static class CglibAutoProxyConfiguration {

        }

    }
    // ...
}
</code></pre>
<h2><a class="header" href="#conditional" id="conditional">@Conditional</a></h2>
<p>自动配置相关注解底层都是通过 @Conditional(OnClassCondition.class) 实现的</p>
<p>通过它, 可以自己定制条件</p>
<p>https://my.oschina.net/u/566591/blog/2250290</p>
<h2><a class="header" href="#封装组合条件" id="封装组合条件">封装组合条件</a></h2>
<p>继承 AllNestedConditions 封装多条件 (and 关系)</p>
<p>AnyNestedCondition (or 关系)</p>
<p>NoneNestedConditions (none 关系)</p>
<h2><a class="header" href="#创建自己的-starter" id="创建自己的-starter">创建自己的 starter</a></h2>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-custom-starter">官方文档</a></p>
<p><a href="https://github.com/SpringForAll/spring-boot-starter-swagger">spring-boot-swagger 示例</a></p>
<ul>
<li>
<p>创建一个starter 项目</p>
<p>命名规则: spring boot 官方 starter 命名为 &quot;spring-boot-starter-xxx&quot;, 自定义的starter 命名 &quot;xxx-spring-boot-starter&quot;;</p>
<p>引入 <code>spring-boot-configuration-processor</code> (编译时生成 spring-configuration-metadata.json ，在IDE中编辑配置文件时，会出现提示), 标注为 optional: true 避免依赖传递</p>
<p>引入 <code>spring boot starter</code> (相关注解需要), 标注为 optional true,  idea 中 spring boot app 创建时自动导入了</p>
<p>继承 <code>spring-boot-starter-parent</code>, <a href="https://stackoverflow.com/questions/21317006/spring-boot-parent-pom-when-you-already-have-a-parent-pom/21318359#21318359">如果想不通过继承方式使用, 可以 dependencyManagement <code>spring boot dependencies</code>, 参考</a></p>
<p>如果是生成的 spring boot 项目, 删除 启动类, 然后替换 spring boot maven 插件 为 <code>maven-compile-plugin</code> (因为没有启动类, repackage 会报错), 设置 properties 下 maven.compiler.source, maven.compiler.target, java.version</p>
</li>
<li>
<p>创建一个 @ConfigurationProperties 类用于保存你的配置信息, 在 @EnableConfigurationProperties(...) 类上指定, (或者标注 component 然后配置componentScan 或者直接 @configurationPropertiesScan)</p>
<p>（如果你的项目不使用配置信息则可以跳过这一步，不过这种情况非常少见）</p>
</li>
<li>
<p>创建一个AutoConfiguration，引用定义好的配置信息；在AutoConfiguration中实现所有starter应该完成的操作，并且把这个类加入classpath:/META-INF/spring.factories配置文件中进行声明</p>
<p>自动配置类不应启用组件扫描以查找其他组件 (即 若生成的是spring boot 骨架, 应去掉启动类)。应该使用 @import 来导入其他配置类</p>
</li>
<li>
<p>打包发布</p>
<p>如果 starter 就是本地自己使用, 可以不打包不发布, 直接在另外的项目中引入</p>
</li>
</ul>
<p>spring.factories 示例:</p>
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration = \
com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration
</code></pre>
<h2><a class="header" href="#反爬虫-starter" id="反爬虫-starter">反爬虫 starter</a></h2>
<p>https://www.cnblogs.com/zouhao/p/12175653.html </p>
<p>TODO</p>
<h1><a class="header" href="#监控-and-安全" id="监控-and-安全">监控 and 安全</a></h1>
<p>密码加密 Argon2</p>
<p>Spring Vault，它为HashiCorp Vault添加抽象 -&gt; 密码存储</p>
<p>OWASP ZAP 渗透测试报告</p>
<h2><a class="header" href="#spring-boot-actuator-监控" id="spring-boot-actuator-监控">spring-boot-actuator 监控</a></h2>
<p>https://www.cnblogs.com/zwqh/p/11851300.html
https://www.jianshu.com/p/8bfac9289c7e</p>
<p>spring boot 的 sub project, 提供产品级别的监控</p>
<p>spring cloud 中, refresh 的 post 端点被 actuator 接管, 配置 <code>management.endpoints.web.exposure.include=health,info</code> (默认) 需要添加 'refresh', 最终需要 <code>curl -d{} http://xxx:xxx/actuator/refresh</code></p>
<p><a href="https://github.com/Netflix/Hystrix/issues/1566">hystrix.stream 也被接管</a>, 配置添加 'hystrix.stream', 监控流为 <code>http://xxx:xxx/actuator/hystrix.stream</code></p>
<p><a href="https://www.jianshu.com/p/d5943e303a1f">actuator 翻译</a>
<a href="https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/html/production-ready-features.html#production-ready">actuator 官方文档</a></p>
<p>自己写监控, 可以:</p>
<pre><code class="language-java">ConfigurableApplicationContext context = SpringApplication.run(PaymentServiceApp.class, args);
        ConfigurableEnvironment        env     = context.getEnvironment();

// 或者 直接 @autowired Environment env
</code></pre>
<p>ui展示: https://github.com/codecentric/spring-boot-admin</p>
<h2><a class="header" href="#spring-boot-admin-监控界面" id="spring-boot-admin-监控界面">spring boot admin 监控界面</a></h2>
<p>https://www.jianshu.com/p/483adafc6b3a //todo</p>
<h2><a class="header" href="#spring-boot-starter-security" id="spring-boot-starter-security">spring-boot-starter-security</a></h2>
<h3><a class="header" href="#security组件介绍" id="security组件介绍">security组件介绍</a></h3>
<p>[ref]](https://www.cnblogs.com/demingblog/p/10874753.html)</p>
<p>spring security 是安全认证框架, 基于 Servlet filter, 核心就是一组过滤器链; 可在 Web 请求级和方法调用级处理身份确认和授权 </p>
<p>如果是 普通的 spring 项目, 使用 shiro 更简单</p>
<p>================================= 核心组件</p>
<p>SecurityContext - 用户 auth 通过后, authentication 信息存储在这里, 可以在任意地方使用 <code>SecurityContextHolder.getContext().set/getAuthentication</code></p>
<p>SecurityContextHolder - 在任意地方可以获取 SecurityContext </p>
<p>Authentication - 认证信息对象, 表示认证后的用户</p>
<p>UserDetails - 认证用户的详细信息</p>
<p>UserDetailsService - 可以用来获取UserDetails。我们会自定义一个CustomUserDetailsService来实现UserDetailsService接口, 通过 username 查询到 userDetails, 如果没查到 , <code>UsernameNotFoundException</code></p>
<p>AuthenticationManager - 作用就是校验Authentication, 校验失败抛出 <code>BadCredentialsException</code></p>
<h3><a class="header" href="#基本使用-和-配置用户名密码" id="基本使用-和-配置用户名密码">基本使用 和 配置用户名密码</a></h3>
<p>配合 starter  (spring-boot-starter-security), 可以零配置使用. 引入后依赖</p>
<pre><code class="language-xml">&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
			&lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

</code></pre>
<p>如下配置即可</p>
<pre><code class="language-yml">server:
  port: 8000
spring:
  application:
    name: spring-security-demo

  security:
    user:
      # 如果不配置, 默认为 user/控制台日志中看到默认密码
    #   前端调用, 需要 basic auth 认证
      name: root
      password: root
</code></pre>
<p>支持两种验证方式:</p>
<ul>
<li>
<p>可以通过 form 表单来认证 (默认)</p>
<p>适合页面验证</p>
</li>
<li>
<p>可以通过 HttpBasic 来认证 (basic auth)</p>
<p>适合 api 接口的验证, 当然也适合页面</p>
</li>
</ul>
<p>用户名密码也可以在这里:</p>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Bean
	@Override
	public UserDetailsService userDetailsService() {
		UserDetails user =
			 User.withDefaultPasswordEncoder()
				.username(&quot;user&quot;)
				.password(&quot;password&quot;)
				.roles(&quot;USER&quot;)
				.build();

		return new InMemoryUserDetailsManager(user);
	}
}
</code></pre>
<h3><a class="header" href="#禁用基本认证" id="禁用基本认证">禁用基本认证</a></h3>
<p>如果既想使用security又不想每次输入用户名密码，可以直接在Application文件中禁用自动配置 (方法 1)</p>
<pre><code class="language-java">@EnableAutoConfiguration(exclude = {
    org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class
})

</code></pre>
<p>或者 在代码中配置 (方法 2)</p>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    /**
    是因为覆盖了父类方法, 父类中的方法内容如下:
        http.authorizeRequests((requests) -&gt; requests.anyRequest().authenticated()); // 所有 请求都需要认证
		http.formLogin(); // 支持表单认证
		http.httpBasic(); // 支持 basic auth 认证

    */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 这里为空, 表示无需 任何认证
//        super.configure(http);
    }
}
</code></pre>
<h3><a class="header" href="#配置中-websecurity-和-httpsecurity-区别" id="配置中-websecurity-和-httpsecurity-区别">配置中 WebSecurity 和 HttpSecurity 区别</a></h3>
<pre><code class="language-java">
// 影响全局安全性的配置（忽略资源，设置调试模式，通过实现自定义防火墙定义拒绝请求）
@Override
public void configure(WebSecurity web) throws Exception {
    web
        .ignoring()
        .antMatchers(&quot;/resources/**&quot;) // 忽略
        .antMatchers(&quot;/publics/**&quot;); // 忽略
}

//资源级别 配置基于Web的安全性, 粒度更细
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
        .antMatchers(&quot;/&quot;, &quot;/home&quot;).permitAll()
        .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)
        .antMatchers(&quot;/publics/**&quot;).hasRole(&quot;USER&quot;) // no effect, 因为  WebSecurity 中配置了 忽略 publics/** 下的验证
        .anyRequest().authenticated()
        .and()
        .formLogin().loginPage(&quot;/login&quot;).permitAll()
        .and()
        .logout().permitAll();
}

</code></pre>
<p>================================ 实现方法级别的权限控制</p>
<p><code>@EnableGlobalMethodSecurity(prePostEnabled =true)</code> 使用表达式实现方法级别的安全性   ,  4个注解可用</p>
<ul>
<li>
<p>@PreAuthorize 在方法调用之前,基于表达式的计算结果来限制对方法的访问</p>
</li>
<li>
<p>@PostAuthorize 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常</p>
</li>
<li>
<p>@PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果</p>
</li>
<li>
<p>@PreFilter 允许方法调用,但必须在进入方法之前过滤输入值</p>
</li>
</ul>
<pre><code class="language-java">//表示如果用户具有admin角色，就能访问listAllUsers方法，如果方法前不加@preAuthorize注解，意味着所有用户都能访问listAllUsers
@PreAuthorize(&quot;hasRole(‘admin‘)&quot;)
@RequestMapping(value = &quot;/user/&quot;, method = RequestMethod.GET)
@ResponseBody
publicList listAllUsers() {

    ……

}
</code></pre>
<p>此外还有 :</p>
<p>@EnableGlobalMethodSecurity(securedEnabled=true) 开启@Secured 注解过滤权限</p>
<p>@EnableGlobalMethodSecurity(jsr250Enabled=true)开启@RolesAllowed 注解过滤权限</p>
<h3><a class="header" href="#配置跨域" id="配置跨域">配置跨域</a></h3>
<p>https://lolico.me/2020/04/26/Spring-Security-CORS/
TODO</p>
<h2><a class="header" href="#oauth2" id="oauth2">oauth2</a></h2>
<p>spring security oauth2</p>
<p>check outline-about-authentication-oauth2.md</p>
<h1><a class="header" href="#日志" id="日志">日志</a></h1>
<h2><a class="header" href="#log4j2-marker-写入到指定日志文件" id="log4j2-marker-写入到指定日志文件">Log4j2-Marker 写入到指定日志文件</a></h2>
<p>https://www.jianshu.com/p/1ff824bc997a?utm_campaign</p>
<h1><a class="header" href="#数据层" id="数据层">数据层</a></h1>
<h2><a class="header" href="#mybatis-自动建表插件" id="mybatis-自动建表插件">mybatis 自动建表插件</a></h2>
<p>https://gitee.com/sunchenbin/mybatis-enhance</p>
<h2><a class="header" href="#mybatis-crud-增强插件" id="mybatis-crud-增强插件">mybatis crud 增强插件</a></h2>
<p>mybatis plus</p>
<p>tk.mybatis</p>
<h2><a class="header" href="#数据库迁移版本控制" id="数据库迁移版本控制">数据库迁移版本控制</a></h2>
<h3><a class="header" href="#liquibase" id="liquibase">liquibase</a></h3>
<p>TODO</p>
<h3><a class="header" href="#flyway" id="flyway">Flyway</a></h3>
<h2><a class="header" href="#数据库-url-和驱动" id="数据库-url-和驱动">数据库 url 和驱动</a></h2>
<pre><code>MySQL
jdbc:mysql://122.191.199.51:60000/js_phaseii_db?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai
jdbc:mysql://localhost:3306/ry-cloud?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8
com.mysql.cj.jdbc.Driver

</code></pre>
<h2><a class="header" href="#graphql集成" id="graphql集成">graphql集成</a></h2>
<p>https://www.awaimai.com/2876.html</p>
<h2><a class="header" href="#启动执行-sql" id="启动执行-sql">启动执行 SQL</a></h2>
<h3><a class="header" href="#sql-分隔符的坑" id="sql-分隔符的坑">SQL 分隔符的坑</a></h3>
<p>默认分隔符是 分号, 若SQL 中有执行过程/函数, 需要 <code>spring.datasource.separator=|</code> </p>
<pre><code class="language-sql">drop function if exists `getChildrenProductName`;|
create function `getChildrenProductName`(orgid varchar(50))
returns varchar(4000)
BEGIN
DECLARE `oTemp` VARCHAR(4000);
DECLARE `oTempChild` VARCHAR(4000);
DECLARE `oTempName` VARCHAR(4000);
DECLARE `oTempChildName` VARCHAR(4000);
DECLARE i int;
SET oTemp = CAST(orgid AS CHAR);
SET oTempChild = CAST(orgid AS CHAR);
set oTempName = '$';
set oTempChildName = '';
set i = 0;
WHILE oTempChild IS NOT NULL
DO
if i&gt;0 then
set oTempName = concat(oTempName,&quot;,&quot;,oTempChildName);
end if;
SET oTemp = CONCAT(oTemp,',',oTempChild);
set i = i +1;
SELECT GROUP_CONCAT(p.product_name,p.partnum) into oTempChildName FROM product p
left join bom b on b.PartID = p.PartID
 WHERE FIND_IN_SET(b.ParentPartID,oTempChild) &gt; 0;
SELECT GROUP_CONCAT(p.PartID) INTO oTempChild FROM product p
left join bom b on b.PartID = p.PartID
 WHERE FIND_IN_SET(b.ParentPartID,oTempChild) &gt; 0;
END WHILE;
RETURN oTempName;
END;|
</code></pre>
<h3><a class="header" href="#spring-datasource-自带" id="spring-datasource-自带">spring datasource 自带</a></h3>
<pre><code class="language-yml">spring:
  datasource:
#   数据源基本配置
    username: root
    password: 123
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC
    type: com.alibaba.druid.pool.DruidDataSource
#   数据源其他配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true
#   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
    schema:
        - classpath:sql/department.sql
        - classpath:sql/employee.sql
    initialization-mode: ALWAYS

</code></pre>
<h3><a class="header" href="#使用-jpa" id="使用-jpa">使用 jpa</a></h3>
<p>1、SpringBoot根据脚本初始化</p>
<p>结构初始化脚本文件由spring.datasource.schema属性指定，数据初始化脚本由文件spring.datasource.data属性指定。</p>
<p>这两个脚本是否执行的开关由spring.datasource.initialization-mode决定：always-一定执行，embedded-只对内存数据库执行(默认)，never-不执行。</p>
<p>2、JPA根据类结构初始化</p>
<p>　　@Entity注解的类将会被初始化一张数据库表。</p>
<p>　　是否执行的开关由spring.jpa.hibernate.ddl-auto属性控制，可为create/update/create-drop/none/validate，其中none和validate为不执行。</p>
<p>3、初始化时对于另一个属性spring.jpa.generate-dll在理解上的困惑</p>
<p>　　按照它的描述，spring.jpa.generate-dll是jpa层面对数据表生成策略的控制，而spring.jpa.hibernate.ddl-auto是jpa实现hibernate层面上对数据表生成策略的控制。</p>
<p>　　实践也验证了文章里所说的，spring.jpa.generate-dll比spring.jpa.hibernate.ddl-auto有更强的控制力度，即使spring.jpa.hibernate.ddl-auto为none，只要spring.jpa.generate-dll为true，也会根据@Entity注解的实体类生成对应数据表。</p>
<p>　　按照文章的建议，为了避免混淆和不好理解，这两者最好不要混用，只对JPA实现层面的控制属性spring.jpa.hibernate.ddl-auto进行设置即可。</p>
<p>4、让SpringBoot根据脚本和让JPA根据实体类进行初始化，两者之中选择一个即可。</p>
<p>5 spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect 虽然 不同的数据库方言会自动选择, 但是若想使用特定引擎类型需要指定方言, 不加这句则不会默认创建MyISAM引擎的数据库</p>
<pre><code class="language-yml">
</code></pre>
<h3><a class="header" href="#datasourceinitializer" id="datasourceinitializer">DataSourceInitializer</a></h3>
<pre><code class="language-java">
@Configuration
public class CustomizeDataSourceInitializer {


    @Value(&quot;classpath:testSql/test_farms.sql&quot;)
    private Resource functionScriptFarms;
    @Value(&quot;classpath:testSql/test_miners.sql&quot;)
    private Resource functionScriptMiners;
    @Value(&quot;classpath:testSql/test_pool_config.sql&quot;)
    private Resource functionScriptPoolConfig;

    @Bean
    public DataSourceInitializer dataSourceInitializer(final DataSource dataSource) {
        final DataSourceInitializer initializer = new DataSourceInitializer();
        // 设置数据源
        initializer.setDataSource(dataSource);
        initializer.setDatabasePopulator(databasePopulator());
        return initializer;
    }

    private DatabasePopulator databasePopulator() {
        final ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
        populator.addScripts(functionScriptFarms);
        populator.addScripts(functionScriptMiners);
        populator.addScripts(functionScriptPoolConfig);

        return populator;
    }

}
</code></pre>
<h3><a class="header" href="#maven-antrun-plugin" id="maven-antrun-plugin">maven-antrun-plugin</a></h3>
<pre><code class="language-xml">
&lt;profile&gt; 
    &lt;id&gt;refresh-db&lt;/id&gt; 
    &lt;build&gt; 
        &lt;plugins&gt; 
            &lt;plugin&gt; 
               &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
               &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; 
               &lt;configuration&gt; 
               &lt;target&gt; 
                   &lt;property file=&quot;src/main/resources/application.properties&quot; /&gt; 
                   &lt;sql driver=&quot;${jdbc.driver}&quot; url=&quot;${jdbc.url}&quot; userid=&quot;${jdbc.username}&quot; password=&quot;${jdbc.password}&quot; onerror=&quot;continue&quot; encoding=&quot;${project.build.sourceEncoding}&quot;&gt;
                       &lt;classpath refid=&quot;maven.test.classpath&quot; /&gt; 
                       &lt;transaction src=&quot;src/main/resources/sql/h2/schema.sql&quot;/&gt;
                       &lt;transaction src=&quot;src/test/resources/data/h2/import-data.sql&quot;/&gt;
                   &lt;/sql&gt; 
              &lt;/target&gt; 
              &lt;/configuration&gt; 
            &lt;/plugin&gt; 
        &lt;/plugins&gt; 
    &lt;/build&gt; 
&lt;/profile&gt;
</code></pre>
<h2><a class="header" href="#整合-spring-jdbc" id="整合-spring-jdbc">整合 spring jdbc</a></h2>
<p>https://www.cnblogs.com/liyihua/p/12333967.html</p>
<h2><a class="header" href="#整合-hibernate" id="整合-hibernate">整合 hibernate</a></h2>
<p>即 spring data jpa</p>
<h3><a class="header" href="#jpa注解总结" id="jpa注解总结">jpa注解总结</a></h3>
<pre><code class="language-java">// anno on class
@DynamicInsert
@DynamicUpdate
@EntityListeners(AuditingEntityListener.class)




//anno on field
// uuid as primary key
    @Id
    @GenericGenerator(name = &quot;generator&quot;, strategy = &quot;uuid&quot;)
    @GeneratedValue(generator = &quot;generator&quot;, strategy = GenerationType.TABLE)
    @Column(name = &quot;id&quot;, length = 32)
</code></pre>
<h3><a class="header" href="#审计-createddate" id="审计-createddate">审计 createdDate</a></h3>
<p>https://blog.csdn.net/a972669015/article/details/104778172
TODO</p>
<h3><a class="header" href="#执行原生-sql" id="执行原生-sql">执行原生 SQL</a></h3>
<p>https://github.com/cloudfavorites/favorites-web</p>
<p>https://www.cnblogs.com/myknow/p/9559011.html
https://segmentfault.com/a/1190000022338883
https://liuyanzhao.com/8069.html
TODO</p>
<h3><a class="header" href="#动态-sql" id="动态-sql">动态 SQL</a></h3>
<p>https://www.cnblogs.com/kongxianghai/p/7575988.html</p>
<p>插入和修改可以在类实体上标注
@DynamicInsert和@DynamicUpdate
运行时动态生成非空字段的 插入和 更新语句</p>
<p>动态查询则需要用 Criteria API</p>
<h3><a class="header" href="#spring-data-rest-配合-spring-data-jpa" id="spring-data-rest-配合-spring-data-jpa">spring-data-rest 配合 spring-data-jpa</a></h3>
<p>http://docs.jcohy.com/docs/spring-data-rest/3.2.8.RELEASE/html5/zh-cn/
https://docs.spring.io/spring-data/rest/docs/3.4.5/reference/html/#Project</p>
<p>https://docs.spring.io/spring-data/jpa/docs/2.4.5/reference/html/#repositories</p>
<p>spring data rest 可以直接将 repository 发布为 rest service, 和 spring data jpa (自动生成 crud api) 配合</p>
<p>目前支持Spring Data JPA、Spring Data MongoDB、Spring Data Neo4j、Spring Data GemFire、Spring Data Cassandra的 repository 自动转换成REST服务</p>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="language-java">@RepositoryRestResource // publish repository as rest service
interface ReservationRepository extends JpaRepository&lt;Reservation, Long&gt; {

    /**
     * customized rest service
     *
     * http://localhost:8080/reservations/search/by-name?name=hello
     */
    @RestResource(path = &quot;by-name&quot;)
    Optional&lt;Reservation&gt; findByName(String name);
}

</code></pre>
<p>在分布式下, 在 feign client 接收 spring data rest 发布的 service 需要和 hateoas (spring-boot-starter-hateoas) 配合:(<a href="https://docs.spring.io/spring-hateoas/docs/current/reference/html/#migrate-to-1.0.changes">hateoas 版本更新, 接受数据的实体有改变</a>)</p>
<pre><code class="language-java">@FeignClient(&quot;reservation-service&quot;) // also support 'url' ( outside eureka)
interface ReservationResources {

    @RequestMapping(&quot;/reservations&quot;)
    CollectionModel&lt;Reservation&gt; reservations();

    @RequestMapping(&quot;/message&quot;)
    String message();
}
</code></pre>
<h2><a class="header" href="#整合-mybatis-plus" id="整合-mybatis-plus">整合 mybatis-plus</a></h2>
<p>mybatis-plus-boot-starter</p>
<pre><code class="language-java">public interface IAccountService extends IService&lt;Account&gt; {
}
@Service
public class AccountService extends ServiceImpl&lt;AccountMapper, Account&gt; implements IAccountService {
}


@mapper
// 或者启动类 @MapperScan(&quot;io.github.xiaoyureed.workflow.mapper&quot;)
public interface AccountMapper extends BaseMapper&lt;Account&gt; {
}


</code></pre>
<p>AccountMapper.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org/DTD Mapper 3.0&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;io.github.xiaoyureed.workflow.mapper.AccountMapper&quot;&gt;
&lt;/mapper&gt;


</code></pre>
<h2><a class="header" href="#整合-mybatis" id="整合-mybatis">整合 mybatis</a></h2>
<ul>
<li>依赖：mybatis-spring-boot-starter</li>
<li>@Mapper标注创建的xxxMapper接口；或者 在 启动类上 标注 @mapperscan(basepackage...)</li>
<li>@Select(&quot;SELECT * FROM USER WHERE NAME = #{name}&quot;)标注方法，还有@insert等；方法参数@Param(&quot;name&quot;)标注</li>
<li>通过@Autowired注入使用</li>
</ul>
<p>也可以直接引入 mybatisplus-spring-boot-starter 通过 mybatis plus 使用</p>
<h3><a class="header" href="#基本配置" id="基本配置">基本配置</a></h3>
<pre><code class="language-yml">server:
  port: 8080
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mall?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai
    username: root
    password: root
mybatis:
  # config-location属性和configuration属性不能同时指定
  #config-location: classpath:mybatis.xml
  type-aliases-package: me.zingon.pagehelper.model
  mapper-locations: classpath:mapper/*.xml
  #mapper-locations: {&quot;classpath:mapper/*.xml&quot;, &quot;classpath*:com/**/mapper/*.xml&quot;}
  configuration:
    map-underscore-to-camel-case: true
    default-fetch-size: 100
    default-statement-timeout: 30

</code></pre>
<h3><a class="header" href="#使用-拦截器-interceptor-plugins" id="使用-拦截器-interceptor-plugins">使用 拦截器 interceptor plugins</a></h3>
<h4><a class="header" href="#principle-of-plugins" id="principle-of-plugins">principle of plugins</a></h4>
<p>基于插件机制，基本上可以控制SQL执行的各个阶段，如执行阶段，参数处理阶段，语法构建阶段，结果集处理阶段，具体可以根据项目业务来实现对应业务逻辑。</p>
<p>设计模式：代理模式、责任链模式</p>
<h4><a class="header" href="#use-scenarios" id="use-scenarios">use scenarios</a></h4>
<ul>
<li>paging 拦截StatementHandler类的prepare方法，改变要执行的SQL语句为分页语句即可；</li>
<li>Assign default values to fields before SQL execution</li>
<li>SQL performance monitor 通过拦截Executor类的update, query等方法，用日志记录每个方法执行的时间</li>
</ul>
<h4><a class="header" href="#how-to-use-plugins" id="how-to-use-plugins">how to use plugins</a></h4>
<p>实现 Interceptor 接口, 标注@Intercepts(@Signature) , 参考 https://www.jianshu.com/p/0a72bb1f6a21</p>
<p>scenario 1: 直接给自定义拦截器添加一个 @Component注解 , 启动时不会自动调用自定义拦截器的setProperties方法
scenario 2: 无需 @component ,只需要 @bean ConfigurationCustomizer 中 addInterceptor , 不会自动调用setProperties方法 --- mybatis plus  中的配置方法
scenario 3: 无需 @component ,需要 @bean SqlSessionFactoryBean 中 setPlugins --- (app 启动时, setProperties被自动调用)</p>
<p>https://github.com/miaoxinwei/mybatis-crypt/blob/master/src/main/java/org/apache/ibatis/plugin/CryptInterceptor.java 日志脱敏<br />
TODO</p>
<pre><code class="language-java">/**
     * 在mybatis中可被拦截的类型有四种(按照拦截顺序):
     * &lt;p&gt;
     * Executor：执行 SQL 语句。
     * ParameterHandler：处理参数
     * ResultHandler：处理结果集。
     * StatementHandler：Sql语法构建。
     *
     * 每个类型可以被拦截的方法:
     *
     拦截的类	拦截的方法
     Executor	update, query, flushStatements, commit, rollback,getTransaction, close, isClosed
     ParameterHandler	getParameterObject, setParameters
     StatementHandler	prepare, parameterize, batch, update, query
     ResultSetHandler	handleResultSets, handleOutputParameters
     */
    //标识该类是一个拦截器；
    @Intercepts({
            //指明自定义拦截器需要拦截哪一个类型，哪一个方法(方法有重载, 所以还需要 指明 args 才能确定是哪个方法)
            @Signature(type = Executor.class, method = &quot;update&quot;, args = {MappedStatement.class, Object.class}),
            @Signature(type = Executor.class, method = &quot;query&quot;, args = {
                    MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
    })
    private static class SqlInterceptor implements Interceptor {

        @Override
        public Object intercept(Invocation invocation) throws Throwable {
//            Object target = invocation.getTarget(); //被代理对象
//            Method method = invocation.getMethod(); //代理方法
//            Object[] args = invocation.getArgs(); //方法参数

            Object[] args = invocation.getArgs();
            Object param = null;
            MappedStatement mappedStatement = (MappedStatement) args[0];
            if (args.length &gt; 1) {
                param = args[1];
            }
            String sql = sql(mappedStatement, param);
            return invocation.proceed();
        }

        private String sql(MappedStatement statement, Object param) {
            BoundSql boundSql = statement.getBoundSql(param);
            List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();
            //将原始sql中的空白字符（\s包括换行符，制表符，空格符）替换为&quot; &quot;
            String sql = boundSql.getSql().replaceAll(&quot;[\\s]+&quot;, &quot; &quot;);
            if (param == null || parameterMappings.size() == 0) {
                return sql;
            }

            org.apache.ibatis.session.Configuration configuration = statement.getConfiguration();
            TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry();
            if (typeHandlerRegistry.hasTypeHandler(param.getClass())) {
                sql = sql.replaceFirst(&quot;\\?&quot;, getParameterValue(param));
            } else {
                MetaObject metaObject = configuration.newMetaObject(param);
                for (ParameterMapping parameterMapping : parameterMappings) {
                    String propertyName = parameterMapping.getProperty();
                    if (metaObject.hasGetter(propertyName)) {
                        Object obj = metaObject.getValue(propertyName);
                        sql = sql.replaceFirst(&quot;\\?&quot;, getParameterValue(obj));
                    } else if (boundSql.hasAdditionalParameter(propertyName)) {
                        Object obj = boundSql.getAdditionalParameter(propertyName);
                        sql = sql.replaceFirst(&quot;\\?&quot;, getParameterValue(obj));
                    }
                }
            }
            return sql;
        }

        private String getParameterValue(Object obj) {
            String value = null;
            if (obj instanceof String) {
                value = &quot;'&quot; + obj.toString() + &quot;'&quot;;
            } else if (obj instanceof Date) {
                DateFormat formatter = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.CHINA);
                value = &quot;'&quot; + formatter.format(obj) + &quot;'&quot;;
            } else {
                if (obj != null) {
                    value = obj.toString();
                } else {
                    value = &quot;&quot;;
                }
            }
            return value;
        }

        /**
         * 生成代理对象
         * 可选
         * 我们可以决定是否要进行拦截, 如果拦截, 就返回代理后的对象
         *       * 如果不拦截, 则返回原始对象
         *
         *  每经过一个拦截器对象都会调用插件的plugin方法，也就是说，该方法会调用4次。根据@Intercepts注解来决定是否进行拦截处理
         */
        @Override
        public Object plugin(Object target) {
            //返回四大接口对象的代理对象, 表示始终会执行拦截
            return Plugin.wrap(target, this);

            // 控制是否拦截
            // 若类上加了 @Signature 指明了 拦截类型, 这一步就省了
//            if (target instanceof StatementHandler) {
//                return Plugin.wrap(target, this);
//            }
//            return target;
        }

        /**
         * 可选
         * 用于在 Mybatis 配置文件中指定一些属性的。类似 spring 中有 @value,
         * 一般不用
         */
        @Override
        public void setProperties(Properties properties) {
        }
    }

</code></pre>
<h3><a class="header" href="#typehandler" id="typehandler">typehandler</a></h3>
<p>https://blog.csdn.net/m0_37735176/article/details/103107759
https://www.cnblogs.com/haoliyou/p/13743698.html
https://www.cnblogs.com/dyf-stu/p/10162301.html</p>
<h3><a class="header" href="#全注解开发" id="全注解开发">全注解开发</a></h3>
<p>https://zhuanlan.zhihu.com/p/94554180
TODO</p>
<h3><a class="header" href="#动态定时刷新-sql-mapper-实现热加载" id="动态定时刷新-sql-mapper-实现热加载">动态定时刷新 SQL mapper 实现热加载</a></h3>
<p>https://veevv.com/2015/09/30/mybatis-mapper-xml-reloader/</p>
<pre><code class="language-java">@component
public class XMLMapperReloader implements ApplicationContextAware {

    private ConfigurableApplicationContext context = null;
    private HashMap&lt;String, Long&gt; fileMapping = new HashMap&lt;String, Long&gt;();
    private Scanner scanner = null;
    private String packageSearchPath = &quot;classpath:com/xx/xx/dao/*/*.xml&quot;;
    private ScheduledExecutorService service = null;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.context = (ConfigurableApplicationContext) applicationContext;

    }

    public XMLMapperReloader(){
        service = Executors.newScheduledThreadPool(1);
        service.scheduleAtFixedRate(new Task(), 5, 5, TimeUnit.SECONDS);
    }

    class Task implements Runnable {
        @Override
        public void run() {
            try {
                scanner = new Scanner();
                scanner.refreshMapper();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    @SuppressWarnings({ &quot;rawtypes&quot; })
    class Scanner {
        private Resource[] mapperLocations;

        public void refreshMapper() {
            try {
                SqlSessionFactory factory = context.getBean(SqlSessionFactory.class);
                Configuration configuration = factory.getConfiguration();

                // step.1 扫描文件
                try {
                    this.scanMapperXml();
                } catch (IOException e) {
                    return;
                }

                // step.2 判断是否有文件发生了变化
                if (this.isChanged()) {
                    System.out.println(&quot;==============检测到mapper有改变, 开始刷新...===============&quot;);
                    // step.2.1 清理
                    this.removeConfig(configuration);

                    // step.2.2 重新加载
                    for (Resource configLocation : mapperLocations) {
                        try {
                            XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(configLocation.getInputStream(), configuration, configLocation.toString(), configuration.getSqlFragments());
                            xmlMapperBuilder.parse();
                        } catch (IOException e) {
                            continue;
                        }
                    }
                    System.out.println(&quot;==============mapper刷新完毕===============&quot;);
                }


            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        private void scanMapperXml() throws IOException {
            this.mapperLocations = new PathMatchingResourcePatternResolver().getResources(packageSearchPath);
        }

        private void removeConfig(Configuration configuration) throws Exception {
            Class&lt;?&gt; classConfig = configuration.getClass();
            clearMap(classConfig, configuration, &quot;mappedStatements&quot;);
            clearMap(classConfig, configuration, &quot;caches&quot;);
            clearMap(classConfig, configuration, &quot;resultMaps&quot;);
            clearMap(classConfig, configuration, &quot;parameterMaps&quot;);
            clearMap(classConfig, configuration, &quot;keyGenerators&quot;);
            clearMap(classConfig, configuration, &quot;sqlFragments&quot;);

            clearSet(classConfig, configuration, &quot;loadedResources&quot;);

        }

        private void clearMap(Class&lt;?&gt; classConfig, Configuration configuration, String fieldName) throws Exception {
            Field field = classConfig.getDeclaredField(fieldName);
            field.setAccessible(true);
            Map mapConfig = (Map) field.get(configuration);
            mapConfig.clear();
        }

        private void clearSet(Class&lt;?&gt; classConfig, Configuration configuration, String fieldName) throws Exception {
            Field field = classConfig.getDeclaredField(fieldName);
            field.setAccessible(true);
            Set setConfig = (Set) field.get(configuration);
            setConfig.clear();
        }

        private boolean isChanged() throws IOException {
            boolean flag = false;
            for (Resource resource : mapperLocations) {
                String resourceName = resource.getFilename();

                boolean addFlag = !fileMapping.containsKey(resourceName);// 此为新增标识

                // 修改文件:判断文件内容是否有变化
                Long compareFrame = fileMapping.get(resourceName);
                long lastFrame = resource.contentLength() + resource.lastModified();
                boolean modifyFlag = null != compareFrame &amp;&amp; compareFrame.longValue() != lastFrame;// 此为修改标识

                // 新增或是修改时,存储文件
                if(addFlag || modifyFlag) {
                    fileMapping.put(resourceName, Long.valueOf(lastFrame));// 文件内容帧值
                    flag = true;
                }
            }
            return flag;
        }
    }

    public String getPackageSearchPath() {
        return packageSearchPath;
    }

    public void setPackageSearchPath(String packageSearchPath) {
        this.packageSearchPath = packageSearchPath;
    }
}


</code></pre>
<h3><a class="header" href="#自定义资源文件打包目录-and-开启占位符过滤" id="自定义资源文件打包目录-and-开启占位符过滤">自定义资源文件打包目录 and 开启占位符过滤</a></h3>
<p>mapper.xml 和 dao interface 放在一起: (开启资源文件过滤)</p>
<pre><code class="language-xml">&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;

		&lt;!-- maven 默认仅仅 将src/main/resources 下的文件打包到 jar
            若 mapper.xml 不在标准目录下, 需要指定资源过滤处理 --&gt;
		&lt;resources&gt;
			&lt;resource&gt;
				&lt;directory&gt;src/main/java&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.*&lt;/include&gt;
				&lt;/includes&gt;
                &lt;!-- 打包到哪里? 可省略, 默认 jar 根目录 --&gt;
                &lt;!-- &lt;targetPath&gt;META-INF/plexus&lt;/targetPath&gt; --&gt;
                &lt;!-- 是否开启资源文件占位符过滤 (如 ${project.version}), 默认 false --&gt;
                &lt;!-- &lt;filtering&gt;false&lt;/filtering&gt; --&gt;
			&lt;/resource&gt;
            &lt;!-- 可省略 --&gt;
			&lt;resource&gt;
				&lt;directory&gt;src/main/resources&lt;/directory&gt;
				&lt;includes&gt;
					&lt;include&gt;**/*.*&lt;/include&gt;
				&lt;/includes&gt;
			&lt;/resource&gt;
            &lt;!-- 添加额外的配置文件, 用来解析资源文件中的占位符 --&gt;
            &lt;filters&gt;
                &lt;filter&gt;src/main/filters/filter.properties&lt;/filter&gt;
            &lt;/filters&gt;
		&lt;/resources&gt;
	&lt;/build&gt;

</code></pre>
<h2><a class="header" href="#springboot-事务" id="springboot-事务">springboot 事务</a></h2>
<h3><a class="header" href="#事务基本使用" id="事务基本使用">事务基本使用</a></h3>
<p>Spring boot是默认启动事务的，只需要在类或者方法上添加@Transactional注解即可</p>
<p>不生效, 可能是:</p>
<p>1、首先要看数据库引擎是否支持注解，mysql默认引擎INNODB是支持的，但MYISAM是不支持的；</p>
<p>2、注解只能被应用到public方法上, 其它方法上不会报错，但不生效；</p>
<p>3、默认情况下只会对运行期异常(java.lang.RuntimeException及其子类)和 Error 进行回滚；</p>
<p>4、如果是其它异常, 手动指定<code>@Transactional(rollbackFor={Exception.class})</code></p>
<p>如果还是不生效, 手动回滚: <code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()</code></p>
<p>https://blog.csdn.net/laoxilaoxi_/article/details/99896738 使用 cglib or jdk 动态代理 <code>@EnableTransactionManagement(proxyTargetClass = true)// 使用cglib</code></p>
<h3><a class="header" href="#spring-事务传播失效的坑" id="spring-事务传播失效的坑">spring 事务传播失效的坑</a></h3>
<p>同一个 service bean 中的 事务方法互相调用, 如 a() 调用 b(), 只会使用 a() 的 事务, b 的无效, 因为事务本质是基于动态代理, 在同个 bean 中的方法互调, 发生在主动调用方 a() 的代理对象中, 所以只有 a() 的事务生效</p>
<p>如果 a(), b() 处于不同 service bean 中, 则 事务传播生效.</p>
<p>解决:</p>
<p>引入 starter aop, 会引入 aspectJ, @enableAspectJAutoProxy(exposeProxy=true) 开启 aspectJ 并暴露代理对象, 在互调的部分, 使用代理对象互调</p>
<pre><code class="language-java">public void a() {
    // b()
    // c()
    OrderService thisService = (OrderService) Aopcontext.currentProxy()
    thisService.b()
    thisService.c()
}
</code></pre>
<h3><a class="header" href="#transactional-注解" id="transactional-注解">Transactional 注解</a></h3>
<p>事务超时</p>
<p>@transaction(timeout=...) unit: s</p>
<p>隔离级别</p>
<p>@transaction(isolation=...)</p>
<h2><a class="header" href="#缓存" id="缓存">缓存</a></h2>
<h3><a class="header" href="#springboot-starter-cache" id="springboot-starter-cache">springboot-starter-cache</a></h3>
<p>引入 redis starter, cache starter</p>
<p>配置文件中配置类型为 redis</p>
<p>注解:</p>
<ul>
<li>@cacheable({&quot;xxxCache&quot;}, sync=true) 缓存数据, 方法上, 指定缓存分区, sync 加锁防止缓存击穿</li>
<li>@cacheEvic(value=&quot;xxx&quot;, allEntries=true) 删除缓存, allEntries 表示删除分区 cache 下的全部缓存对</li>
<li>@cacheput 更新</li>
<li>caching 组合多个操作</li>
<li>@cacheconfig 在类级别共享缓存配置</li>
<li>@enablecaching 开启缓存</li>
</ul>
<p>自定义配置</p>
<pre><code class="language-java">// 自定义缓存 key
// 自定义 json 序列化, 不用默认的 jdk 序列化
// 自定义过期时间, 默认-1 永不过期
</code></pre>
<p>优势是简单方便,</p>
<p>对于读模式:</p>
<ul>
<li>缓存穿透 (查询一个 null 数据), 配置 cache-null-value=true 缓存 null 数据</li>
<li>缓存击穿 (大量并发同时请求一个快过期的key): </li>
<li>雪崩(大量key 同时过期), 配置 time-to-live 过期时间, </li>
</ul>
<p>对于写模式: 没有很好的内置解决方法, 可以通过:</p>
<ul>
<li>读写加锁</li>
<li>canal 中间件</li>
</ul>
<h3><a class="header" href="#caffeine" id="caffeine">caffeine</a></h3>
<p>Caffeine是使用Java8对Guava缓存的重写版本，在Spring Boot 2.0中将取代Guava</p>
<h2><a class="header" href="#配合-h2-数据库进行开发" id="配合-h2-数据库进行开发">配合 h2 数据库进行开发</a></h2>
<h3><a class="header" href="#h2-和-spring-data-jpa-配合" id="h2-和-spring-data-jpa-配合">h2 和 spring data jpa 配合</a></h3>
<p>无需任何配置文件</p>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient // compared with @EnableEurekaClient, more comprehensive
public class ReservationServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ReservationServiceApplication.class, args);
    }

    @Bean
    public ApplicationRunner initData(ReservationRepository reservationRepository) {
        return args -&gt; {
            Stream.of(&quot;ehllo&quot;, &quot;hello&quot;, &quot;llhoe&quot;, &quot;jojo&quot;, &quot;猕猴桃&quot;)
                    .forEach(name -&gt; reservationRepository.save(new Reservation(null, name)));
            reservationRepository.findAll().forEach(System.out::println);
        };
    }

}

@RepositoryRestResource // publish repository as rest service
        // 比如查询所有 /reservations, 查某个 /reservations/1, 搜索 /reservations/search ...
interface ReservationRepository extends JpaRepository&lt;Reservation, Long&gt; {

    /**
     * customized rest service
     *
     * http://localhost:8080/reservations/search/by-name?name=hello
     */
    @RestResource(path = &quot;by-name&quot;)
    Optional&lt;Reservation&gt; findByName(String name);
}

@RestController
@RefreshScope
class ConfigRefreshTestController {

    private final String message;

    private final DiscoveryClient discoveryClient;

    public ConfigRefreshTestController(@Value(&quot;${message: defaultMsg}&quot;) String message,
                                       @Autowired DiscoveryClient discoveryClient) {
        this.message = message;
        this.discoveryClient = discoveryClient;
    }

    @RequestMapping(value = &quot;/message&quot;, method = RequestMethod.GET)
    public String readMessage() {
        return this.message;
    }

    @RequestMapping(&quot;/eureka-services&quot;)
    public ResponseEntity&lt;List&lt;String&gt;&gt; eurekaServices() {
        return new ResponseEntity&lt;&gt;(discoveryClient.getServices(), HttpStatus.OK);
    }
}

/**
 * entity: 预定
 */
@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor // if removed, jpa error may be produced
class Reservation {

    @Id
    @GeneratedValue
    private Long id;

    private String name;
}
</code></pre>
<h3><a class="header" href="#和-mybatis-plus-配合" id="和-mybatis-plus-配合">和 mybatis-plus 配合</a></h3>
<p><a href="https://mp.baomidou.com/guide/quick-start.html">h2 和 mybatis-plus 配合</a>:</p>
<pre><code class="language-yml"># DataSource Config
spring:
  datasource:
    driver-class-name: org.h2.Driver
    schema: classpath:db/schema-h2.sql
    data: classpath:db/data-h2.sql
    url: jdbc:h2:mem:test
    username: root
    password: test
</code></pre>
<p><code>@MapperScan(&quot;mapper package&quot;)</code></p>
<p>mapper extends BaseMapper</p>
<h2><a class="header" href="#多数据源" id="多数据源">多数据源</a></h2>
<h3><a class="header" href="#基本配置-全注解开发" id="基本配置-全注解开发">基本配置 全注解开发</a></h3>
<p>启动类需要排除自动配置@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})</p>
<pre><code class="language-props">server.port=8335
# 配置第一个数据源
spring.datasource.hikari.db1.jdbc-url=jdbc:mysql://127.0.0.1:3306/erp?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=GMT%2B8
spring.datasource.hikari.db1.username=root
spring.datasource.hikari.db1.password=153963
spring.datasource.hikari.db1.driver-class-name=com.mysql.cj.jdbc.Driver
# 配置第二个数据源
spring.datasource.hikari.db2.jdbc-url=jdbc:mysql://127.0.0.1:3306/erp2?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=GMT%2B8
spring.datasource.hikari.db2.username=root
spring.datasource.hikari.db2.password=153963
spring.datasource.hikari.db2.driver-class-name=com.mysql.cj.jdbc.Driver
</code></pre>
<pre><code class="language-java">@Configuration
@MapperScan(basePackages = &quot;top.snailclimb.db1.dao&quot;, sqlSessionTemplateRef = &quot;db1SqlSessionTemplate&quot;)
public class DataSource1Config {

    /**
     * 生成数据源.  @Primary 注解声明为默认数据源
     */
    @Bean(name = &quot;db1DataSource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.hikari.db1&quot;)
    @Primary // 声明为默认数据源, 防止 dao 层的类忘记指定 @Qualifier(&quot;db1SqlSessionTemplate&quot;), 可以使用默认的
    public DataSource testDataSource() {
        return DataSourceBuilder.create().build();
    }

    /**
     * 创建 SqlSessionFactory
     */
    @Bean(name = &quot;db1SqlSessionFactory&quot;)
    @Primary
    public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;db1DataSource&quot;) DataSource dataSource) throws Exception {
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        // 若有 mapper.xml , 需要指定位置
        // 若是全注解开发, 无需指定
        //  bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mybatis/mapper/db1/*.xml&quot;));
        return bean.getObject();
    }

    /**
     * 配置事务管理
     */
    @Bean(name = &quot;db1TransactionManager&quot;)
    @Primary
    public DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;db1DataSource&quot;) DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    /**
    SqlSessionTemplate是线程安全的，可以被多个DAO所共享使用。
    */
    @Bean(name = &quot;db1SqlSessionTemplate&quot;)
    @Primary
    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(&quot;db1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception {
        return new SqlSessionTemplate(sqlSessionFactory);
    }

}




@Configuration
@MapperScan(basePackages = &quot;top.snailclimb.db2.dao&quot;, sqlSessionTemplateRef = &quot;db2SqlSessionTemplate&quot;)
public class DataSource2Config {

    @Bean(name = &quot;db2DataSource&quot;)
    @ConfigurationProperties(prefix = &quot;spring.datasource.hikari.db2&quot;)
    public DataSource testDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = &quot;db2SqlSessionFactory&quot;)
    public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;db2DataSource&quot;) DataSource dataSource) throws Exception {
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        //bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mybatis/mapper/db2/*.xml&quot;));
        return bean.getObject();
    }

    @Bean(name = &quot;db2TransactionManager&quot;)
    public DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;db2DataSource&quot;) DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }

    @Bean(name = &quot;db2SqlSessionTemplate&quot;)
    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(&quot;db2SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception {
        return new SqlSessionTemplate(sqlSessionFactory);
    }

}






dao 开发:

@Qualifier(&quot;db1SqlSessionTemplate&quot;)
public interface UserDao {
    /**
     * 通过名字查询用户信息

    mybatis中#{}和${}符号的区别 
    使用#{}意味着使用的预编译的语句，即 preparedStatement, 替换占位符时, 会为参数添加引号作为 string 传入, 防止注入攻击
    也不是说${}一无是处，比如在MyBatis动态排序时使用order by +${动态参数}，使用${}而不是#{}, 动态参数可以传入不定个数的字段.


     */
    @Select(&quot;SELECT * FROM user WHERE name = #{name}&quot;)
    User findUserByName(String name);

}
@Qualifier(&quot;db2SqlSessionTemplate&quot;)
public interface MoneyDao {

    /**
     * 通过id 查看工资详情
     */
    @Select(&quot;SELECT * FROM money WHERE id = #{id}&quot;)
    Money findMoneyById(@Param(&quot;id&quot;) int id);
}


</code></pre>
<h3><a class="header" href="#abstractroutingdatasource-动态数据源切换" id="abstractroutingdatasource-动态数据源切换">AbstractRoutingDataSource 动态数据源切换</a></h3>
<p>https://blog.csdn.net/qq_37502106/article/details/91044952
https://www.cnblogs.com/wyb628/p/7240061.html</p>
<h2><a class="header" href="#多数据库类型-databaseidprovider" id="多数据库类型-databaseidprovider">多数据库类型 databaseIdProvider</a></h2>
<p>https://www.cnblogs.com/valten/p/12083128.html# 配置 MySQL Oracle 共同使用</p>
<pre><code class="language-java">
@Configuration
public class DataSourceConfig {
    @Value(&quot;${mybatis.mapper-locations}&quot;)
    private String mapperLocations;

    @Primary
    @Bean(name = &quot;dataSource&quot;)
    @ConfigurationProperties(&quot;spring.datasource.hikari&quot;)
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    public JdbcTemplate jdbcTemplate() {
        return new JdbcTemplate(dataSource());
    }

    //如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；
    // databaseId 是 mybatis 的内置参数
    //如果带或者不带的语句都有，则不带的会被忽略。新增，修改和删除都有这个属性
    /**
    
    &lt;!-- mybatis动态sql的两个内置参数 , 可以直接在 mapper.xml 中使用
           _parameter:代表整个参数
                单个参数：_parameter就是这个参数
                多个参数：参数会被封装为一个map:_parameter就是代表这个map             
           _databaseId:如果配置了databaseIdProvider标签
                _databaseId 就是代表当前数据库的别名Oracle
      --&gt;
      &lt;!-- List&lt;Employee&gt; getEmpsTestInnerParameter(Employee employee); --&gt;
      &lt;select id=&quot;getEmpsTestInnerParameter&quot; resultType=&quot;com.hand.mybatis.bean.Employee&quot;&gt;
          SELECT * FROM emp 
          &lt;if test=&quot;_parameter!=null&quot;&gt;      _parameter相当于传入的参数employee,判断employee是否为空，若不为空则执行where条件 
           where ename=#{_parameter.eName}   
          &lt;/if&gt;
      &lt;/select&gt;
    */
    @Bean
    public DatabaseIdProvider databaseIdProvider() {
        DatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
        Properties p = new Properties();
        p.setProperty(&quot;Oracle&quot;, &quot;oracle&quot;);
        p.setProperty(&quot;MySQL&quot;, &quot;mysql&quot;);
        p.setProperty(&quot;PostgreSQL&quot;, &quot;postgresql&quot;);
        p.setProperty(&quot;DB2&quot;, &quot;db2&quot;);
        p.setProperty(&quot;SQL Server&quot;, &quot;sqlserver&quot;);
        databaseIdProvider.setProperties(p);
        return databaseIdProvider;
    }

    @Primary
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(@Qualifier(&quot;dataSource&quot;) DataSource dataSource) throws Exception {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        factoryBean.setDatabaseIdProvider(databaseIdProvider());
        factoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));
        return factoryBean;
    }
}


</code></pre>
<pre><code class="language-yml"># application.yml
# 切换对应的环境 postgresql mysql
spring:
  profiles:
    active: postgresql

# mybatis配置
mybatis:
  mapper-locations: classpath:mapper/**/*.xml
  type-aliases-package: com.valten.**.model

# showSql 控制台打印sql日志
logging:
  level:
    com:
      valten:
        dao: debug

---
# application-mysql.yml#
# 端口
server:
  port: 8001

# 数据源配置
spring:
  datasource:
    hikari:
      jdbc-url: jdbc:mysql://127.0.0.1:3306/test?&amp;useSSL=false
      driver-class-name: com.mysql.jdbc.Driver
      username: root
      password: 123456

---      
# application-postgresql.yml#
# 端口
server:
  port: 8002

# 数据源配置
spring:
  datasource:
    hikari:
      jdbc-url: jdbc:postgresql://127.0.0.1:5432/test
      driver-class-name: org.postgresql.Driver
      username: root
      password: 123456
        
</code></pre>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!--oracle--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.oracle&lt;/groupId&gt;
    &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;
    &lt;version&gt;11.2.0.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--postgresql--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;9.4.1212&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 集成mybatis --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--fastjson--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
    &lt;version&gt;1.2.16&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- druid数据库连接池组件 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h1><a class="header" href="#web-相关" id="web-相关">web 相关</a></h1>
<h2><a class="header" href="#加解密" id="加解密">加解密</a></h2>
<p>https://github.com/yinjihuan/monkey-api-encrypt api 加解密 </p>
<p>https://www.baeldung.com/java-aes-encryption-decryption 加密科普</p>
<p>https://www.cnblogs.com/loong-hon/p/11225407.html</p>
<p>https://www.javatt.com/p/22814
https://blog.csdn.net/github_36086968/article/details/103424945
https://jueee.github.io/2021/01/2021-01-06-SpringBoot%E5%AE%9E%E7%8E%B0API%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AEAES%E5%8A%A0%E5%AF%86/</p>
<h2><a class="header" href="#springboot-发送-https-或者-http-客户端-client" id="springboot-发送-https-或者-http-客户端-client">springboot 发送 https 或者 http 客户端 client</a></h2>
<p>https://blog.csdn.net/defonds/article/details/86594441 (https://prasans.info/making-https-call-using-apache-httpclient/)
https://www.cnblogs.com/lfstudy/p/13793625.html
https://www.cnblogs.com/dbei/articles/12746191.html
https://segmentfault.com/a/1190000014456939 使用 resttemplate</p>
<p>https://square.github.io/okhttp/
https://square.github.io/okhttp/https/</p>
<h3><a class="header" href="#发送-http-client" id="发送-http-client">发送 http client</a></h3>
<h3><a class="header" href="#发送-https-client" id="发送-https-client">发送 https client</a></h3>
<p>okhttp</p>
<pre><code class="language-java">@Configuration
public class JavaConfig {

    @Bean(name = &quot;myRestTemplate&quot;)
    public RestTemplate restTemplate() throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException {
        TrustStrategy acceptingTrustStrategy = (X509Certificate[] chain, String authType) -&gt; true;
        SSLContext sslContext = org.apache.http.ssl.SSLContexts.custom()
                .loadTrustMaterial(null, acceptingTrustStrategy)
                .build();
        SSLConnectionSocketFactory csf = new SSLConnectionSocketFactory(sslContext);
        CloseableHttpClient httpClient = HttpClients.custom()
                .setSSLSocketFactory(csf)
                .build();
        HttpComponentsClientHttpRequestFactory requestFactory =
                new HttpComponentsClientHttpRequestFactory();
        requestFactory.setHttpClient(httpClient);

        //60s
        requestFactory.setConnectTimeout(60 * 1000);
        requestFactory.setReadTimeout(60 * 1000);
        RestTemplate restTemplate = new RestTemplate(requestFactory);
        restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8));
        return restTemplate;
    }
}

</code></pre>
<h2><a class="header" href="#requestcontextholder" id="requestcontextholder">RequestContextHolder</a></h2>
<pre><code class="language-java">ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder
        .getRequestAttributes();
HttpServletRequest request = attributes.getRequest();

</code></pre>
<h2><a class="header" href="#解决-api-版本共存" id="解决-api-版本共存">解决 api 版本共存</a></h2>
<p>https://blog.csdn.net/j903829182/article/details/81836551, https://www.cnblogs.com/huanshilang/p/12097048.html 放在 url
TODO</p>
<h3><a class="header" href="#requestmappinghandlermapping" id="requestmappinghandlermapping">RequestMappingHandlerMapping</a></h3>
<h3><a class="header" href="#request-matcher" id="request-matcher">request matcher</a></h3>
<pre><code class="language-java">private RequestMatcher matcherHtml = new AntPathRequestMatcher(&quot;/**&quot;, &quot;GET&quot;);

把ServletRequest转化成HttpServletRequest,强转即可

调用matches方法进行匹配 boolean matches(HttpServletRequest request)

</code></pre>
<h3><a class="header" href="#request-condition" id="request-condition">request condition</a></h3>
<p>在 spring mvc 中，通过DispatchServlet接收客户端发起的一个请求之后，会通过 HanderMapping 来获取对应的请求处理器；而 HanderMapping 如何找到可以处理这个请求的处理器呢，这就需要 RequestCondition 来决定了</p>
<p>最终的实现类可能是针对以下情况之一：路径匹配，头部匹配，请求参数匹配，可产生MIME匹配，可消费MIME匹配，请求方法匹配，或者是以上各种情况的匹配条件的一个组合</p>
<pre><code class="language-java">public interface RequestCondition&lt;T&gt; {
    // 一个http接口上有多个条件规则时，用于合并
    //比如类上指定了@RequestMapping的 url 为 root - 而方法上指定的@RequestMapping的 url 为 method - 那么在获取这个接口的 url 匹配规则时，类上扫描一次，方法上扫描一次，这个时候就需要把这两个合并成一个，表示这个接口匹配root/method
	T combine(T other);

	// 判断是否成功，失败返回 null；否则，则返回匹配成功的条件
	// 举个例子来讲，如果当前请求匹配条件是一个路径匹配条件，包含多个路径匹配模板，
	// 并且其中有些模板和指定请求request匹配，那么返回的新建的请求匹配条件将仅仅
	// 包含和指定请求request匹配的那些路径模板。
	@Nullable
	T getMatchingCondition(HttpServletRequest request);

	// 多个都满足条件时，用来指定具体选择哪一个。
	int compareTo(T other, HttpServletRequest request);

}


</code></pre>
<p>AbstractRequestCondition 实现了equals,hashCode和toString 通用方法, 还通过protected抽象方法约定了实现类其他的一些内部通用逻辑</p>
<p>具体实现类:</p>
<ul>
<li>PatternsRequestCondition	路径匹配条件</li>
<li>RequestMethodsRequestCondition	请求方法(get post delete..)匹配条件</li>
<li>ParamsRequestCondition	请求参数匹配条件</li>
<li>HeadersRequestCondition	头部信息匹配条件</li>
<li>ConsumesRequestCondition	可消费MIME匹配条件</li>
<li>ProducesRequestCondition	可生成MIME匹配条件</li>
</ul>
<h2><a class="header" href="#接收参数相关的注解" id="接收参数相关的注解">接收参数相关的注解</a></h2>
<pre><code class="language-java">@RequestParam 可以用于从query parameters, form data, 和parts in multipart requests中获取参数。

即GET请求和POST（application/x-www-form-urlencoded ，multipart/form-data）请求的参数都可以使用@RequestParam

@RequestPart 用在multipart/form-data表单提交请求的方法上，支持的请求方法的方式MultipartFile，属于Spring的MultipartResolver类。

// 前三种支持 application/x-www-form-urlencoded;charset=UTF-8’ 格式 (表单提交), 是浏览器默认的编码格式。
// 
// multipart/form-data 格式 区别: 不会对参数编码，使用的boundary(分割线)，相当于&amp;，boundary的值是----Web**AJv3。 文件上传必须要这种格式, 也可用于键值对参数，最后连接成一串字符传输 (ref: https://www.jianshu.com/p/53b5bd0f1d44)
// 
// @requestParam 注解方法参数, 可省略, 可以有多个
@ApiOperation(&quot;查询用户&quot;)
    @PostMapping(&quot;/detailByParam&quot;)
    public void detailByParam(@RequestParam (value = &quot;id&quot;) Integer id,@RequestParam(value = &quot;roleName&quot;) String roleName,@RequestParam(value = &quot;roleDes&quot;) String roleDes) {
    	System.out.println(&quot;&gt;&gt;&gt;id=&quot;+id+&quot;,roleName=&quot;+roleName+&quot;,roleDes=&quot;+roleDes);
        // &gt;&gt;&gt;id=1,roleName=admin,roleDes=拥有admin权限
	}


@ApiOperation(&quot;查询用户&quot;)
    @PostMapping(&quot;/detailByParam&quot;)
    public void detailByParam(@RequestParam Map&lt;String, String&gt; params) {
        System.out.println(&quot;&gt;&gt;&gt;id=&quot;+params.get(&quot;id&quot;)+&quot;,roleName=&quot;+params.get(&quot;roleName&quot;)+&quot;,roleDes=&quot;+params.get(&quot;roleDes&quot;));
        // &gt;&gt;&gt;id=1,roleName=admin,roleDes=拥有admin权限
    }



@ApiOperation(&quot;查询用户&quot;)
    @PostMapping(&quot;/detailByParam&quot;)
    public void detailByParam(@RequestBody String params) {
        System.out.println(&quot;&gt;&gt;&gt;&quot;+params);
        // &gt;&gt;&gt;id=1&amp;roleName=admin&amp;roleDes=%E6%8B%A5%E6%9C%89admin%E6%9D%83%E9%99%90
        // 
        // 参数用 &amp; 隔离开, 对于Get请求，是将参数转换?key=value&amp;key=value格式，连接到url后
        // 如果参数值中需要&amp;，则必须对其进行编码。编码格式就是application/x-www-form-urlencoded（将键值对的参数用&amp;连接起来，如果有空格，将空格转换为+加号；有特殊符号，将特殊符号转换为ASCII HEX值）
    }




// 仅支持 application/json  格式, 不支持 application/x-www-form-urlencoded;charset=UTF-8’
@ApiOperation(&quot;查询用户&quot;)
    @PostMapping(&quot;/detailByParam&quot;)
    public void detailByParam(@RequestBody GetRoleParam getRoleParam) {// @RequestBody 注解参数, 不可省略, 最多只能一个
        System.out.println(&quot;&gt;&gt;&gt;&quot;+getRoleParam); 
    }
</code></pre>
<h2><a class="header" href="#自定义接收参数类型" id="自定义接收参数类型">自定义接收参数类型</a></h2>
<p>若果只是一个两个类型需要转换, 直接实现  org.springframework.core.convert.converter.Converter 然后标注 component 即可 (包含连个泛型, 第一个是请求中原始类型如 Integer, 第二个泛型是 希望转换后的类型如 enum),</p>
<p>对 get/post 请求都有效</p>
<pre><code class="language-java">// 例子
@Component
public class StringToDateConverter implements Converter&lt;String, Date&gt; {

    private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);

    @Override
    public Date convert(String s) {
        Date parse = null;
        try {
            parse = simpleDateFormat.parse(s);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return parse;
    }
}


// 实例案例: 枚举转换
@Data
public class QueryRequest {
    private GenderEnum gender;
}
@GetMapping(&quot;/get&quot;)//gender 只能接收到 MALE 、FEMALE 这样的参数，除此以外，均会报类型不匹配的错误信息，此时是无法处理 0 、1 这样的参数的
public Dict testGet(QueryRequest request) {
    log.info(&quot;【get-request】= {}&quot;, JSONUtil.toJsonStr(request));
    return Dict.create().set(&quot;get-request&quot;, request);
}

@PostMapping(&quot;/post&quot;)
public Dict testPost(@RequestBody QueryRequest request) {
    log.info(&quot;【post-request】= {}&quot;, JSONUtil.toJsonStr(request));
    return Dict.create().set(&quot;post-request&quot;, request);
}

// 增加一个转换器即可
@component
public class IntegerCodeToGenderEnumConverter implements Converter&lt;Integer, GenderEnum&gt; {
    private Map&lt;Integer, GenderEnum&gt; enumMap = Maps.newHashMap();
 
    public IntegerCodeToGenderEnumConverter() {
        for (GenderEnum genderEnum : GenderEnum.values()) {
            enumMap.put(genderEnum.getCode(), genderEnum);
        }
    }
 
    @Override
    public GenderEnum convert(Integer source) {
        GenderEnum genderEnum = enumMap.get(source);
        if (ObjectUtil.isNull(genderEnum)) {
            throw new IllegalArgumentException(&quot;无法匹配对应的枚举类型&quot;);
        }
        return genderEnum;
    }
}
</code></pre>
<p>当我们的枚举类特别多的时候, 不使用上面直接使用 Converter 的这种方法，我们引入 ConverterFactory 来解决这个问题</p>
<pre><code class="language-java">//通用枚举接口
public interface BaseEnum {
    /**
     * 获取枚举编码
     *
     * @return 编码
     */
    Integer getCode();
}
@Getter
public enum GenderEnum implements BaseEnum {
    /**
     * 男
     */
    MALE(0),
    /**
     * 女
     */
    FEMALE(1);
 
    /**
     * 性别编码
     */
    private Integer code;
 
    GenderEnum(int code) {
        this.code = code;
    }
 
}

public class IntegerToEnumConverter&lt;T extends BaseEnum&gt; implements Converter&lt;Integer, T&gt; {
    private Map&lt;Integer, T&gt; enumMap = Maps.newHashMap();
 
    public IntegerToEnumConverter(Class&lt;T&gt; enumType) {
        T[] enums = enumType.getEnumConstants();
        for (T e : enums) {
            enumMap.put(e.getCode(), e);
        }
    }
 
    @Override
    public T convert(Integer source) {
        T t = enumMap.get(source);
        if (ObjectUtil.isNull(t)) {
            throw new IllegalArgumentException(&quot;无法匹配对应的枚举类型&quot;);
        }
        return t;
    }
}
//创建对应的自定义 ConverterFactory 工厂类
public class IntegerCodeToEnumConverterFactory implements ConverterFactory&lt;Integer, BaseEnum&gt; {
    private static final Map&lt;Class, Converter&gt; CONVERTERS = Maps.newHashMap();
 
    /**
     * 获取一个从 Integer 转化为 T 的转换器，T 是一个泛型，有多个实现
     *
     * @param targetType 转换后的类型
     * @return 返回一个转化器
     */
    @Override
    public &lt;T extends BaseEnum&gt; Converter&lt;Integer, T&gt; getConverter(Class&lt;T&gt; targetType) {
        Converter&lt;Integer, T&gt; converter = CONVERTERS.get(targetType);
        if (converter == null) {
            converter = new IntegerToEnumConverter&lt;&gt;(targetType);
            CONVERTERS.put(targetType, converter);
        }
        return converter;
    }
}
// 注册工厂
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
 
    /**
     * 枚举类的转换器工厂 addConverterFactory
     */
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverterFactory(new IntegerCodeToEnumConverterFactory());
        registry.addConverterFactory(new StringCodeToEnumConverterFactory());
    }
}
</code></pre>
<h2><a class="header" href="#返回图片" id="返回图片">返回图片</a></h2>
<pre><code class="language-java">@Controller
@RequestMapping(value = &quot;/image&quot;)
public class ImageController {
    @RequestMapping(value = &quot;/get&quot;)
    @ResponseBody
    public void getImage(HttpServletResponse response) throws IOException {
        File file = new File(&quot;D:/test.jpg&quot;);
        FileInputStream inputStream = new FileInputStream(file);
        byte[] bytes = new byte[inputStream.available()];
        
        response.setContentType(&quot;image/jpeg&quot;);
        OutputStream out = response.getOutputStream();
       out.write(result);
       out.flush();
       //关闭响应输出流
       out.close();
       
    }
}



 
@Controller
@RequestMapping(value = &quot;/image&quot;)
public class ImageController {
    @RequestMapping(value = &quot;/get&quot;,produces = MediaType.IMAGE_JPEG_VALUE) //如果是网页的话，produces = MediaType.TEXT_HTML
    @ResponseBody
    public byte[] getImage() throws IOException {
        File file = new File(&quot;D:/test.jpg&quot;);
        FileInputStream inputStream = new FileInputStream(file);
        byte[] bytes = new byte[inputStream.available()];
        inputStream.read(bytes, 0, inputStream.available());
        return bytes;
    }
}
</code></pre>
<h2><a class="header" href="#rest-api-文档" id="rest-api-文档">rest api 文档</a></h2>
<h3><a class="header" href="#knife4j" id="knife4j">knife4j</a></h3>
<h3><a class="header" href="#springdoc-openapi" id="springdoc-openapi">springdoc-openapi</a></h3>
<p>https://springdoc.org/</p>
<p>https://www.baeldung.com/spring-rest-openapi-documentation</p>
<h3><a class="header" href="#swagger3" id="swagger3">swagger3</a></h3>
<p>访问 /swagger-ui.html or /swagger-ui/index.html (springdoc.swagger-ui.path=/swagger-ui.html)</p>
<pre><code class="language-xml">&lt;dependency&gt;
     &lt;groupId&gt;io.springfox&lt;/groupId&gt;
      &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;
      &lt;version&gt;3.0.0&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<pre><code class="language-java">@EnableOpenApi
@SpringBootApplication
@MapperScan(basePackages = {&quot;cn.ruiyeclub.dao&quot;})
public class Swagger3Application {
    public static void main(String[] args) {
        SpringApplication.run(Swagger3Application.class, args);
    }
}


@Configuration
public class Swagger3Config {
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.OAS_30)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))
                .paths(PathSelectors.any())
                .build()
                // 协议使用 http; 默认是 https
                .protocols(Stream.of(&quot;http&quot;).collect(Collectors.toSet()));
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title(&quot;Swagger3接口文档&quot;)
                .version(&quot;1.0&quot;)
                .build();
    }
}

</code></pre>
<h3><a class="header" href="#集成swagger2" id="集成swagger2">集成swagger2</a></h3>
<p>http://springfox.github.io/springfox/docs/snapshot/#springfox-spring-mvc-and-spring-boot</p>
<ul>
<li>swagger2配置类，和APP启动类同级，@Configuration，@EnableSwagger2</li>
<li>访问：http://localhost:8080/swagger-ui.html</li>
<li>配置mvc时候， 如果继承了WebMvcConfigurationSupport， 需要重新注入资源文件， 否则访问不到swagger-ui.html;(<a href="https://blog.csdn.net/zjcjava/article/details/78064264">ref</a>)</li>
<li>分环境开启 
<ul>
<li>在配置类上标注 @Profile({&quot;dev&quot;,&quot;test&quot;})</li>
<li>或者 在new Docket里添加.Enable(true/false)方法</li>
</ul>
</li>
<li>springfox.documentation.swagger-ui.enabled=false 生产 env 下 close</li>
</ul>
<pre><code class="language-xml">&lt;!-- 会引入 谷歌的 guava --&gt;
&lt;!-- 版本可省略 --&gt;
&lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.6.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.6.1&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre>
<pre><code class="language-java">
@Configuration
@EnableSwagger2
public class Swagger2Config {
    // 添加 swagger 静态资源处理
    // 一般我们会设置 mvc 中, spring.resources.add-mappings=false, 对静态资源默认不处理, 这是需要为 swagger 添加例外 (还会设置 spring.mvc.throw-exception-if-no-handler-found=true 没找到 Handler时直接抛出异常)
//    @Bean
//    public WebMvcConfigurer swaggerPassConfigure() {
//        return new WebMvcConfigurer() {
//            @Override
//            public void addResourceHandlers(ResourceHandlerRegistry registry) {
//                registry.addResourceHandler(&quot;swagger-ui.html&quot;)
//                        .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;, &quot;/static&quot;, &quot;/public&quot;);
//
//                registry.addResourceHandler(&quot;/webjars/**&quot;)
//                        .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);
//            }
//        };
//    }

    @Bean
    public Docket api() {

        ParameterBuilder ticketPar = new ParameterBuilder();
        List&lt;Parameter&gt; pars = new ArrayList&lt;&gt;();
        ticketPar.name(&quot;Access-Token&quot;).description(&quot;Rest接口权限认证token,无需鉴权可为空&quot;)
                .modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;)
                //header中的ticket参数非必填，传空也可以
                .required(false).build();
        //根据每个方法名也知道当前方法在设置什么参数
        pars.add(ticketPar.build());


        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                // 根据包名扫描controller
                // 自行修改为自己的包路径
                .apis(RequestHandlerSelectors.basePackage(&quot;com.tgpms&quot;)) // 多包配置: https://www.jianshu.com/p/78309feb5d5a
                // 扫描所有controller
                // .apis(RequestHandlerSelectors.any()) 
                // 指定扫描部分注解标注的 controller
                // .apis(RequestHandlerSelectors.withMethodAnnotation(Api.class/ApiOperation.class))

                .paths(PathSelectors.any()) // .paths() 这个是包路径下的路径,PathSelectors.any()是包下所有路径                
                .build()
                // 全局设置请求参数
                .globalOperationParameters(pars);
        

        //生成全局通用参数
    // private List&lt;RequestParameter&gt; getGlobalRequestParameters() {
    //     List&lt;RequestParameter&gt; parameters = new ArrayList&lt;&gt;();
    //     parameters.add(new RequestParameterBuilder()
    //             .name(&quot;appid&quot;)
    //             .description(&quot;平台id&quot;)
    //             .required(true)
    //             .in(ParameterType.QUERY)
    //             .query(q -&gt; q.model(m -&gt; m.scalarModel(ScalarType.STRING)))
    //             .required(false)
    //             .build());
    //     parameters.add(new RequestParameterBuilder()
    //             .name(&quot;udid&quot;)
    //             .description(&quot;设备的唯一id&quot;)
    //             .required(true)
    //             .in(ParameterType.QUERY)
    //             .query(q -&gt; q.model(m -&gt; m.scalarModel(ScalarType.STRING)))
    //             .required(false)
    //             .build());
    //     parameters.add(new RequestParameterBuilder()
    //             .name(&quot;version&quot;)
    //             .description(&quot;客户端的版本号&quot;)
    //             .required(true)
    //             .in(ParameterType.QUERY)
    //             .query(q -&gt; q.model(m -&gt; m.scalarModel(ScalarType.STRING)))
    //             .required(false)
    //             .build());
    //      return parameters;
    // }

    // //生成通用响应信息
    // private List&lt;Response&gt; getGlobalResonseMessage() {
    //     List&lt;Response&gt; responseList = new ArrayList&lt;&gt;();
    //     responseList.add(new ResponseBuilder().code(&quot;404&quot;).description(&quot;找不到资源&quot;).build());
    //      return responseList;
    // }
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title(&quot;online exam by springboot&quot;)
                .description(&quot;在线考试系统 by 梁山广 at 2020&quot;)
                .termsOfServiceUrl(&quot;https://github.com/19920625lsg/spring-boot-online-exam&quot;)
                .version(&quot;1.0&quot;)
                .contact(new Contact(&quot;liangshanguang&quot;, &quot;https://github.com/19920625lsg/spring-boot-online-exam&quot;, &quot;liangshanguang2@gmail.com&quot;))
                .build();
    }
}





@Api(&quot;测试用例1&quot;) on controller class, 

    @ApiOperation(value = &quot;apiOperationSwaggerTest&quot;, notes = &quot;apiOperationSwagger测试&quot;) on controller class method

@ApiParam(name = &quot;id&quot;, value = &quot;id入参&quot;, required = true) on method params

@ApiModel(description = &quot;测试实体类&quot;, value = &quot;测试实体类&quot;) on data model class

    @ApiModelProperty(name = &quot;userName&quot;, value = &quot;用户名&quot;, required = false, exmaple = &quot;小明&quot;) on data module class field

@ApiImplicitParams({@ApiImplicitParam(name = &quot;id&quot;, value = &quot;id入参&quot;, required = true, dataType = &quot;Integer&quot;, paramType = &quot;query&quot;),
                        @ApiImplicitParam(name = &quot;brand&quot;, value = &quot;brand&quot;, required = true, dataType = &quot;BRAND&quot;, paramType = &quot;body&quot;)
    }) on controller class method
@ApiImplicitParams：用在请求的方法上，表示一组参数说明
    @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面
        name：参数名
        value：参数的汉字说明、解释
        required：参数是否必须传
        paramType：参数放在哪个地方
            · header --&gt; 请求参数的获取：@RequestHeader
            · query --&gt; 请求参数的获取：@RequestParam
            · path（用于restful接口）--&gt; 请求参数的获取：@PathVariable
            · body（不常用）
            · form（不常用）    
        dataType：参数类型，默认String，其它值dataType=&quot;Integer&quot;       
        defaultValue：参数的默认值
</code></pre>
<h2><a class="header" href="#过滤器-和-拦截器" id="过滤器-和-拦截器">过滤器 和 拦截器</a></h2>
<h3><a class="header" href="#区别" id="区别">区别</a></h3>
<p>servlet filter和spring mvc Interceptor区别：</p>
<ul>
<li>
<p>Filter 是基于 函数回调的，而 Interceptor 则是基于 Java 反射 和 动态代理。</p>
</li>
<li>
<p>Filter 依赖于 Servlet 容器, 和servlet容器隔的近，而 Interceptor 依赖springmvc, 和应用隔的近, 在最里层。所以filter 先进入, 最后退出</p>
</li>
<li>
<p>Filter 对几乎 所有的请求 起作用，而 Interceptor 只对 Controller 请求起作用。</p>
</li>
<li>
<p>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</p>
</li>
</ul>
<h3><a class="header" href="#使用-filter" id="使用-filter">使用 filter</a></h3>
<pre><code class="language-java">scenario 1:
直接实现Filter接口，并使用@Component, 拦截所有路径 &quot;/*&quot;, 这种方式可以注入 bean


scenario 2:
实现Filter接口，用@WebFilter注解，指定拦截路径以及一些参数，同时需要在启动类使用@ServletComponentScan扫描带@WebFilter、@WebServlet、@WebListener, 
这种方式无法注入 bean, 除非 和 @component 一起使用, 但是需要配置覆盖 bean
#启用覆盖同名bean
spring.main.allow-bean-definition-overriding=true

scenario 3:
@Configuration
public class MyFilterConfig {
    @Autowired
    MyFilter myFilter;
    @Bean
    public FilterRegistrationBean&lt;MyFilter&gt; thirdFilter() { // 泛型指定 filter 类型, so 多个 filter 每个都要一个 bean 方法
        FilterRegistrationBean&lt;MyFilter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;();
        filterRegistrationBean.setOrder(2)
        filterRegistrationBean.setFilter(myFilter);

        filterRegistrationBean.setUrlPatterns(new ArrayList&lt;&gt;(Arrays.asList(&quot;/api/*&quot;)));

        return filterRegistrationBean;
    }
}


和 这里的 filter 不同, 这里是为了过滤 扫描
@ComponentScan(value=&quot;com.wxj&quot;,excludeFilters= {
        @Filter(type=FilterType.ANNOTATION,classes= {Controller.class})
})
</code></pre>
<h3><a class="header" href="#使用-interceptor" id="使用-interceptor">使用 interceptor</a></h3>
<h4><a class="header" href="#基本使用拦截器" id="基本使用拦截器">基本使用拦截器</a></h4>
<p>https://www.baeldung.com/spring-mvc-handlerinterceptor</p>
<pre><code class="language-java">实现 HandlerInterceptor 接口,
@component
class InterfaceAuthCheckInterceptor implements HandlerInterceptor {

        private Logger logger = LoggerFactory.getLogger(getClass());

        @Autowired
        StringRedisTemplate stringRedisTemplate;

        ...


  // 配置      
@Configuration
public class InterceptorConfig implements WebMvcConfigurer { // WebMvcConfigurerAdapter 过时, WebMvcConfigurationSupport, 对于 classpath:/META/resources/，classpath:/resources/，classpath:/static/，classpath:/public/）不生效, 所以选择WebMvcConfigurer 最好

    @autowire
    .... interceptor

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 多个拦截器组成一个拦截器链, 加入的顺序就是拦截器执行的顺序, 也可使用 @order(-1/0/1...)指定
        // addPathPatterns 用于添加拦截规则, 默认拦截所有 即 /**
        // excludePathPatterns 用户排除拦截
        registry.addInterceptor(interceptor).addPathPatterns(&quot;/api/**&quot;).exclude(&quot;...&quot;);
        
    }

</code></pre>
<h4><a class="header" href="#基于-url-拦截" id="基于-url-拦截">基于 url 拦截</a></h4>
<p>一种方式是 在配置中 registry.addInterceptor(interceptor).addPathPatterns(&quot;/api/**&quot;).exclude(&quot;...&quot;);</p>
<p>一种是直接在 prehandle() 中处理 String path = request.getServletPath(), path.matches(Const.NO_INTERCEPTOR_PATH 就是基于正则匹配的url </p>
<h4><a class="header" href="#基于注解拦截" id="基于注解拦截">基于注解拦截</a></h4>
<p>interceptor 也属于 aop, </p>
<pre><code class="language-java">public class AuthorityInterceptor extends HandlerInterceptorAdapter{
	
	 @Override
	 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
	 	// 如果不是映射到方法直接通过
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        // ①:START 方法注解级拦截器
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        Method method = handlerMethod.getMethod();
        // 判断接口是否需要登录
        LoginRequired methodAnnotation = method.getAnnotation(LoginRequired.class);
        // 有 @LoginRequired 注解，需要认证
        if (methodAnnotation != null) {
            // 这写你拦截需要干的事儿，比如取缓存，SESSION，权限判断等
            System.out.println(&quot;====================================&quot;);
            return true;
        }
        return true;
	}
}

</code></pre>
<h2><a class="header" href="#servlet-druid-监控" id="servlet-druid-监控">servlet Druid 监控</a></h2>
<pre><code class="language-java">@Configuration
public class DruidConfig {

    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    @Bean
    public DataSource druid(){
        return  new DruidDataSource();
    }

    //配置Druid的监控
    //1、配置一个管理后台的Servlet
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);
        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();

        initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);
        initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);
        initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问
        initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;);

        bean.setInitParameters(initParams);
        return bean;
    }


    //2、配置一个web监控的filter
    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();
        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);

        bean.setInitParameters(initParams);

        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));

        return  bean;
    }
}

</code></pre>
<h2><a class="header" href="#aop-整合使用" id="aop-整合使用">aop 整合使用</a></h2>
<h3><a class="header" href="#基本使用" id="基本使用">基本使用</a></h3>
<p>通知执行顺序: around &gt; before &gt; around &gt; after &gt; afterReturning</p>
<pre><code class="language-java">// 只需要spring-boot-starter-aop
//@EnableAspectJAutoProxy// 无需, 自动开启,引入依赖后

@Component //必须
@Aspect
public class ReqCheckAop {

    @Autowired
    private ObjectMapper objectMapper;

    @Pointcut(&quot;execution(org.springframework.http.ResponseEntity&lt;Resp&gt; io.github.xiaoyureed.demo..*.*(..))&quot;)
    private void pointcut() {}

    @Around(&quot;pointcut()&quot;)
    public Object reqCheck(ProceedingJoinPoint jp) throws Throwable {
        Object[] args = jp.getArgs();
        System.out.println(&quot;&gt;&gt;&gt; req = &quot; + objectMapper.writeValueAsString(args[0]));
        return jp.proceed();
    }
}
</code></pre>
<h3><a class="header" href="#切入点表达式" id="切入点表达式">切入点表达式</a></h3>
<p>用来指定增强哪些方法</p>
<p>https://www.cnblogs.com/ityangshuai/p/11923696.html</p>
<pre><code>1.execution(xxx)  用于确定方法
    表达式格式(就是方法签名)：修饰符  返回值  包.类.方法(参数列表) throws 异常
        1.1 修饰符 （可选），一般不使用 ----------- 接空格
            public        公共修饰符
            *            任意修饰符
        1.2 返回值， 复杂类型需要全限定名称，常用 ----------- 接空格
            String        返回字符串
            *            返回任意
        1.3 包    ，常用
            com.xiaoyu.spring.learn.service            指定service包
            com.xiaoyu.spring.learn.crm.*.service                crm项目下的任意子模块（子文件夹）的service包
            com.xiaoyu.spring.learn.service..            service目录包含的所有目录（包括次级子目录等等）
            com.xiaoyu.spring.learn.crm.*.service..                crm下所有的子模块中service目录包含的所有目录
        1.4 类，常用
            UserService                指定类名
            User*                    以User开头类
            *Service                    以Service结尾类（常用）
            *                        任意类
        1.5 方法，常用 与 1.4类相似
            addUser                    指定方法
            add*                        add开头方法
            *User                    以User结尾方法
            *                        任意方法
        1.6 参数列表，常用
            ()                        没有参数
            (int)                        一个参数
            (int,int)                    两个参数
            (..)                        参数任意
        1.7 异常 ，具体异常（可选）

    多表达式：
        &lt;aop:pointcut experssion=&quot;exection(表达式1)  || exection(表达式2) &quot;&gt;    ：表达式1或 表达式2
    综合案例：execution(* com.xiaoyu.spring.learn.crm.*.service..*.*(..))
        含义：    返回值任意，crm项目下的任意子目录中的的service目录下的所有目录中的任意类的任意方法，参数任意。

- within(): 只能指定 包.类; 再下面的粒度就没办法了, 所以相当于 execution() 的简化版
    within(com.xiaoyu.spring.learn.aop..*)匹配aop 包/子包下的所有类的所有方法

    指定注解类亦可
    within(@org.springframework.web.bind.annotation.RestController *) 匹配 被 指定注解标注的所有类的所有方法
    
- this(): 用于向通知方法中传入代理对象的引用
    如:
    @Before(&quot;before() &amp;&amp; this(proxy)&quot;)
    public void beforeAdvide(JoinPoint point, Object proxy){

- target(): 用于向通知方法中传入目标对象的引用

- args() ：用于将参数传入到通知方法中
    如:
    @Before(&quot;before() &amp;&amp; args(age,username)&quot;)
    public void beforeAdvide(JoinPoint point, int age, String username){
    如 
    @Pointcut(&quot;execution(public * com.example.demo.aop.AopController.xxxMethod(int)) &amp;&amp; args(point))&quot;) 会将拦截到的方法的 int 类型参数 传递到 aop 方法中, 使用 point 接受即可


-------


- @within ：用于匹配在类一级使用了注解的类，其所有方法都将被匹配
    @Pointcut(&quot;@within(com.cjm.annotation.AdviceAnnotation)&quot;) － 所有被@AdviceAnnotation标注的类都将匹配
    常用:
    @Pointcut(&quot;@annotation(AopLog) || @within(AopLog)&quot;) - 被 aopLog 标注的类 or 方法被拦截

- @target ：和@within的功能类似，但必须要指定注解的保留策略为RUNTIME。

    存疑?@target() 指定目标类型, 所有这个类型的类都会被匹配
    @target(com.xiaoyu.spring.learn.aop.user.IUserDAO)匹配 IUserDAO 的所有实现类, 类中的方法都会被代理, 包括未在接口中声明的方法

- @args() 指定一个注解, 表示要拦截方法的参数需要带有这个注解


- @bean(id值) 对指定的目标对象的类进行匹配

- @annotation(参数中注解参数名称) 匹配被指定注解标注的方法

    如: 下面表示 -&gt; 匹配 web 包/子包下所有类的所有方法 且方法被 @CheckReqNo 标注 
    
    @Around(&quot;within(io.github.xiaoyureed.web..*) &amp;&amp; @annotation(checkReqNo)&quot;)
    public void xxx(JoinPoint jp, CheckReqNo checkReqNo)

-  可以使用 &amp;&amp;, ||, ! 运算符来定义切点表达式
</code></pre>
<h2><a class="header" href="#controlleradvice-异常处理" id="controlleradvice-异常处理">@controllerAdvice 异常处理</a></h2>
<p>全局异常处理 全局数据绑定 全局请求数据预处理</p>
<pre><code class="language-java">@ControllerAdvice //@ControllerAdvice注解 可以通过 assignableTypes 指定特定的类，让异常处理类只处理特定类抛出的异常
public class MyGlobalExceptionHandler {
    // 直接返回 web 页面
    @ExceptionHandler(Exception.class)
    public ModelAndView customException(Exception e) {
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;message&quot;, e.getMessage());
        mv.setViewName(&quot;myerror&quot;);
        return mv;
    }

    // 返回 json
    @exception..
    @respbody // 如果类上使用的是@RestControllerAdvice, 那么 返回 json 无需 @ResponseBody, 只需要 @ExceptionHandler
    public respseentiyt xxx(Exception ex) {}


    // 绑定 md 到每个 controler 中的方法参数中
    @ModelAttribute(name = &quot;md&quot;)
    public Map&lt;String,Object&gt; mydata() {
        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;age&quot;, 99);
        map.put(&quot;gender&quot;, &quot;男&quot;);
        return map;
    }
    // controller 中这么使用
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model) {// 或者 @ModelAttribute(&quot;md&quot;) Map&lt;String, Object&gt; md
        Map&lt;String, Object&gt; map = model.asMap();
        System.out.println(map);
        int i = 1 / 0;
        return &quot;hello controller advice&quot;;
    }


    // 请求数据预处理
    // 如此, 请求参数就可以传递这样的参数: a.name=xxx, b.name=yyy
    // controller 中这样获取 @ModelAttribute(&quot;b&quot;) Book book, @ModelAttribute(&quot;a&quot;) Author author
    @InitBinder(&quot;b&quot;)
    public void b(WebDataBinder binder) {
        binder.setFieldDefaultPrefix(&quot;b.&quot;);
    }
    @InitBinder(&quot;a&quot;)
    public void a(WebDataBinder binder) {
        binder.setFieldDefaultPrefix(&quot;a.&quot;);
    }
}

</code></pre>
<p>处理异常的其他方法:</p>
<pre><code class="language-java">@ExceptionHandler(value = Exception.class)// 拦截所有异常
    public ResponseEntity&lt;ErrorResponse&gt; exceptionHandler(Exception e) {

        if (e instanceof IllegalArgumentException) {
            return ResponseEntity.status(400).body(illegalArgumentResponse);
        } else if (e instanceof ResourceNotFoundException) {
            return ResponseEntity.status(404).body(resourseNotFoundResponse);
        }
        return null;
    }



@GetMapping(&quot;/resourceNotFoundException2&quot;)
    public void throwException3() {
        throw new ResponseStatusException(HttpStatus.NOT_FOUND, &quot;Sorry, the resourse not found!&quot;, new ResourceNotFoundException());
    }

</code></pre>
<h2><a class="header" href="#httpservletrequest-的输入流只能读取一次的问题" id="httpservletrequest-的输入流只能读取一次的问题">HttpServletRequest 的输入流只能读取一次的问题</a></h2>
<p>https://www.cnblogs.com/JAYIT/p/10943155.html</p>
<p>还是推荐使用 aop 去切 controller 更方便一点</p>
<h2><a class="header" href="#路由处理" id="路由处理">路由处理</a></h2>
<h3><a class="header" href="#静态资源映射-暴露静态资源" id="静态资源映射-暴露静态资源">静态资源映射 暴露静态资源</a></h3>
<p>暴露图片资源</p>
<pre><code class="language-java">@Configuration
public class ImageConfig implements WebMvcConfigure {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler(&quot;/images/**&quot;) //addResourceLocations指的是文件放置的目录，addResoureHandler指的是对外暴露的访问路径
                .addResourceLocations(&quot;file:./localdata/images/&quot;);
    }
}

</code></pre>
<p>分环境暴露配置文件</p>
<pre><code class="language-java">
// 配置文件访问地址 (注意每个访问路径后面的路径加 / !!!)
// ## windows系统下访问路径
// uploadWindow: E:\common\file\root\
// ## windows系统下访问路径
// uploadLinux: /user/img/
@Override
protected void addResourceHandlers(ResourceHandlerRegistry registry) {
    String os = System.getProperty(&quot;os.name&quot;);

    //如果是Windows系统
    if (os.toLowerCase().startsWith(&quot;win&quot;)) {
        registry.addResourceHandler(&quot;/app_file/**&quot;)
                // /app_file/**表示在磁盘filePathWindow目录下的所有资源会被解析为以下的路径
                .addResourceLocations(&quot;file:&quot; + filePathWindow);
    } else {  //linux 和mac
        registry.addResourceHandler(&quot;/app_file/**&quot;)
                .addResourceLocations(&quot;file:&quot; + filePathLinux) ;
    }

    super.addResourceHandlers(registry);
}
</code></pre>
<p>还有个例子, --&gt; swagger 静态资源处理 (放行 相关的静态页面)</p>
<h3><a class="header" href="#添加-view-controller" id="添加-view-controller">添加 view controller</a></h3>
<pre><code class="language-java">@Configuration
class MvcConfig implements WebMvcConfigurer {
    /**
     * 添加 view controller
     * &lt;p&gt;
     * 将 url path 和 template 对应, 无需添加任何的 controller 代码
     */
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController(&quot;/home&quot;).setViewName(&quot;home&quot;);// 等价 访问 /home , controller 返回 &quot;home&quot;
        registry.addViewController(&quot;/&quot;).setViewName(&quot;home&quot;);
        registry.addViewController(&quot;/hello&quot;).setViewName(&quot;hello&quot;);
        registry.addViewController(&quot;/login&quot;).setViewName(&quot;login&quot;);
        registry.addViewController(&quot;/admin-page&quot;).setViewName(&quot;admin-page&quot;);
    }
}
</code></pre>
<h2><a class="header" href="#spring-boot-starter-thymeleaf" id="spring-boot-starter-thymeleaf">spring-boot-starter-thymeleaf</a></h2>
<p>thymeleaf 和 spring security 配合使用 <code>sec</code> 标签: https://www.jianshu.com/p/bb3a3b388c4e</p>
<p>springboot默认  static/public 中放静态页面，而templates中放动态页面即 thymeleaf 模板</p>
<p>静态页面: 直接在static放一个hello.html,然后直接输入http://localhost:8080/hello.html 便能成功访问 (关闭这个特性需要 spring.resources.add-mappings: false), 也可以通过controller跳转 <code>return &quot;hello.html&quot;;</code></p>
<p>动态页面: 需要 <code>spring-boot-starter-thymeleaf</code>, 静态页面的return默认是跳转到/static/index.html，当在pom.xml中引入了thymeleaf组件，动态跳转会覆盖默认的静态跳转，默认就会跳转到/templates/index.html，注意看两者return代码也有区别，动态没有html后缀, 如果在使用动态页面时还想跳转到/static/index.html，可以使用重定向return &quot;redirect:/index.html&quot;</p>
<pre><code class="language-java">@RequestMapping(&quot;/Hi&quot;)
    public String sayHello() {
        return &quot;hello&quot;;
    }

@RequestMapping(&quot;/Hi&quot;)
public ModelAndView sayHello() {
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName(&quot;hello&quot;);
    modelAndView.addObject(&quot;key&quot;, 12345);
    //System.out.println(&quot;test&quot;);
    return modelAndView;
}

@RequestMapping(&quot;/Hi&quot;)
public String sayHello(Map&lt;String,obj&gt; map) {
    map.put(&quot;stu&quot;, new Stu())
    return &quot;hello&quot;;
}
</code></pre>
<p>配置:</p>
<pre><code class="language-yml">
#spring配置
spring:
  mvc:
    servlet:
      load-on-startup: 1
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/springbootssm?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8
    username: root
    password: 123456
  thymeleaf:
    cache: false #关闭缓存
    mode: HTML5 #设置模板类型
    encoding: utf-8  #设置编码
    prefix: classpath:/templates/
    suffix: .html
    content-type=text/html 
</code></pre>
<h1><a class="header" href="#运维部署" id="运维部署">运维部署</a></h1>
<h2><a class="header" href="#支持-https-ssl" id="支持-https-ssl">支持 https ssl</a></h2>
<h3><a class="header" href="#nginx-配置-https" id="nginx-配置-https">nginx 配置 https</a></h3>
<p>Let's Encrypt 或者阿里云, 腾讯云 支持 面粉 ssl 证书 , 一年有效期, 过期再次申请 </p>
<p>https://segmentfault.com/a/1190000016760251 使用 lets encrypt 配置 nginx</p>
<p>https://www.cnblogs.com/to-red/p/12450616.html
https://www.cnblogs.com/chnmig/p/10343890.html
https://blog.csdn.net/fenglin0429/article/details/81347634
https://www.nonelonely.com/article/1584965619600 nginx 配置 http  转https, 代理 springboot
https://ask.csdn.net/questions/701009</p>
<h3><a class="header" href="#支持-https-访问" id="支持-https-访问">支持 https 访问</a></h3>
<pre><code class="language-java">// 假设如下的 api, 希望支持 https 访问, 现在仅仅只是http访问。http://localhost:8080
@RestController
@SpringBootApplication
public class TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }
    @RequestMapping(value = &quot;/&quot;,produces = &quot;text/plain;charset=UTF-8&quot;)
    String index(){
        return &quot;Hello Spring Boot!&quot;;
    }
}


//生成ssl证书, 系统的当前用户目录下会生成一个keystore.p12文件, 将keystore.p12文件拷贝到我们项目的根路径下
// 1.-storetype 指定密钥仓库类型
// 2.-keyalg 生证书的算法名称，RSA是一种非对称加密算法
// 3.-keysize 证书大小
// 4.-keystore 生成的证书文件的存储路径
// 5.-validity 证书的有效期
keytool -genkey -alias tomcat  -storetype PKCS12 -keyalg RSA -keysize 2048  -keystore keystore.p12 -validity 3650

// 修改配置文件
server.ssl.key-store=keystore.p12 //路径
server.ssl.key-store-password=123456 //生成ssl证书时设置的密钥库的口令
server.ssl.keyStoreType=PKCS12
server.ssl.keyAlias = tomcat

//此时工程已经支持https访问。 https://localhost:8080/

</code></pre>
<h3><a class="header" href="#http-请求自动转为-https" id="http-请求自动转为-https">http 请求自动转为 https</a></h3>
<pre><code class="language-java">// 配置访问http  urL 时自动转到https。
// 配置后, 访问 https://localhost:8081/ 正常, 访问 http://localhost:8080/，我们可以看到页面的url变成了https://localhost:8081/
class Config {
    @Bean
    public EmbeddedServletContainerFactory servletContainer() {
        TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory() {
            @Override
            protected void postProcessContext(Context context) {
                SecurityConstraint constraint = new SecurityConstraint();
                constraint.setUserConstraint(&quot;CONFIDENTIAL&quot;);
                SecurityCollection collection = new SecurityCollection();
                collection.addPattern(&quot;/*&quot;);
                constraint.addCollection(collection);
                context.addConstraint(constraint);
            }
        };
        tomcat.addAdditionalTomcatConnectors(httpConnector());
        return tomcat;
    }

    @Bean
    public Connector httpConnector() {
        Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);
        connector.setScheme(&quot;http&quot;);
        //Connector监听的http的端口号
        connector.setPort(8080);
        connector.setSecure(false);
        //监听到http的端口号后转向到的https的端口号
        connector.setRedirectPort(8081); // 需要设置 server.port=8081

        return connector;
    }
}



</code></pre>
<h3><a class="header" href="#同时支持-http-https" id="同时支持-http-https">同时支持 http https</a></h3>
<p>用http请求时不再转换成https请求</p>
<p>只需要将代码中的connector.setSecure(false)中的false改成true就可以了</p>
<h2><a class="header" href="#容器化部署" id="容器化部署">容器化部署</a></h2>
<p>https://rovo98.github.io/posts/39885a36/ SpringBoot + Docker + Nginx 负载均衡实现
TODO</p>
<p>https://github.com/GoogleContainerTools/jib 为 java 程序构造 docker 镜像 (https://www.cnblogs.com/felordcn/p/13201163.html)</p>
<h2><a class="header" href="#nginx-反向代理" id="nginx-反向代理">nginx 反向代理</a></h2>
<p>https://cloud.tencent.com/developer/article/1332603</p>
<h2><a class="header" href="#内嵌-tomcat-调优" id="内嵌-tomcat-调优">内嵌 tomcat 调优</a></h2>
<pre><code class="language-yml">server:
  compression:
    #SpringBoot 默认是不开启 gzip 压缩的，需要我们手动开启
    enabled: true
    #optional, 在 spring2.0+的版本中，默认值已经有了
    mime-types: application/json,application/xml,text/html,text/plain,text/css,application/x-javascript
    #默认情况下，仅会压缩 2048 字节以上的内容, 指定超过多少就压缩
    min-response-size: 1024

  tomcat:
    # 排队数, 等待队列长度：队列做缓冲池用，但也不能无限长，消耗内存，出入队列也耗cpu
    accept-count: 1000   
    max-connections: 10000 #最大可被连接数，默认为10000 
    #最大工作线程数, 默认 200
    # 4核8G内存单进程调度线程数800-1000，超过这个并发数之后，将会花费巨大的时间在cpu调度上。
    max-threads: 800  
    min-spare-threads: 100 #最小工作线程数, 默认 10
    # 连接超时 30s
    connection-timeout: 30000
    # Maximum size, in bytes, of the HTTP message header
    max-http-header-size:
    # Maximum size, in bytes, of the HTTP post content.
    max-http-post-size:
</code></pre>
<p>通过 java code 配置:</p>
<p>修改keepalivetimeout和maxKeepAliveRequests开启长连接</p>
<pre><code class="language-java">//当Spring容器内没有TomcatEmbeddedServletContainerFactory这个bean时，会吧此bean加载进spring容器中
@Component
public class  WebServerConfiguration implements WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; {
    @Override
    public void customize(ConfigurableWebServerFactory configurableWebServerFactory) {
            //使用对应工厂类提供给我们的接口定制化我们的tomcat connector
        ((TomcatServletWebServerFactory)configurableWebServerFactory).addConnectorCustomizers(new TomcatConnectorCustomizer() {
            @Override
            public void customize(Connector connector) {
                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();

                //定制化keepalivetimeout,设置30秒内没有请求则服务端自动断开keepalive链接
                protocol.setKeepAliveTimeout(30000);
                //当客户端发送超过10000个请求则自动断开keepalive链接
                protocol.setMaxKeepAliveRequests(10000);

                // 设置其他....
            }
        });
    }
}

// 或者这样配置, 效果等同   
public class WebServerConfiguration {
    @Bean
    public ConfigurableServletWebServerFactory webServerFactory() {
        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
        factory.setPort(11359);//端口号
        factory.setUriEncoding(Charset.forName(&quot;utf-8&quot;));//编码
        factory.addConnectorCustomizers(new MyTomcatConnectorCustomizer());
        return factory;
    }
    
    class MyTomcatConnectorCustomizer implements TomcatConnectorCustomizer {
        @Override
        public void customize(Connector connector) {
            // TODO Auto-generated method stub
            Http11NioProtocol handler = (Http11NioProtocol)connector.getProtocolHandler();
            
            handler.setAcceptCount(2000);//排队数
                        
            handler.setMaxConnections(5000);//最大连接数
            
            handler.setMaxThreads(2000);//线程池的最大线程数
            
            handler.setMinSpareThreads(100);//最小线程数
                        
            handler.setConnectionTimeout(30000);//超时时间                    
        }
    }
}
</code></pre>
<h2><a class="header" href="#配置-war-包部署到-tomcat" id="配置-war-包部署到-tomcat">配置 war 包部署到 Tomcat</a></h2>
<pre><code class="language-java">public class ServletInitializer extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(Application.class);
    }

}

@Configuration
@ComponentScan(basePackageClasses = Application.class, useDefaultFilters = true)
public class ServletContextConfig extends WebMvcConfigurationSupport{
    /**
     * 配置servlet处理
     */
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}

</code></pre>
<p>或者直接一步到位:</p>
<pre><code class="language-java">@SpringbootApplication
public class Application extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(Application.class);
    }

    ...
}
</code></pre>
<h1><a class="header" href="#spring-boot-中的并发" id="spring-boot-中的并发">spring boot 中的并发</a></h1>
<p>https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/ //todo
https://blog.csdn.net/qq_40606397/article/details/104945855</p>
<h1><a class="header" href="#实现乐观锁悲观锁" id="实现乐观锁悲观锁">实现乐观锁悲观锁</a></h1>
<p>https://www.cnblogs.com/cloudfloating/p/11461530.html </p>
<p>TODO</p>
<h1><a class="header" href="#移动端消息推送" id="移动端消息推送">移动端消息推送</a></h1>
<p>https://juejin.im/post/6844903838495801357 
https://crossoverjie.top/2018/09/25/netty/million-sms-push/
https://juejin.im/post/6844903478200909837
TODO</p>
<h1><a class="header" href="#即时通信-im系统" id="即时通信-im系统">即时通信 IM系统</a></h1>
<p>https://github.com/tywo45</p>
<h1><a class="header" href="#辅助工具" id="辅助工具">辅助工具</a></h1>
<h2><a class="header" href="#lombok-notice" id="lombok-notice">lombok notice</a></h2>
<ul>
<li>
<p>@data &lt;=&gt; @Setter、@Getter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode, </p>
<p>其中 @RequiredArgsConstructor 没什么用, 不会生成构造方法, 默认无参构造方法仍然有效</p>
<p>若存在继承, 需要为 son 指定 @EqualsAndHashCode(callSuper = true)</p>
<p>@RequiredArgsConstructor(staticName=&quot;of&quot;) 单独使用, 表示为必须field 生成 constructor, 也就是为 final 的成员或者@notnull成员生成 constructor, 其他field 不会作为参数, staticname=of 表示这个类不能用构造方法构造出来，必须通过 ThisClass.of(...)方法才能构造出来</p>
</li>
<li>
<p>通用的组合是 @data, @all... , @no...</p>
</li>
<li>
<p>和 Java8 配合良好, jdk升级很麻烦, 需要 delombok</p>
</li>
<li>
<p>@builder 构造对象时底层用的是全参数构造器, 需要 @AllArgsConstructor一起用, 无法单独使用, 若果一定要用, 好的组合是 @NoArgsConstructor @AllArgsConstructor @Builder @Data</p>
</li>
<li>
<p>代替@AutoWired注解: @RequiredArgsConstructor(onConstructor =@__(@Autowired))标注在类上</p>
</li>
<li>
<p>替代@tostring注解 可以使用 lang3 的 <code>ToStringBuilder.reflectionToString(this)</code></p>
</li>
</ul>
<h2><a class="header" href="#devtools" id="devtools">devtools</a></h2>
<p>开发者组件, 修改了 thymeleaf 后, 重新编译修改的文件, 页面即可更新, 不必重启整个 app, 但是若修改了 Java config , 还是要重启</p>
<pre><code class="language-props">spring.thymeleaf.cache=true
spring.devtools.restart.enabled=true
... additional-paths=src/main/java // 监听目录  
</code></pre>
<h2><a class="header" href="#maven-wrapper" id="maven-wrapper">maven wrapper</a></h2>
<p>wrapper：maven的包装器，通过mvnw命令替代mvn，简化mvn操作, 不需要在操作系统上安装Maven</p>
<p>受到 gradle wrappe 启发</p>
<p>/.mvn/wrapper/maven-wrapper.jar 是其主体程序</p>
<p>/.mvn/wrapper/maven-wrapper.properties 可指定 maven 版本及下载路径</p>
<p>mvnw, mvnw.cmd 命令行程序</p>
<p>mvnw第一次运行会检测$USER_HOME/.m2/wrapper/dists 目录下是否有maven-wrapper.properties中指定的Maven版本，如果没有就自动下载</p>
<h1><a class="header" href="#校验" id="校验">校验</a></h1>
<h2><a class="header" href="#校验配置文件" id="校验配置文件">校验配置文件</a></h2>
<p>任何添加@ConfigurationProperties的类，class上加 <code>@Validated</code> annotation, app都会进行属性校验, 确保引入了 JSR-303 javax.validation 规范的实现;
使用校验规范JSR-303 javax.validation中的注解即可实现校验（介绍见这里https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/）</p>
<pre><code class="language-java">@ConfigurationProperties(prefix=&quot;connection&quot;)
@Validated
public class FooProperties {

    @NotNull
    private InetAddress remoteAddress;

    @Valid // 这里是为了激活 Security类中的注解校验
    private final Security security = new Security();

    // ... getters and setters

    public static class Security {

        @NotEmpty
        public String username;

        // ... getters and setters

    }

}
</code></pre>
<p>@Validated 也可以可以加到 @Bean 方法上 来触发校验;</p>
<p>也可以使用自定的Spring Validator，bean id是 configurationPropertiesValidator 即可</p>
<p>spring-boot-actuator 模块有一个端点，对外暴露了所有的 @ConfigurationProperties beans。浏览器中访问 /configprops 即可</p>
<h2><a class="header" href="#校验请求参数" id="校验请求参数">校验请求参数</a></h2>
<p>https://blog.csdn.net/mzh_cn/article/details/80637015</p>
<h2><a class="header" href="#自定义校验" id="自定义校验">自定义校验</a></h2>
<h2><a class="header" href="#validated和valid" id="validated和valid">@Validated和@Valid</a></h2>
<p>@Valid是 JSR-303 规范, hibernate-validation实现了这一规范</p>
<p>@Validated来自于spring, 是 spring 对于 @Valid 的实现, 提供&quot;validation groups&quot;功能(创建空接口作为分组), valid则不具备;(https://stackoverflow.com/questions/36173332/difference-between-valid-and-validated-in-spring) , 一旦controler 中使用 @Validated(group={...}), 那么实体类字段上的注解若指定 group 则约束生效, 不指定分组的不生效. 反之, 若 @validated 没有指定分组, 则 实体类字段指定了 group 的不生效, 不指定group 的字段生效</p>
<h1><a class="header" href="#runner-获取命令行参数" id="runner-获取命令行参数">runner 获取命令行参数</a></h1>
<h2><a class="header" href="#获取命令行参数" id="获取命令行参数">获取命令行参数</a></h2>
<p>注入一个<code>org.springframework.boot.ApplicationArguments </code>bean</p>
<pre><code class="language-java">@Component
public class MyBean {

    @Autowired
    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption(&quot;debug&quot;);//option参数即“--”开头的参数
        List&lt;String&gt; files = args.getNonOptionArgs();// if run with &quot;--debug logfile.txt&quot; 那么结果是 debug=true, files=[&quot;logfile.txt&quot;]
    }

}
</code></pre>
<p>另外的注入方法:</p>
<p>Spring Boot will also register a <code>CommandLinePropertySource</code> with the Spring <code>Environment</code>. This allows you to also inject single application arguments using the <code>@Value</code> annotation.</p>
<h2><a class="header" href="#applicationrunner-or-commandlinerunner" id="applicationrunner-or-commandlinerunner"><code>ApplicationRunner</code> or <code>CommandLineRunner</code></a></h2>
<p><code>ApplicationRunner</code> or <code>CommandLineRunner</code>接口都有run()待实现(在SpringApplication.run(…​)完成之前调用)但是参数不同, 具体如下:</p>
<ul>
<li>
<p>ApplicationRunner接口, <code>void run(ApplicationArguments args)</code></p>
</li>
<li>
<p>CommandLineRunner接口, <code>void run(String... args)</code></p>
</li>
</ul>
<pre><code class="language-java">@Component
public class MyBean implements CommandLineRunner {

    @Override
    public void run(String... args) {//可以获取命令行参数, 作为String[]
        // 这里的内容会在app完全启动前最后一步执行, 即SpringApplication.run(…​)完成之前, 也会在ApplicationReadyEvent之前
    }

}


// 另一种方法:
//java -jar commandline-app-0.0.1-SNAPSHOT.jar iamnonoption --app.name=CmdRulez --app.hosts=abc,def,ghi --app.name=2
implements ApplicationRunner
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 获取非 --xxx=yyy 的参数集合
        System.out.println(&quot;# NonOptionArgs: &quot; + args.getNonOptionArgs().size());
        System.out.println(&quot;NonOptionArgs:&quot;);
        args.getNonOptionArgs().forEach(System.out::println);

        // 获取 --xxx=yy 的参数中的 key
        System.out.println(&quot;# OptionArgs: &quot; + args.getOptionNames().size());
        System.out.println(&quot;OptionArgs:&quot;);

        args.getOptionNames().forEach(optionName -&gt; {
            System.out.println(optionName + &quot;=&quot; + args.getOptionValues(optionName));// 获取 value
        });
    }
</code></pre>
<p>如果有多个CommandLineRunner or ApplicationRunner beans 被定义, 这时候涉及到调用数序问题, 两种方式:</p>
<ul>
<li>
<p>实现<code>org.springframework.core.Ordered</code>接口</p>
</li>
<li>
<p>使用<code>org.springframework.core.annotation.Order</code>注解 eg: @Order(num), num为Int, 0优先级最高</p>
</li>
</ul>
<h1><a class="header" href="#开发命令行应用" id="开发命令行应用">开发命令行应用</a></h1>
<p>加入开发一个工具 ab.jar, 希望这么使用:</p>
<ul>
<li>java -jar ab.jar 使用提示</li>
<li>java -jar ab.jar  --spring.profiles.active=hello-world,receiver 激活不同的 profile</li>
</ul>
<p>配置中指定一个默认 激活 profile</p>
<pre><code>spring:
  profiles:
    active: usage_message
</code></pre>
<pre><code class="language-java">// 工具使用提示
@Profile(&quot;usage_message&quot;)
@Bean
public CommandLineRunner usage() {
    return args -&gt; {
        System.out.println(&quot;This app uses Spring Profiles to
            control its behavior.\n&quot;);
        System.out.println(&quot;Sample usage: java -jar
            rabbit-tutorials.jar
            --spring.profiles.active=hello-world,sender&quot;);
    };
}

// 若出传递了参数, 则 usage_message 就被覆盖, 这个 bean 被注册
@Profile(&quot;!usage_message&quot;)
@Bean
public CommandLineRunner tutorial() {
    return new RabbitAmqpTutorialsRunner();
}

// 传递不同的参数, 不同的 profile 会激活
@Profile(&quot;receiver&quot;)
@Bean
public Tut1Receiver receiver() {
    return new Tut1Receiver();
}

@Profile(&quot;sender&quot;)
@Bean
public Tut1Sender sender() {
    return new Tut1Sender();
}


// 具体操作
public class RabbitAmqpTutorialsRunner implements CommandLineRunner {

    @Value(&quot;${tutorial.client.duration:0}&quot;)
    private int duration;

    @Autowired
    private ConfigurableApplicationContext ctx;

    @Override
    public void run(String... arg0) throws Exception {
        System.out.println(&quot;Ready ... running for &quot; + duration + &quot;ms&quot;);
        Thread.sleep(duration);
        ctx.close();
    }
}


</code></pre>
<h1><a class="header" href="#整合-grpc" id="整合-grpc">整合 grpc</a></h1>
<p>https://github.com/ChinaSilence/spring-boot-starter-grpc</p>
<h1><a class="header" href="#任务调度" id="任务调度">任务调度</a></h1>
<h2><a class="header" href="#整合-xxl-job-任务调度平台" id="整合-xxl-job-任务调度平台">整合 XXL-JOB 任务调度平台</a></h2>
<p>https://www.tianheyu.top/archives/springboot-xxl-job-executor</p>
<h2><a class="header" href="#异步任务" id="异步任务">异步任务</a></h2>
<pre><code class="language-java">@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
        //核心线程数
        taskExecutor.setCorePoolSize(8);
        //最大线程数
        taskExecutor.setMaxPoolSize(16);
        //队列大小
        taskExecutor.setQueueCapacity(100);
        // 当最大池已满时,此策略为我们提供可伸缩队列，此策略保证不会丢失任务请求，但是可能会影响应用程序整体性能。
    executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
    executor.setThreadNamePrefix(&quot;My ThreadPoolTaskExecutor-&quot;);
        taskExecutor.initialize();
        return taskExecutor;
    }
}




// 使用
@Service
public class FutureService {

    //在需要执行的方法上加@Async表明该方法是个异步方法，如果加在类级别上，则表明类所有的方法都是异步方法
    @Async
    public Future&lt;String&gt; futureTest() throws InterruptedException {
        System.out.println(&quot;任务执行开始,需要：1000ms&quot;);
        for (int i = 0; i &lt; 10; i++) {
            Thread.sleep(100);
            System.out.println(&quot;do:&quot; + i);
        }
        System.out.println(&quot;完成任务&quot;);
        return new AsyncResult&lt;&gt;(Thread.currentThread().getName());
    }


    @Async
    public CompletableFuture&lt;List&lt;String&gt;&gt; completableFutureTask(String start) {
        // 打印日志
        logger.warn(Thread.currentThread().getName() + &quot;start this task!&quot;);
        // 找到特定字符/字符串开头的电影
        List&lt;String&gt; results =
            movies.stream().filter(movie -&gt; movie.startsWith(start)).collect(Collectors.toList());
        // 模拟这是一个耗时的任务
        try {
        Thread.sleep(1000L);
        } catch (InterruptedException e) {
        e.printStackTrace();
        }
        //返回一个已经用给定值完成的新的CompletableFuture。
        return CompletableFuture.completedFuture(results);
    }
}
</code></pre>
<h2><a class="header" href="#定时任务" id="定时任务">定时任务</a></h2>
<h3><a class="header" href="#springboot-内置" id="springboot-内置">springboot 内置</a></h3>
<p>SpringBoot为我们内置了@Scheduled定时任务 (spring task), @EnableScheduling 开启</p>
<p>@Scheduled注解各参数详解: (https://www.jianshu.com/p/1defb0f22ed1)</p>
<ul>
<li>cron</li>
<li>zone</li>
<li>fixedDelay 上次完毕到下次开始(ms)</li>
<li>fixedDelayString=&quot;${time.fixedDelay}&quot; 同上</li>
<li>fixedRate 上次开始到下次开始</li>
<li>initialDelay 首次延迟</li>
</ul>
<p>自定义线程池:</p>
<pre><code class="language-java">
//默认情况下，@Scheduled任务都在Spring创建的大小为1的默认线程池中执行

@Configuration
public class SchedulerConfig implements SchedulingConfigurer {
    private final int POOL_SIZE = 10;

    @Override
    public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {
        ThreadPoolTaskScheduler threadPoolTaskScheduler = new ThreadPoolTaskScheduler();

        threadPoolTaskScheduler.setPoolSize(POOL_SIZE);
        threadPoolTaskScheduler.setThreadNamePrefix(&quot;my-scheduled-task-pool-&quot;);
        threadPoolTaskScheduler.initialize();

        scheduledTaskRegistrar.setTaskScheduler(threadPoolTaskScheduler);
    }
}


</code></pre>
<h3><a class="header" href="#集成-quartz" id="集成-quartz">集成 Quartz</a></h3>
<h1><a class="header" href="#配置文件-and-环境" id="配置文件-and-环境">配置文件 and 环境</a></h1>
<h2><a class="header" href="#读取配置文件" id="读取配置文件">读取配置文件</a></h2>
<h3><a class="header" href="#几种读取配置文件的方法" id="几种读取配置文件的方法">几种读取配置文件的方法</a></h3>
<ol>
<li>
<p>使用 @Value(&quot;${property}&quot;) 读取比较简单的配置信息</p>
</li>
<li>
<p>通过@ConfigurationProperties(prefix = &quot;library&quot;)读取并与 bean 绑定, 需要 加 @component(此时无需在配置类上添加 @EnableConfigurationProperties), 若不用 @component, 则必须 在任意一个配置类上添加 @EnableConfigurationProperties(...)</p>
</li>
<li>
<p>@ConfigurationProperties 配合 @bean 用在方法上, 方法调用空构造函数返回想要构造的对象</p>
</li>
<li>
<p>@PropertySource(&quot;classpath:website.properties&quot;) 读取指定 properties 文件</p>
</li>
</ol>
<h3><a class="header" href="#注入复杂类型" id="注入复杂类型">注入复杂类型</a></h3>
<p>对于 properties 格式的配置文件:</p>
<pre><code class="language-java"># application.properties
#
#单个值
val=10

# List
list=1,2,3,4

#Map
map={'name':'chen', 'age':'12', 'sex':'男'}



#java
# 用到了spel表达式
@PropertySource(&quot;classpath:xxx&quot;)
public class ConfigProps {
    //单个数值，可注入为int或String
    @Value(&quot;${val}&quot;)
    private int val;

    //array 数组
    @Value(&quot;#{'${ips}'.split(',')}&quot;)
    private List&lt;String&gt; iplist;


    //map
    @Value(&quot;#{${map}}&quot;)
    private Map&lt;String, String&gt; map;
}


</code></pre>
<p>对于 yml 格式的文件:</p>
<pre><code class="language-java">custom:
  ignored-token-path: /base/xx/login, /xx/**/, /xx/hfc/test

然和配置接受类

@Configuration // 也可以用 @component, 若果不想用这类注解, 可以去掉, 取而代之在启动类上标注 @enableConfigProperties(xxx.class), 相当于加了 @Component
@ConfigurationProperties(&quot;custom&quot;)
public class Custom {

    private String[] ignoredTokenPath;

}





custom:
  mail[0]:
    username: xxx@xxx.com
    password: axxx
  mail[1]:
    username: xxx@xxx.com
    password: axxx

@component
@ConfigurationProperties(&quot;custom&quot;)
public class Custom {

    private List&lt;MailInfo&gt; mail;

    static class MailInfo {

        private String username;
        private String password;

    }

}





directory:
  maps:
    11: /dciZhongShan/resourceWarn/agricultureLand

@Component
@Data
@ConfigurationProperties(prefix = &quot;directory&quot;)
public class MapConfig {
    private Map&lt;Integer, String&gt; maps;
}
</code></pre>
<h2><a class="header" href="#配置文件优先级" id="配置文件优先级">配置文件优先级</a></h2>
<p>配置文件加载优先级: 命令行 &gt; ${user.dir}/config/xxx &gt; ${user.dir}/xxx (usr.dir 即为命令执行的当前目录) &gt; classpath:config/xxx &gt; classpath:xxx</p>
<p>--spring.profiles.active=prod,,,, --spring.config.location=target/application.properties</p>
<h2><a class="header" href="#读取环境信息" id="读取环境信息">读取环境信息</a></h2>
<pre><code class="language-java">/**
 * @author xiaoyu
 * date: 2020/3/21
 */
@SpringBootApplication
public class SpringbootDemoApp {

    /**
     * springboot在启动的时候需要检测当前项目是否是一个web项目，
     * 检测方式为判断classpath中是否有以下final变量中定义的两个参数
     */
    private static final String[] WEB_ENVIRONMENT_CLASSES =
            new String[]{&quot;javax.servlet.Servlet&quot;, &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;};

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootDemoApp.class, args);
        ConfigurableEnvironment        env     = context.getEnvironment();

        String[] activeProfiles = env.getActiveProfiles();
        String   port           = env.getProperty(&quot;server.port&quot;);

        System.out.println(&quot;==============================&quot;);
        System.out.println(&quot;active profiles: &quot; + Arrays.toString(activeProfiles));
        System.out.println(&quot;local uri: http://localhost:&quot; + port);
        System.out.println(&quot;local area network uri: http://&quot; + localAreaNetwork() + &quot;:&quot; + port);
        System.out.println(&quot;==============================&quot;);
    }

    private static String localAreaNetwork() {
        try {
            return InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            e.printStackTrace();
            return &quot;get local area network error&quot;;
        }
    }

    private boolean deduceWebEnv() {
        //https://blog.csdn.net/txba6868/article/details/80732475
        return true;
    }
}

@RestController
class DemoController {

    /**
     * file upload 文件上传
     */
    @RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.POST)
    public ResponseEntity&lt;String&gt; upload(HttpServletRequest request) throws IOException {
        MultipartHttpServletRequest req = (MultipartHttpServletRequest) request;
        MultipartFile aa = req.getFile(&quot;aa&quot;);
        MultipartFile bb = req.getFile(&quot;bb&quot;);
        aa.transferTo(Paths.get(System.getProperty(&quot;user.home&quot;) + &quot;/tmp&quot;).toFile());

        return ResponseEntity.ok(&quot;ok&quot;);
    }
}

</code></pre>
<h2><a class="header" href="#两种引入-springboot-方式" id="两种引入-springboot-方式">两种引入 springboot 方式</a></h2>
<p>一种是通过 设置 parent 为 spring boot starter parent</p>
<p>一种是通过 dependencyManagement 加入 spring boot dependencies (需要 设置 maven  properties, <code>maven.compiler.source</code> 和 <code>maven.compiler.target</code> 防止编译使用 jdk 1.5)</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

&lt;!--    &lt;parent&gt;--&gt;
&lt;!--        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;
&lt;!--        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;--&gt;
&lt;!--        &lt;version&gt;&lt;/version&gt;--&gt;
&lt;!--        &lt;relativePath/&gt; &amp;lt;!&amp;ndash; lookup parent from repository &amp;ndash;&amp;gt;--&gt;
&lt;!--    &lt;/parent&gt;--&gt;

    &lt;groupId&gt;io.github.xiaoyureed&lt;/groupId&gt;
    &lt;artifactId&gt;shopee&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;description&gt;聚合服务&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;spring-boot.version&gt;2.3.4.RELEASE&lt;/spring-boot.version&gt;
        &lt;spring-cloud.version&gt;Hoxton.SR8&lt;/spring-cloud.version&gt;
        &lt;spring-cloud-alibaba.version&gt;2.2.1.RELEASE&lt;/spring-cloud-alibaba.version&gt;
        &lt;aliyun-spring-boot.version&gt;1.0.0&lt;/aliyun-spring-boot.version&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;

        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-boot.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-cloud-alibaba.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;aliyun-spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${aliyun-spring-boot.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;3.4.0&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;8.0.21&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;dependency&gt;
                &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;
                &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;
                &lt;version&gt;7.9.2&lt;/version&gt;
            &lt;/dependency&gt;

&lt;!--            代码生成 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
                &lt;version&gt;3.4.0&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- https://mvnrepository.com/artifact/org.apache.velocity/velocity-engine-core --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
                &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;
                &lt;version&gt;2.2&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --&gt;
&lt;!--            common module need this--&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
                &lt;artifactId&gt;httpcore&lt;/artifactId&gt;
                &lt;version&gt;4.4.13&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;
                &lt;version&gt;3.11&lt;/version&gt;
            &lt;/dependency&gt;




        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;


&lt;/project&gt;
</code></pre>
<p>使用这种方式 spring boot maven plugin 可能失效, 需要手动配置</p>
<pre><code class="language-xml">&lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;repackage&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>
<h1><a class="header" href="#序列化-反序列化" id="序列化-反序列化">序列化 反序列化</a></h1>
<h2><a class="header" href="#日期时间-json" id="日期时间-json">日期时间 json</a></h2>
<p>https://www.cnblogs.com/carrychan/p/9883172.html
https://blog.csdn.net/z69183787/article/details/109356584</p>
<h2><a class="header" href="#jackson-使用" id="jackson-使用">jackson 使用</a></h2>
<p>springboot web starter 中包含了 Jackson-databind 依赖, 可以直接注入 objectmapper, 若自己定制:</p>
<h3><a class="header" href="#jsoncomponent" id="jsoncomponent">@JsonComponent</a></h3>
<p>用于对特定属性定制序列化</p>
<pre><code class="language-java">@Data
@AllArgsConstructor
public class User {
    private Color favoriteColor;
}


@JsonComponent
public class UserCombinedSerializer {

    public static class UserJsonSerializer // 若只需要序列化, 不需要反序列化, 则只需要这个类 并在这个类标注 @JsonComponent. 外层类和下面的内部类类都不需要, 
      extends JsonSerializer&lt;User&gt; {

        @Override
        public void serialize(User user, JsonGenerator jsonGenerator, 
          SerializerProvider serializerProvider) throws IOException, 
          JsonProcessingException {

            jsonGenerator.writeStartObject();
            jsonGenerator.writeStringField(
              &quot;favoriteColor&quot;, getColorAsWebColor(user.getFavoriteColor()));

            // ... 其他属性...

            jsonGenerator.writeEndObject();
        }

        private static String getColorAsWebColor(Color color) {
            int r = (int) Math.round(color.getRed() * 255.0);
            int g = (int) Math.round(color.getGreen() * 255.0);
            int b = (int) Math.round(color.getBlue() * 255.0);
            return String.format(&quot;#%02x%02x%02x&quot;, r, g, b);
        }
    }

    public static class UserJsonDeserializer 
      extends JsonDeserializer&lt;User&gt; {

        @Override
        public User deserialize(JsonParser jsonParser, 
          DeserializationContext deserializationContext)
          throws IOException, JsonProcessingException {

            TreeNode treeNode = jsonParser.getCodec().readTree(jsonParser);
            TextNode favoriteColor = (TextNode) treeNode.get(
              &quot;favoriteColor&quot;);
            return new User(Color.web(favoriteColor.asText()));
        }
    }
}
</code></pre>
<h3><a class="header" href="#jackson-在-springboot-中的配置" id="jackson-在-springboot-中的配置">Jackson 在 springboot 中的配置</a></h3>
<pre><code>spring.jackson.date-format指定日期格式，比如yyyy-MM-dd HH:mm:ss，或者具体的格式化类的全限定名

spring.jackson.deserialization是否开启Jackson的反序列化

spring.jackson.generator是否开启json的generators.

spring.jackson.joda-date-time-format指定Joda date/time的格式，比如yyyy-MM-ddHH:mm:ss). 如果没有配置的话，dateformat会作为backup

spring.jackson.locale指定json使用的Locale.

spring.jackson.mapper是否开启Jackson通用的特性.

spring.jackson.parser是否开启jackson的parser特性.

spring.jackson.property-naming-strategy指定PropertyNamingStrategy(CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES)或者指定PropertyNamingStrategy子类的全限定类名.

spring.jackson.serialization是否开启jackson的序列化.

spring.jackson.serialization-inclusion指定序列化时属性的inclusion方式，具体查看JsonInclude.Include枚举.

spring.jackson.time-zone指定日期格式化时区，比如America/Los_Angeles或者GMT+10
</code></pre>
<h3><a class="header" href="#jackson注解" id="jackson注解">jackson注解</a></h3>
<pre><code class="language-java">@JsonIgnore 此注解用于属性上，作用是进行JSON操作时忽略该属性。
@JsonIgnoreProperties(value = { &quot;intValue&quot; }) on type, 忽略指定属性
@JsonIgnoreType on type 忽略所有属性
        //or @JsonIgnoreType on mixin type(empty type) to ignore fields of the type which we have no access to
        //        mapper.addMixIn(String[].class, MyMixInForIgnoreType.class);//MyMixInForIgnoreType is empty
        //Note: Since version 2.5 – it seems that we can not use this method to ignore primitive data types, but we can use it for custom data types and arrays.
@JsonFormat 此注解用于属性上，作用是把Date类型直接转化为想要的格式，如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”)。
@JsonProperty 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，@JsonProperty(“name”)。
@JsonValue 用于属性/get方法上, 一个类只能用一个, 相当于自定义序列化, 当加上@JsonValue注解，序列化是只返回这一个字段的值/方法的值作为当前对象的值
@JsonRawValue on json string field to serialize raw json string
</code></pre>
<h3><a class="header" href="#objectmapper-定制" id="objectmapper-定制">objectmapper 定制</a></h3>
<p>https://www.kancloud.cn/ahutchen/spring-boot-reference-guide/333370</p>
<pre><code class="language-java">@Bean
    public ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();

        /*
        &gt;&gt;&gt; serialization config
         */
         //序列化的时候序列对象的所有属性
        //          JsonInclude.Include.NON_NULL 忽略 null 值
        //          Include.NON_EMPTY 如果为null或者 空字符串和空集合都不会被序列化
		objectMapper.setSerializationInclusion(Include.ALWAYS);
        
        //如果是空对象的时候,不抛异常
		objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);

        // 格式化输出
        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        //or
            mapper.enable(SerializationFeature.INDENT_OUTPUT);


        // 自定义时间格式
        //取消时间的转化格式,默认是时间戳,可以取消,同时需要设置要表现的时间格式
		objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);// 默认为true,会显示时间戳
		objectMapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;))

        //  config filter
        //
//        new SimpleBeanPropertyFilter.FilterExceptFilter()
//        objectMapper.setFilterProvider()





        /*
        &gt;&gt;&gt; deserialization config
         */
		//反序列化的时候如果多了其他属性,不抛出异常
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);





        //@JsonValue 可以用在get方法或者属性字段上，一个类只能用一个，当加上@JsonValue注解是，序列化是只返回这一个字段的值

        //@JsonRootName(value = &quot;user&quot;) to wrapper a root property for output json

        //@JsonSerialize(using = CustomDateSerializer.class) on field to specify a customized serializer
        // ex: class CustomDateSerializer extends StdSerializer&lt;Date&gt;

        return objectMapper;
    }

</code></pre>
<h3><a class="header" href="#objectmapper-使用" id="objectmapper-使用">objectmapper 使用</a></h3>
<pre><code class="language-java">
// &gt;&gt;&gt; 序列化数组

Person person1 = new Person(1, &quot;zxc&quot;, new Date());
Person person2 = new Person(2, &quot;ldh&quot;, new Date());
List&lt;Person&gt; persons = new ArrayList&lt;&gt;();
persons.add(person1);
persons.add(person2);
String personStr = objectMapper.writeValueAsString(persons);

//反序列化为List&lt;user&gt; 集合,1需要通过 TypeReference 来具体传递值
List&lt;Person&gt; persons2 = objectMapper.readValue(personStr, new TypeReference&lt;List&lt;Person&gt;&gt;() {});
//or 
//通过 JavaType 来进行处理返回
JavaType javaType = objectMapper.getTypeFactory().constructParametricType(List.class, Person.class);
List&lt;Person&gt; persons3 = objectMapper.readValue(personStr, javaType);
</code></pre>
<h1><a class="header" href="#拾遗" id="拾遗">拾遗</a></h1>
<h2><a class="header" href="#bean-懒加载" id="bean-懒加载">bean 懒加载</a></h2>
<p>一般情况下，Spring容器在启动时会创建所有的Bean对象，使用@Lazy注解 (和 @Component 共同使用) 可以将Bean对象的创建延迟到第一次使用Bean的时候</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="pre.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="springcloud-note.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="pre.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="springcloud-note.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
