---
title: 经典的系统设计思路
categories: distributed system
date: 2020-08-31 22:23:47
tags:
---


收集一些经典的系统设计思路

https://blog.csdn.net/Brad_PiTt7/article/details/90717429
TODO


https://github.com/0voice/interview_internal_reference 大厂面试题库

<!--more-->

<!-- TOC -->

- [第三方登录](#第三方登录)
- [直播弹幕系统](#直播弹幕系统)
- [秒杀系统](#秒杀系统)
  - [秒杀解决方案](#秒杀解决方案)
- [积分系统](#积分系统)
- [订单系统](#订单系统)
  - [订单号生成策略](#订单号生成策略)
  - [订单创建](#订单创建)
    - [扣减库存](#扣减库存)
      - [下单减库存](#下单减库存)
      - [付款减库存](#付款减库存)
- [feed 流系统](#feed-流系统)
- [点赞模块设计](#点赞模块设计)
  - [设计思路](#设计思路)
  - [优缺点](#优缺点)
  - [数据结构设计](#数据结构设计)
- [扫码登录](#扫码登录)
  - [扫码设计思路](#扫码设计思路)
- [Excel 表导入优化](#excel-表导入优化)
- [java 监控系统设计](#java-监控系统设计)
  - [检测哪些内容](#检测哪些内容)
  - [如何监控](#如何监控)
    - [程序内置监测](#程序内置监测)
    - [jdk 自带可视化工具](#jdk-自带可视化工具)
    - [jdk 自带命令行工具](#jdk-自带命令行工具)
    - [第三方工具](#第三方工具)
  - [案例 生鲜电商监控平台](#案例-生鲜电商监控平台)
- [消息推送系统 IM 系统](#消息推送系统-im-系统)
- [流程引擎系统](#流程引擎系统)
- [权限系统](#权限系统)
- [日志采集系统](#日志采集系统)

<!-- /TOC -->


# 第三方登录

https://mp.weixin.qq.com/s/3wHFNFQPtj86AocLhUQahw


# 直播弹幕系统

https://mp.weixin.qq.com/s/QTslEl7FRupsckfeq7fSLg
TODO

# 秒杀系统

## 秒杀解决方案

https://github.com/qiurunze123/miaosha

-   分布式 session , 为了抗并发, app 可能水平拓展, 各个 node 的 session 需要统一

    使用 Redis 存储 session

-   加缓存缓解数据库读取压力

    “分层校验”, 过滤尽量多的请求, 这时不做一致性校验, 比如可以直接从缓存读, 直到写库，才对库存做一致性检查

    允许读场景下一定的脏数据，这样只会导致少量原本无库存的下单请求被误认为是有库存的，等到真正写数据时再保证最终一致性，由此做到高可用和一致性之间的平衡。

-   页面静态化

-   异步下单

    使用消息队列
    
-   限流降级

-   应用层优化

    -   裁剪日志异常堆栈, 减少日志打印量

    -   去组件框架, 比如去掉传统的 MVC 框架，直接使用 Servlet 处理请求

    -   如何扣减库存

        -   下单减库存

            用户体验好, 但是可能面临恶意下单, 造成最后货物剩余

        -   付款减库存

            会出现 用户付款却没货了. 出现超卖, 用户体验较差

        -   预扣库存 (买家下单后，库存为其保留一定的时间（如 15 分钟），超过这段时间，库存自动释放)

            提高了恶意下单的成本, 体验还可以

            一般采用这种



# 积分系统

https://mp.weixin.qq.com/s/S8-P8h3_mhFWiEscEOi4ug



# 订单系统

功能: 订单列表、订单详情、在线下单

业务流程: 订单创建、订单支付、订单确认、订单完成、取消订单等订单流程

## 订单号生成策略

https://www.v2ex.com/t/770751#reply16
TODO

## 订单创建

先获取下单中涉及的商品信息，然后获取该商品所涉及到的优惠信息

增减库存:

### 扣减库存

#### 下单减库存

——即用户下单成功时减少库存数量

优势：用户体验友好，系统逻辑简洁；
缺点：会导致恶意下单或下单后却不买，使得真正有需求的用户无法购买，影响真实销量

解决办法：
设置订单有效时间，若订单创建成功N分钟不付款，则订单取消，库存回滚；
限购，用各种条件来限制买家的购买件数，比如一个账号、一个ip，只能买一件；
风控，从技术角度进行判断，屏蔽恶意账号，禁止恶意账号购买


#### 付款减库存

优势：减少无效订单带来的资源损耗；
缺点：因第三方支付返回结果存在时差，同一时间多个用户同时付款成功，会导致下单数目超过库存，商家库存不足容易引发断货和投诉，成本增加

解决办法：
付款前再次校验库存，如确认订单要付款时再验证一次，并友好提示用户库存不足；
增加提示信息：在商品详情页，订单步骤页面提示不及时付款，不能保证有库存等


# feed 流系统

https://mp.weixin.qq.com/s/q4w6DdjznVZBXh28MzHdgA
TODO


# 点赞模块设计

## 设计思路

点赞、取消点赞是高频次的操作，若每次都读写数据库，大量的操作会影响数据库性能，所以需要做缓存。将点赞数据扔到 redis 中, 然后离线刷回 MySQL

多久从 redis 中刷出一次数据到 MySQL 呢, 暂定为 2h

文章热度计算:文章获得点赞数越高，文章的热度就越高，那么怎么判断呢？不就直接记录点赞数就行啦，但是对于最新的文章怎么办？例如有一篇文章一年前发布的，获得 50 个赞，有篇最新文章获得 49 个赞，但是按照上面所说的一年前的文章热度还比最新的高，这就不合理了. ------------- 解决办法: 为每个文章加入一个 时间戳字段

## 优缺点

-   缓解了数据库写操作的压力

-   没法保证数据安全性

    比如 redis 挂了会丢失数据

    比如 点赞数据刷回 MySQL 不及时, 可能 redis 会在执行内存淘汰策略时淘汰这些数据 (不过 点赞数据也不是什么关键数据, 丢失一点问题也不大)

## 数据结构设计

MySQL:

-   user (id, name)
-   like_info (id, tweet_id, user, status)
-   tweet(id, content, user, like_count, hate_count)

redis:

每有一条点赞数据, 就存一条数据 tweet_id::user_id status, 点赞 status = 1, 取消点赞 status = 0

一个 hash(tweet_id, set(user_id, ...)) 结构存储某个人所有文章的点赞人情况, tweet_id:(user_id1, user_id2...)

# 扫码登录

## 扫码设计思路

web 端 和 服务器的配合:

1. user 访问登录页, server 随机生成 uuid, 作为键存入 redis, 值暂时为空, 同时设置过期时间, 根据 UUID + 验证字符串, 生成二维码 , 和 UUID 一起, 返回给 浏览器
1. browser 拿到 UUID 和 二维码, 之后每隔一秒向服务器发送一个请求, 看是否已经登录成功, 请求携带 UUID
1. server 根据 UUID 从 redis 获取 userID, 生成登录成功的 token, 浏览器登录成功

手机端 和 服务器配合:

1. 手机扫描二维码, 得到 UUID, 向 手机端服务器发送请求, 携带 UUID + 验证字符串 + user token (穿 token 而不是 直接 userId 是为了安全, token 是经过加密的)
1. 手机端服务器收到请求, 首先对比参数中的验证信息，确定是否为用户登录请求接口, 如果是，返回一个确认信息给手机端。
1. 手机端收到返回后，将登录确认框显示给用户, 用户确认, 手机再次发送请求, 携带 UUID, token
1. 服务器拿到 uuId 和 token 解析的 userId 后，将用户的 userid 作为 value 值存入 redis 中以 uuid 作为 key 的键值对中。

# Excel 表导入优化

缴费记录导入, 用户 将别的系统的数据填入我们系统中的 Excel 模板，应用将文件内容读取、校对、转换之后产生欠费数据、票据、票据详情并存储到数据库中; 校验包括:

-   字段长度, 字段内容正则校验, 都在内存中没有外部数据交互, 性能影响小
-   数据正确性, 重复性校验, 如票据号是否和系统已存在的票据号重复, 房屋是否存在

在我接手之前数据量还不大, 接手后数据量增加到 10w 级别, 对应到数据库就是 30w 级别, 经过优化后可以在 100s 内完成 (测试服务器 4g 内存不仅放了数据库 MySQL5.7，还放了很多微服务应用。处理能力不太行)

1. poi 读取 Excel 成 list
1. 遍历 list, 检验字段长度, 一些查询数据库的校验，比如校验当前行欠费对应的房屋是否在系统中存在, 写入当前行数据
1. 返回执行结果，如果出错 / 校验不合格。则返回提示信息并回滚数据 (涉及到三个表)

优化:

-   缓存: 将参加校验的数据全部缓存到 HashMap 中。直接到 HashMap 去命中

    校验行中的房屋是否存在，原本是要用 区域 + 楼宇 + 单元 + 房号 去查询房屋表匹配房屋 ID，查到则校验通过，生成的欠单中存储房屋 ID.因此我采用一条 SQL，将该小区下所有的房屋以 区域/楼宇/单元/房号 作为 key，以 房屋 ID 作为 value，存储到 HashMap 中

-   批量插入: MySQL insert 语句支持使用 values (),(),() 的方式一次插入多行数据，通过 mybatis foreach 结合 java 集合可以实现批量插入

-   EasyExcel 代替 poi, 注解方式读写 Excel

-   优化插入速度

    我使用了 values 批量插入代替逐行插入。每 30000 行拼接一个长 SQL、顺序插入。整个导入方法这块耗时最多。后来我将每次拼接的行数减少到 10000、5000、3000、1000、500 发现执行最快的是 1000

-   日志, info 日志 对比不打日志, 不打印日志耗时仅仅是打印日志耗时的 1/10

*   并行流, 榨干数据库的 CPU，利用网络 IO 的等待时间

```java
public class InsertConsumer {
    /**
     * 每个长 SQL 插入的行数，可以根据数据库性能调整
     */
    private final static int SIZE = 1000;

    /**
     * 如果需要调整并发数目，修改下面方法的第二个参数即可
     */
    static {
        System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "4");
    }

    /**
     * 插入方法
     *
     * @param list     插入数据集合
     * @param consumer 消费型方法，直接使用 mapper::method 方法引用的方式
     * @param <T>      插入的数据类型
     */
    public static <T> void insertData(List<T> list, Consumer<List<T>> consumer) {
        if (list == null || list.size() < 1) {
            return;
        }

        List<List<T>> streamList = new ArrayList<>();

        for (int i = 0; i < list.size(); i += SIZE) {
            int j = Math.min((i + SIZE), list.size());
            List<T> subList = list.subList(i, j);
            streamList.add(subList);
        }
        // 并行流使用的并发数是 CPU 核心数，不能局部更改。全局更改影响较大，斟酌
        streamList.parallelStream().forEach(consumer);
    }
}

```


# java 监控系统设计

## 检测哪些内容

-   当 java 运行一个应用，就会生成一个 JVM 的实例，而 java 应用则运行于此 JVM 实例中，当应用退出，JVM 实例也会关闭。启动多个 java 应用，也会启动多个 JVM 实例，它们不会相互影响
-   虚拟机主要有三大模块，
    -   一个类加载子系统（Class Loader Subsystem,负责加载类），
    -   一个执行引擎（Execution Engine,负责执行类的方法指令和垃圾回收），
    -   一个运行时数据区（Runtime Data Areas,负责存放程序运行时的数据）
        -   方法区（存储如类信息，方法信息，引用，常量池等），
        -   堆（存储类实例对象和数组），
        -   java 栈（以栈方式存放以帧为单位保存线程的运行状态帧），
        -   程序计数器（每一个线程都有它自己的程序计数器，表示下一条将被执行指令的“地址”）

java 应用启动流程就是通过类加载子系统加载相关的类，然后把相关数据如类信息，方法等存到方法区中，实例化相关的类存储在堆中，程序运行位置则是每个线程使用计数器来指定。方法区和堆是线程共享的，程序计数器及 Java 栈是线程私有的。

运行时数据区是 java 应用运行时的监测区域，其中各个区域的内存情况，特别是堆的内存使用情况，是重点区域。堆还会分年轻代、年老代及 Metaspace，垃圾回收器会进行分代回收。通过它的回收情况监测，可以检测到是否存在内存泄漏，而 java 栈则与线程有关，线程的运行状态又与 CPU 相关，因此 java 栈的监测可以知道 CPU 占用过大的问题，同时方法区和 java 栈的占用内存大小也是一个监测的指标

## 如何监控

### 程序内置监测

打印日志

另一方面可以输出系统属性 System.getProperties()及 System.getProperty()

对于 Spring Boot 应用，还可以使用 actuator 来监测程序运行情况

### jdk 自带可视化工具

在 windows 平台下，jdk 还提供了可视化监测工具，以更直观，更方便的方式对 java 应用运行状况进行监测。这两款工具分别是 jconsole 和 jvisualvm，在 jdk 下的 bin 目录下可以找到。它们均可监测本地及远程的 java 应用，包括堆使用情况，线程使用，cpu 使用，类加载情况，gc 情况，jvisualvm 还可以生成相应的堆和线程快照，同时还可以使用相应的插件，以便于进一步分析。

### jdk 自带命令行工具

-   jps 查看 java 进程 ID
-   jinfo 查看及调整虚拟机参数
-   jmap 查看堆(heap)使用情况及生成堆快照
-   jstack 查看线程运行状态及生成线程快照
-   jstat 显示进程中的类装载、内存、垃圾收集等运行数据。

### 第三方工具

-   MAT 是 eclipse 的内存分析插件，通过 MAT 可以对 dump 出来的堆快照进行分析，并且辅助分析内存泄露原因，快速的计算出在内存中对象的占用大小，垃圾收集器的回收工作情况，并可以通过报表直观的查看到可能造成这种结果的对象。
-   BTrace 是是 sun 推出的一款 Java 动态、安全追踪（监控）工具，可以在不停机的情况下监控系统运行情况，并且做到最少的侵入，占用最少的系统资源。特别适用在生产环境下对 java 应用进行监测，问题排查。
-   Arthas 是阿里开源的在线 Java 诊断工具，同样可以在不停机情况监控系统，包括内存情况，线程情况，GC 情况，运行时数据，也可以监测方法参数、返回值，异常返回等数据，堪称神器，在生产环境下使用非常方便。


## 案例 生鲜电商监控平台

https://mp.weixin.qq.com/s/9E6tdnPXHEtAeI2DO1KTdw

# 消息推送系统 IM 系统

im系统常用相关协议，如：xmpp，mqtt，pb等

mosquito

https://zhuanlan.zhihu.com/p/37993013
TODO

# 流程引擎系统

https://blog.csdn.net/herriman/article/details/51815925
https://blog.csdn.net/WSRspirit/article/details/81412344


# 权限系统

- 集中式认证服务, 认证中心提供一个认证凭据, 各个子系统可以通过这个凭据生成自己子系统的凭据
- 基于角色的权限模型 RBAC(Role-Based Access Control), 角色是权限的集合, 权限是操作的集合


# 日志采集系统

https://mp.weixin.qq.com/s/n2LsrWWsP1ALeLtOYl68XQ
TODO

