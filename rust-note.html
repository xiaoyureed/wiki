<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust-note - Xiaoyu Wiki</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="pre.html">pre page</a></li><li class="chapter-item expanded "><a href="SpringBoot-note.html"><strong aria-hidden="true">1.</strong> Spring boot note</a></li><li class="chapter-item expanded "><a href="springcloud-note.html"><strong aria-hidden="true">2.</strong> springcloud-note</a></li><li class="chapter-item expanded "><a href="java-concurrent.html"><strong aria-hidden="true">3.</strong> java-concurrent</a></li><li class="chapter-item expanded "><a href="java-memory-model-jmm-jvm.html"><strong aria-hidden="true">4.</strong> java-memory-model-jmm-jvm</a></li><li class="chapter-item expanded "><a href="java-note.html"><strong aria-hidden="true">5.</strong> java-note</a></li><li class="chapter-item expanded "><a href="rust-note.html" class="active"><strong aria-hidden="true">6.</strong> rust-note</a></li><li class="chapter-item expanded "><a href="git-note.html"><strong aria-hidden="true">7.</strong> git note</a></li><li class="chapter-item expanded "><a href="linux-note.html"><strong aria-hidden="true">8.</strong> linux-note</a></li><li class="chapter-item expanded "><a href="cross-gfw.html"><strong aria-hidden="true">9.</strong> cross gfw</a></li><li class="chapter-item expanded "><a href="react-note.html"><strong aria-hidden="true">10.</strong> react-note</a></li><li class="chapter-item expanded "><a href="cs-note.html"><strong aria-hidden="true">11.</strong> cs note</a></li><li class="chapter-item expanded "><a href="distributed-system.html"><strong aria-hidden="true">12.</strong> distributed system</a></li><li class="chapter-item expanded "><a href="message-queue.html"><strong aria-hidden="true">13.</strong> message-queue</a></li><li class="chapter-item expanded "><a href="data-structure-and-algorithm.html"><strong aria-hidden="true">14.</strong> data structure and algorithm</a></li><li class="chapter-item expanded "><a href="effective-java-reading-note.html"><strong aria-hidden="true">15.</strong> effective java reading note</a></li><li class="chapter-item expanded "><a href="docker-note.html"><strong aria-hidden="true">16.</strong> docker note</a></li><li class="chapter-item expanded "><a href="how-to-test-java-app.html"><strong aria-hidden="true">17.</strong> how-to-test-java-app</a></li><li class="chapter-item expanded "><a href="maven-note.html"><strong aria-hidden="true">18.</strong> maven-note</a></li><li class="chapter-item expanded "><a href="mac.html"><strong aria-hidden="true">19.</strong> mac</a></li><li class="chapter-item expanded "><a href="autohotkey.html"><strong aria-hidden="true">20.</strong> AHK collection</a></li><li class="chapter-item expanded "><a href="class-conflict-check.html"><strong aria-hidden="true">21.</strong> class conflict check</a></li><li class="chapter-item expanded "><a href="cpp.html"><strong aria-hidden="true">22.</strong> cpp</a></li><li class="chapter-item expanded "><a href="create-blog-by-react.html"><strong aria-hidden="true">23.</strong> create blog by react</a></li><li class="chapter-item expanded "><a href="css-note.html"><strong aria-hidden="true">24.</strong> css-note</a></li><li class="chapter-item expanded "><a href="css-pre-processor.html"><strong aria-hidden="true">25.</strong> css pre processor</a></li><li class="chapter-item expanded "><a href="defect-about-java-programmer-from-programming-thinking.html"><strong aria-hidden="true">26.</strong> from programming thinking</a></li><li class="chapter-item expanded "><a href="design-pattern-note.html"><strong aria-hidden="true">27.</strong> design pattern note</a></li><li class="chapter-item expanded "><a href="dev-resources.html"><strong aria-hidden="true">28.</strong> dev resources</a></li><li class="chapter-item expanded "><a href="eclipse.html"><strong aria-hidden="true">29.</strong> eclipse</a></li><li class="chapter-item expanded "><a href="extjs-note.html"><strong aria-hidden="true">30.</strong> extjs-note</a></li><li class="chapter-item expanded "><a href="FreeMarker-note.html"><strong aria-hidden="true">31.</strong> FreeMarker-note</a></li><li class="chapter-item expanded "><a href="go-note.html"><strong aria-hidden="true">32.</strong> golang</a></li><li class="chapter-item expanded "><a href="hello-world.html"><strong aria-hidden="true">33.</strong> hexo</a></li><li class="chapter-item expanded "><a href="html-note.html"><strong aria-hidden="true">34.</strong> html-note</a></li><li class="chapter-item expanded "><a href="idea-note.html"><strong aria-hidden="true">35.</strong> idea-note</a></li><li class="chapter-item expanded "><a href="interview-system-design.html"><strong aria-hidden="true">36.</strong> interview-system-design</a></li><li class="chapter-item expanded "><a href="java-code-clean.html"><strong aria-hidden="true">37.</strong> java-code-clean</a></li><li class="chapter-item expanded "><a href="job-interview-cv.html"><strong aria-hidden="true">38.</strong> job-interview-cv</a></li><li class="chapter-item expanded "><a href="joke-collecting.html"><strong aria-hidden="true">39.</strong> joke-collecting</a></li><li class="chapter-item expanded "><a href="jquery-note.html"><strong aria-hidden="true">40.</strong> jquery-note</a></li><li class="chapter-item expanded "><a href="js-tutorial.html"><strong aria-hidden="true">41.</strong> js-tutorial</a></li><li class="chapter-item expanded "><a href="money.html"><strong aria-hidden="true">42.</strong> money</a></li><li class="chapter-item expanded "><a href="mongodb-note.html"><strong aria-hidden="true">43.</strong> mongodb-note</a></li><li class="chapter-item expanded "><a href="mvc-mvvm.html"><strong aria-hidden="true">44.</strong> mvc-mvvm</a></li><li class="chapter-item expanded "><a href="my-ioc.html"><strong aria-hidden="true">45.</strong> my-ioc</a></li><li class="chapter-item expanded "><a href="mybatis-note.html"><strong aria-hidden="true">46.</strong> mybatis-note</a></li><li class="chapter-item expanded "><a href="mysql-note.html"><strong aria-hidden="true">47.</strong> mysql-note</a></li><li class="chapter-item expanded "><a href="nodejs.html"><strong aria-hidden="true">48.</strong> nodejs</a></li><li class="chapter-item expanded "><a href="outline-about-cache.html"><strong aria-hidden="true">49.</strong> outline-about-cache</a></li><li class="chapter-item expanded "><a href="outline-about-db-design-note.html"><strong aria-hidden="true">50.</strong> outline-about-db-design-note</a></li><li class="chapter-item expanded "><a href="outline-about-http.html"><strong aria-hidden="true">51.</strong> outline-about-http</a></li><li class="chapter-item expanded "><a href="outline-about-rest-api.html"><strong aria-hidden="true">52.</strong> outline-about-rest-api</a></li><li class="chapter-item expanded "><a href="php-note.html"><strong aria-hidden="true">53.</strong> php-note</a></li><li class="chapter-item expanded "><a href="postgres-note.html"><strong aria-hidden="true">54.</strong> postgres-note</a></li><li class="chapter-item expanded "><a href="python-note.html"><strong aria-hidden="true">55.</strong> python-note</a></li><li class="chapter-item expanded "><a href="redis-login-limitation.html"><strong aria-hidden="true">56.</strong> redis-login-limitation</a></li><li class="chapter-item expanded "><a href="redis-note.html"><strong aria-hidden="true">57.</strong> redis-note</a></li><li class="chapter-item expanded "><a href="regex-js.html"><strong aria-hidden="true">58.</strong> regex-js</a></li><li class="chapter-item expanded "><a href="servlet.html"><strong aria-hidden="true">59.</strong> servlet</a></li><li class="chapter-item expanded "><a href="spring-note.html"><strong aria-hidden="true">60.</strong> spring-note</a></li><li class="chapter-item expanded "><a href="springboot-doc.html"><strong aria-hidden="true">61.</strong> springboot-doc</a></li><li class="chapter-item expanded "><a href="springmvc-note.html"><strong aria-hidden="true">62.</strong> springmvc-note</a></li><li class="chapter-item expanded "><a href="task-schedule-note.html"><strong aria-hidden="true">63.</strong> task-schedule-note</a></li><li class="chapter-item expanded "><a href="tcp-ip-note.html"><strong aria-hidden="true">64.</strong> tcp-ip-note</a></li><li class="chapter-item expanded "><a href="tomcat-jetty-nginx.html"><strong aria-hidden="true">65.</strong> tomcat-jetty-nginx</a></li><li class="chapter-item expanded "><a href="webpack-note.html"><strong aria-hidden="true">66.</strong> webpack-note</a></li><li class="chapter-item expanded "><a href="windows-sub-system-on-linux.html"><strong aria-hidden="true">67.</strong> windows-sub-system-on-linux</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Xiaoyu Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<h2>title: A Bit of Rust
categories: language
date: 2020-08-31 22:15:27</h2>
<p>https://github.com/rust-unofficial/awesome-rust
https://github.com/rust-lang-nursery/rust-cookbook</p>
<p>https://play.integer32.com/
https://play.rust-lang.org/</p>
<p>servo 新一代浏览器引擎</p>
<p>https://www.rust-lang.org/ 官方站</p>
<p>https://users.rust-lang.org/ 社区
https://rustcc.cn/ 中文社区</p>
<p>https://doc.rust-lang.org/std/ std api</p>
<p>https://docs.rs/  cates api 文档
https://crates.io/ crates 搜索</p>
<p>https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html the book 手册
https://kaisery.github.io/trpl-zh-cn/title-page.html the book 翻译</p>
<p>https://github.com/rust-lang/nomicon 死灵书 设计原理</p>
<p>https://doc.rust-lang.org/stable/reference/introduction.html</p>
<p>https://doc.rust-lang.org/stable/rust-by-example/macros/dsl.html example
https://books.budshome.com/rust-by-example/testing/unit_testing.html 中文</p>
<p>https://rust-unofficial.github.io/too-many-lists/ another tutorial</p>
<p>https://cheats.rs/#data-structures 速查表</p>
<p>https://doc.rust-lang.org/cargo/index.html cargo book
https://cargo.budshome.com/index.html</p>
<p>https://github.com/chinanf-boy?tab=stars - 爱好者
https://github.com/AurevoirXavier - 爱好者
https://github.com/BurntSushi - master
https://github.com/rust-lang 官方GitHub</p>
<p>http://intorust.com/ 动画介绍</p>
<p>https://zhuanlan.zhihu.com/c_208092758/ 知乎专栏
https://zhuanlan.zhihu.com/c_118514498</p>
<p>https://github.com/phil-opp/blog_os rust 实现os</p>
<p>https://github.com/Kilerd/resource - 中文资料收集
https://zhuanlan.zhihu.com/rust-lang
https://wiki.jikexueyuan.com/project/rust-primer/concurrency-parallel-thread/thread.html</p>
<p>https://github.com/aylei/leetcode-rust 算法实现</p>
<p>https://www.zhihu.com/question/382172347/answer/1103525234 tips
https://www.zhihu.com/question/393796866/answer/1213171124</p>
<p>https://www.zhihu.com/question/30407715/answer/48032883</p>
<p>https://www.zhihu.com/question/34665842?sort=created 练手
https://www.zhihu.com/question/352420716/answer/973279231</p>
<p>https://www.zhihu.com/question/30511494/answer/649921526 值得关注</p>
<!--more-->
<!-- TOC -->
<ul>
<li><a href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">简单介绍</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li>
<li><a href="#%E7%89%B9%E6%80%A7">特性</a></li>
<li><a href="#%E8%AF%AD%E4%B9%89-%E6%A6%82%E5%BF%B5">语义 概念</a></li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">开发环境配置</a>
<ul>
<li><a href="#install">install</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8">命令行工具使用</a></li>
<li><a href="#ide">IDE</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F">配置国内镜像</a></li>
</ul>
</li>
<li><a href="#%E6%A0%87%E5%87%86%E5%BA%93">标准库</a>
<ul>
<li><a href="#path-%E8%B7%AF%E5%BE%84">path 路径</a></li>
<li><a href="#%E6%97%B6%E9%97%B4">时间</a></li>
</ul>
</li>
<li><a href="#2015-%E5%AF%B9%E6%AF%94-2018">2015 对比 2018</a>
<ul>
<li><a href="#nll">nll</a></li>
<li><a href="#raw-identifier">Raw identifier</a></li>
<li><a href="#%E7%AE%80%E5%8C%96%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">简化模式匹配</a></li>
<li><a href="#main-%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%BF%94%E5%9B%9E-result">main 函数可以返回 Result</a></li>
<li><a href="#impl-trait-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B">impl trait 抽象类型</a></li>
</ul>
</li>
<li><a href="#%E8%AF%AD%E6%B3%95">语法</a>
<ul>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC">变量赋值</a>
<ul>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84">默认是不可变的</a></li>
<li><a href="#%E5%AD%97%E9%9D%A2%E9%87%8F">字面量</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</a>
<ul>
<li><a href="#%E5%80%BC%E7%B1%BB%E5%9E%8B-and-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">值类型 and 引用类型</a></li>
<li><a href="#%E5%B8%B8%E9%87%8F-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F">常量 静态变量</a></li>
<li><a href="#%E6%95%B0%E5%AD%97">数字</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E5%80%BC-%E5%AD%97%E7%AC%A6-%E5%AD%97%E8%8A%82">布尔值 字符 字节</a></li>
<li><a href="#%E6%95%B0%E7%BB%84">数组</a></li>
<li><a href="#range-%E8%8C%83%E5%9B%B4">Range 范围</a></li>
<li><a href="#%E5%88%87%E7%89%87">切片</a></li>
<li><a href="#str-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87">str 字符串切片</a></li>
<li><a href="#%E5%8E%9F%E7%94%9F%E6%8C%87%E9%92%88-row-pointer">原生指针 row pointer</a></li>
<li><a href="#never-%E7%B1%BB%E5%9E%8B-%E6%84%9F%E5%8F%B9%E5%8F%B7">never 类型 感叹号</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>
<ul>
<li><a href="#%E5%87%A0%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%BA%E5%88%AB">几种字符串区别</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">常用方法</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2">字符串转换</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96">格式化</a></li>
<li><a href="#%E8%B0%83%E8%AF%95%E6%89%93%E5%8D%B0%E7%AC%A6%E5%90%88%E7%B1%BB%E5%9E%8B--debug-trait-display-trait">调试打印符合类型  Debug trait Display trait</a></li>
<li><a href="#%E9%97%AE%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%A4%9A%E6%AC%A1%E5%86%99">问号操作符 多次写</a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a>
<ul>
<li><a href="#vec-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84">Vec 动态数组</a></li>
<li><a href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-vecdeque">双端队列 VecDeque</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8-linkedlist">链表 Linkedlist</a></li>
<li><a href="#hashmap--%E6%97%A0%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8">hashmap  无序哈希表</a>
<ul>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">哈希表基本使用</a></li>
<li><a href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA-key">复合类型作为 key</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E%E6%94%BB%E5%87%BB">哈希碰撞攻击</a></li>
</ul>
</li>
<li><a href="#btreemap-%E6%9C%89%E5%BA%8F%E5%93%88%E5%B8%8C%E8%A1%A8">BTreeMap 有序哈希表</a></li>
<li><a href="#hashset-%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88">hashset 无序集合</a></li>
<li><a href="#btreeset-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88">BTreeSet 有序集合</a></li>
<li><a href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-binaryheap">优先队列 BinaryHeap</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">基本的类型转换</a></li>
<li><a href="#%E8%BD%AC%E6%8D%A2%E7%9B%B8%E5%85%B3%E7%9A%84-trait">转换相关的 trait</a></li>
</ul>
</li>
<li><a href="#%E6%89%80%E6%9C%89%E6%9D%83">所有权</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%89%80%E6%9C%89%E6%9D%83-raii%E6%9C%BA%E5%88%B6">为什么需要所有权 RAII机制</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99">基本原则</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B5%8B%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83">字符串赋值的所有权</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83">函数参数的所有权</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%89%80%E6%9C%89%E6%9D%83">函数返回值所有权</a></li>
<li><a href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83">复合类型中的所有权</a></li>
<li><a href="#%E5%A4%9A%E6%89%80%E6%9C%89%E6%9D%83">多所有权</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%82%E6%95%B0">生命周期参数</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">什么是生命周期</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E9%87%8A">为什么存在生命周期注释</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%82%E6%95%B0">函数中的生命周期参数</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E7%9C%81%E7%95%A5%E7%9A%84%E8%A7%84%E5%88%99">结构体中生命周期 省略的规则</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E9%87%8A">静态生命周期注释</a></li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BA%A6%E6%9D%9F">生命周期约束</a></li>
</ul>
</li>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a>
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D">引用基本介绍</a></li>
<li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8">不可变引用</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8">可变引用</a></li>
<li><a href="#%E5%9E%82%E6%82%AC%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98dangling-references">垂悬引用问题（Dangling References)</a></li>
</ul>
</li>
<li><a href="#%E8%A3%B8%E6%8C%87%E9%92%88">裸指针</a></li>
<li><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">智能指针</a>
<ul>
<li><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BB%8B%E7%BB%8D">智能指针介绍</a></li>
<li><a href="#raii%E6%9C%BA%E5%88%B6-%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6">RAII机制 实现内存回收</a></li>
<li><a href="#box-%E6%97%A0%E7%97%9B%E4%BD%BF%E7%94%A8%E5%A0%86%E5%86%85%E5%AD%98">Box 无痛使用堆内存</a>
<ul>
<li><a href="#box%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">Box基本使用</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">自定义智能指针</a></li>
<li><a href="#%E5%8C%85%E8%A3%85%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B">包装动态大小类型</a></li>
</ul>
</li>
<li><a href="#rc-%E5%92%8C-weak-%E5%85%B1%E4%BA%AB%E5%A0%86%E5%86%85%E5%AD%98">Rc 和 Weak 共享堆内存</a>
<ul>
<li><a href="#rc-%E5%BC%BA%E5%BC%95%E7%94%A8">Rc 强引用</a></li>
<li><a href="#%E5%AF%B9%E5%86%85%E9%83%A8%E5%80%BC%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9">对内部值进行修改</a></li>
<li><a href="#weak-%E5%BC%B1%E5%BC%95%E7%94%A8">Weak 弱引用</a></li>
</ul>
</li>
<li><a href="#refcell-%E5%92%8C-cell-%E6%8F%90%E4%BE%9B%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7">RefCell 和 Cell 提供内部可变性</a>
<ul>
<li><a href="#cell">Cell</a></li>
<li><a href="#refcell">RefCell</a></li>
</ul>
</li>
<li><a href="#rc-box-refcell-cell-%E5%87%A0%E7%A7%8D%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94">Rc Box RefCell Cell 几种指针的区别对比</a></li>
<li><a href="#cow-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6">Cow 写时复制</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">函数基本语法</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%93%E8%A1%A8%E8%BE%BE%E5%BC%8F">函数体表达式</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">函数作为参数</a></li>
<li><a href="#result-%E8%BF%94%E5%9B%9E%E5%80%BC">Result 返回值</a></li>
<li><a href="#%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0">发散函数</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">泛型函数</a></li>
<li><a href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">函数指针</a></li>
<li><a href="#%E7%A6%81%E6%AD%A2%E5%87%BD%E6%95%B0%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%8F%98%E9%87%8F">禁止函数捕获外部环境中变量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%97%AD%E5%8C%85">闭包</a>
<ul>
<li><a href="#%E9%97%AD%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">闭包基本使用</a></li>
<li><a href="#rust-%E5%AE%9E%E7%8E%B0%E9%97%AD%E5%8C%85%E7%9A%84%E5%8E%9F%E7%90%86">rust 实现闭包的原理</a></li>
<li><a href="#%E6%8D%95%E8%8E%B7%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-and-%E4%B8%89%E7%A7%8D%E9%97%AD%E5%8C%85%E7%B1%BB%E5%9E%8B">捕获环境变量 and 三种闭包类型</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC-or-%E5%8F%82%E6%95%B0">闭包作为返回值 or 参数</a>
<ul>
<li><a href="#%E9%80%83%E9%80%B8%E9%97%AD%E5%8C%85-%E9%9D%9E%E9%80%83%E9%80%B8%E9%97%AD%E5%8C%85">逃逸闭包 非逃逸闭包</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">闭包作为参数</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC">闭包作为返回值</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">闭包参数中的生命周期</a></li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8">什么是迭代器</a></li>
<li><a href="#iterator-trait">Iterator trait</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-%E6%94%B6%E9%9B%86%E5%99%A8-%E5%87%BD%E6%95%B0%E5%BC%8F%E9%A3%8E%E6%A0%BC">迭代器适配器 收集器 函数式风格</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8">自定义迭代器</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%82%E9%85%8D%E5%99%A8-%E6%94%B6%E9%9B%86%E5%99%A8">自定义适配器 收集器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF">条件循环</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a>
<ul>
<li><a href="#%E5%8D%95%E6%80%81%E5%8C%96">单态化</a></li>
<li><a href="#%E5%A4%9A%E9%87%8D%E7%BA%A6%E6%9D%9F-%E5%8A%A0%E5%8F%B7">多重约束 加号</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0-and-%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">默认泛型参数 and 关联类型</a></li>
<li><a href="#%E7%A9%BA%E7%BA%A6%E6%9D%9F">空约束</a></li>
<li><a href="#turbofish-%E6%93%8D%E4%BD%9C%E7%AC%A6-and-%E8%BF%94%E5%9B%9E%E5%80%BC%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC">turbofish 操作符 and 返回值自动推导</a></li>
</ul>
</li>
<li><a href="#trait">trait</a>
<ul>
<li><a href="#trait-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">trait 基本使用</a></li>
<li><a href="#%E5%AD%A4%E5%84%BF%E8%A7%84%E5%88%99">孤儿规则</a></li>
<li><a href="#%E7%89%B9%E5%8C%96-specialization">特化 Specialization</a></li>
<li><a href="#trait-%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0-%E9%9C%80%E8%A6%81-impl-%E5%89%8D%E7%BC%80">trait 作为参数 需要 impl 前缀</a></li>
<li><a href="#trait-%E4%BD%9C%E4%B8%BA-%E8%BF%94%E5%9B%9E%E5%80%BC-%E8%BF%94%E5%9B%9E%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B">trait 作为 返回值 返回动态类型</a></li>
<li><a href="#%E6%B4%BE%E7%94%9F-trait-%E5%92%8C-%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC-trait%E5%AE%9E%E7%8E%B0">派生 trait 和 自动推导 trait实现</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">运算符重载</a></li>
<li><a href="#trait-%E7%BB%A7%E6%89%BF">trait 继承</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E5%88%86%E5%8F%91-%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91">静态分发 动态分发</a></li>
<li><a href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B">抽象类型</a>
<ul>
<li><a href="#trait%E5%AF%B9%E8%B1%A1">trait对象</a></li>
<li><a href="#trait%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-sized-trait">trait对象安全问题 Sized trait</a></li>
<li><a href="#impl-trait">impl trait</a></li>
</ul>
</li>
<li><a href="#trait%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">trait的类型转换</a></li>
<li><a href="#from-trait-into-trait">From trait Into trait</a></li>
<li><a href="#derefmut%E5%92%8C-deref">DerefMut和 Deref</a></li>
<li><a href="#asref-trait-asmut-trait">AsRef trait AsMut trait</a></li>
<li><a href="#borrow-trait">Borrow trait</a></li>
<li><a href="#debug-trait">Debug trait</a></li>
<li><a href="#drop-trait-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE">Drop trait 资源释放</a></li>
<li><a href="#clone-trait">Clone trait</a></li>
<li><a href="#%E6%A0%87%E7%AD%BE-trait">标签 trait</a>
<ul>
<li><a href="#send-trait-%E5%92%8C-sync-trait">Send trait 和 Sync trait</a></li>
<li><a href="#copy-trait">Copy trait</a></li>
<li><a href="#sized-trait--%E5%92%8C-unsized-trait-%E5%92%8C-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B">Sized trait  和 Unsized trait 和 动态类型</a></li>
</ul>
</li>
<li><a href="#default-trait">Default trait</a></li>
<li><a href="#extend-trait">Extend trait</a></li>
<li><a href="#any-trait">Any trait</a></li>
<li><a href="#%E5%92%8C%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%9A%84trait">和比较排序相关的trait</a></li>
</ul>
</li>
<li><a href="#%E5%85%83%E7%BB%84">元组</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a>
<ul>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">结构体基本使用</a></li>
<li><a href="#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93-and-%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93">元组结构体 and 单元结构体</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95">结构体方法</a></li>
<li><a href="#new-type-%E6%A8%A1%E5%BC%8F-%E5%92%8C-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-self%E5%88%AB%E5%90%8D">new type 模式 和 类型别名 Self别名</a></li>
<li><a href="#%E6%A1%88%E4%BE%8B-%E5%BD%A9%E8%89%B2%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA">案例 彩色命令行输出</a></li>
</ul>
</li>
<li><a href="#%E6%9E%9A%E4%B8%BE">枚举</a>
<ul>
<li><a href="#%E6%9E%9A%E4%B8%BE%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">枚举基本使用</a></li>
<li><a href="#option">Option</a></li>
<li><a href="#c-%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%9E%9A%E4%B8%BE">c 风格的枚举</a></li>
<li><a href="#%E6%A1%88%E4%BE%8B-%E5%BD%A9%E8%89%B2%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%87%BA%E4%BC%98%E5%8C%96">案例 彩色命令行输出优化</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B-%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8">实例 创建链表</a></li>
</ul>
</li>
<li><a href="#match-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">match 模式匹配</a>
<ul>
<li><a href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">模式匹配简单使用</a></li>
<li><a href="#if-lef-while-let-%E8%AF%AD%E6%B3%95%E7%B3%96">if lef while let 语法糖</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a>
<ul>
<li><a href="#%E6%96%AD%E8%A8%80">断言</a></li>
<li><a href="#panic-%E5%92%8C-abort">panic 和 Abort</a></li>
<li><a href="#result--%E5%92%8C-%E9%97%AE%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6">Result  和 问号操作符</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E8%A3%85%E7%AE%B1-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">错误装箱 自定义异常</a></li>
<li><a href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8">捕获异常</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%BF%9B%E5%8C%96%E8%BF%87%E7%A8%8B">错误处理进化过程</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">第三方库处理异常</a></li>
</ul>
</li>
<li><a href="#io">io</a>
<ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">命令行参数</a></li>
<li><a href="#%E6%96%87%E4%BB%B6-io">文件 io</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-oop">面向对象 oop</a>
<ul>
<li><a href="#%E5%8F%AF%E8%A7%81%E6%80%A7">可见性</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
<li><a href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B">向下转型</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a>
<ul>
<li><a href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F">建造者模式</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">访问者模式</a></li>
<li><a href="#raii%E6%A8%A1%E5%BC%8F">raii模式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AD%90%E8%BF%9B%E7%A8%8B">子进程</a></li>
<li><a href="#ffi-%E5%A4%96%E9%83%A8%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3">ffi 外部语言函数接口</a></li>
<li><a href="#%E5%8F%8D%E5%B0%84">反射</a></li>
<li><a href="#%E5%AE%8F">宏</a>
<ul>
<li><a href="#%E5%86%85%E7%BD%AE%E5%AE%8F">内置宏</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%AE%8F">创建宏</a></li>
<li><a href="#%E5%AE%8F%E9%87%8D%E8%BD%BD">宏重载</a></li>
<li><a href="#%E8%BF%87%E7%A8%8B%E5%AE%8F">过程宏</a></li>
</ul>
</li>
<li><a href="#unsafe-%E5%B1%8F%E8%94%BD%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5">unsafe 屏蔽内存安全检查</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a>
<ul>
<li><a href="#%E5%A0%86-%E5%92%8C-%E6%A0%88">堆 和 栈</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">内存对齐</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86-%E6%A8%A1%E5%9D%97">工程管理 模块</a>
<ul>
<li><a href="#%E6%A6%82%E5%BF%B5%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A">概念简单解释</a></li>
<li><a href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86">编译器版本管理</a></li>
<li><a href="#%E4%B8%BA%E9%A1%B9%E7%9B%AE%E5%8D%95%E7%8B%AC%E6%8C%87%E5%AE%9Aconfig-%E9%85%8D%E7%BD%AE">为项目单独指定config 配置</a></li>
<li><a href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-cargo">依赖管理 cargo</a>
<ul>
<li><a href="#cargo-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4">cargo 基本命令</a></li>
<li><a href="#cargotoml">Cargo.toml</a></li>
<li><a href="#cargolock">cargo.lock</a></li>
<li><a href="#workspace">workspace</a></li>
<li><a href="#%E4%BE%9D%E8%B5%96%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E8%A7%84%E5%88%99">依赖的版本号规则</a></li>
</ul>
</li>
<li><a href="#buildrs">build.rs</a></li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%A1%88%E4%BE%8B">项目管理案例</a>
<ul>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89-crate">导入自定义 crate</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E5%AD%90%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84-module">执行子目录中的 module</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89-module">导入自定义 module</a></li>
<li><a href="#%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9-crate">导入第三方 crate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a></li>
<li><a href="#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91-and-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91">交叉编译 and 条件编译</a></li>
<li><a href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B">异步编程</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5-%E5%8D%95%E7%BA%BF%E7%A8%8B-webserver">为什么使用异步 单线程 webserver</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">基本使用</a>
<ul>
<li><a href="#block_on">block_on</a></li>
<li><a href="#await">await</a></li>
<li><a href="#join">join</a></li>
</ul>
</li>
<li><a href="#async-std">async-std</a></li>
<li><a href="#future-trait">Future trait</a></li>
<li><a href="#%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0-future-%E7%B1%BB%E5%9E%8B">动手实现 Future 类型</a></li>
<li><a href="#%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0-%E5%BC%82%E6%AD%A5-sleep">动手实现 异步 sleep</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B">并发 多线程</a>
<ul>
<li><a href="#crossbeam-%E5%BC%80%E6%BA%90%E5%BA%93">CrossBeam 开源库</a></li>
<li><a href="#arc-%E5%92%8C-rc">Arc 和 Rc</a></li>
<li><a href="#rwlock-%E5%92%8C-refcell">RwLock 和 RefCell</a></li>
<li><a href="#mutex">Mutex</a></li>
<li><a href="#atomicptr-%E5%92%8C-cell">AtomicPtr 和 Cell</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">线程基本使用</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B0%8F%E4%BE%8B%E5%AD%90">多线程小例子</a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0-map-reduce-%E7%AE%97%E6%B3%95">实现 map-reduce 算法</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BB%9F%E8%AE%A1%E5%92%8C">多线程统计和</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0-webserver">多线程 线程池 webserver</a></li>
</ul>
</li>
<li><a href="#channel">channel</a></li>
<li><a href="#%E4%BA%92%E6%96%A5-%E9%94%81">互斥 锁</a></li>
</ul>
</li>
<li><a href="#%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">简单文件系统</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a>
<ul>
<li><a href="#tcp">tcp</a></li>
<li><a href="#udp">udp</a></li>
</ul>
</li>
<li><a href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6">消息中间件</a></li>
<li><a href="#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91">游戏开发</a></li>
<li><a href="#%E7%88%AC%E8%99%AB">爬虫</a></li>
<li><a href="#rpc-%E6%A1%86%E6%9E%B6">rpc 框架</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E4%BB%A3%E7%90%86">编写代理</a>
<ul>
<li><a href="#http-%E4%BB%A3%E7%90%86">http 代理</a></li>
<li><a href="#socket-%E4%BB%A3%E7%90%86">socket 代理</a></li>
</ul>
</li>
<li><a href="#webassembly">webassembly</a></li>
<li><a href="#%E5%92%8C-java-%E4%BA%A4%E4%BA%92">和 java 交互</a>
<ul>
<li><a href="#rust-%E8%B0%83%E7%94%A8-java">rust 调用 java</a></li>
<li><a href="#java-%E8%B0%83%E7%94%A8-rust">java 调用 rust</a></li>
</ul>
</li>
<li><a href="#%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-web-%E6%B8%B8%E6%88%8F">开发微信小程序-web 游戏</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9-crates">第三方 crates</a>
<ul>
<li><a href="#web-%E5%BC%80%E5%8F%91">web 开发</a>
<ul>
<li><a href="#web%E6%A1%86%E6%9E%B6">web框架</a></li>
<li><a href="#orm">orm</a></li>
<li><a href="#http-client">http client</a></li>
</ul>
</li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">序列化反序列化</a>
<ul>
<li><a href="#toml">toml</a></li>
<li><a href="#json">json</a></li>
</ul>
</li>
<li><a href="#%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F">日志系统</a>
<ul>
<li><a href="#env_logger">env_logger</a></li>
<li><a href="#log4rs-and-log">log4rs and log</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90%E5%99%A8">文本解析器</a></li>
<li><a href="#lazy-static-%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96">lazy static 延迟初始化</a></li>
<li><a href="#%E7%94%B5%E5%AD%90%E4%B9%A6">电子书</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F">命令行程序</a>
<ul>
<li><a href="#structopt">structopt</a></li>
<li><a href="#clap">clap</a></li>
</ul>
</li>
<li><a href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-1">异步编程</a></li>
<li><a href="#websocket">websocket</a></li>
<li><a href="#%E7%BC%A9%E5%B0%8F%E4%BD%93%E7%A7%AF">缩小体积</a></li>
<li><a href="#http-client-1">http client</a></li>
<li><a href="#%E5%AE%B9%E9%94%99%E8%BF%90%E8%A1%8C%E6%97%B6">容错运行时</a></li>
<li><a href="#%E5%88%86%E5%8F%91%E5%B7%A5%E5%85%B7">分发工具</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-1">错误处理</a></li>
<li><a href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a></li>
<li><a href="#gui-%E5%9B%BE%E5%BD%A2%E5%BA%93">gui 图形库</a></li>
<li><a href="#%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C-api">底层网络 api</a></li>
<li><a href="#%E6%AD%A3%E5%88%99">正则</a></li>
<li><a href="#%E9%9A%8F%E6%9C%BA">随机</a>
<ul>
<li><a href="#rand-%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97">rand 随机数字</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE">开源项目</a></li>
</ul>
<!-- /TOC -->
<h1><a class="header" href="#简单介绍" id="简单介绍">简单介绍</a></h1>
<h2><a class="header" href="#使用场景" id="使用场景">使用场景</a></h2>
<p>传统命令行程序 - Rust 编译器可以直接生成目标可执行程序，不需要任何解释程序。</p>
<p>Web 应用 - Rust 可以被编译成 WebAssembly，WebAssembly 是一种 JavaScript 的高效替代品。</p>
<p>网络服务器 - Rust 用极低的资源消耗做到安全高效，且具备很强的大规模并发处理能力，十分适合开发普通或极端的服务器程序。</p>
<p>嵌入式设备 - Rust 同时具有JavaScript 一般的高效开发语法和 C 语言的执行效率，支持底层平台的开发。</p>
<p>综上, 是 cpp 的有力竞争者</p>
<h2><a class="header" href="#特性" id="特性">特性</a></h2>
<ul>
<li>
<p>Rust 是基于 LLVM 的语言</p>
</li>
<li>
<p>所有权系统几乎解决了野指针, 强大的类型系统</p>
</li>
<li>
<p>zero cost abstract (编译期间即可编译成机器码, 运行时没有开销), 没有 runtime 和 gc, 和 c 无缝交互</p>
</li>
<li>
<p>自带测试, cargo 工具</p>
</li>
</ul>
<p>https://opensource.com/article/20/5/rust-java 为什么java -&gt; rust</p>
<h2><a class="header" href="#语义-概念" id="语义-概念">语义 概念</a></h2>
<ol>
<li>范式: 面向对象 , 函数式</li>
<li>语义: 所有权, move, copy, 借用, lifecycle, drop</li>
<li>类型系统: 泛型, trait, 多态, 类型推断</li>
<li>内存管理: heap, stack, raii</li>
</ol>
<p>1, 2, 3 点涉及到开发者的操作, 2,3,4 编译器操作</p>
<h1><a class="header" href="#开发环境配置" id="开发环境配置">开发环境配置</a></h1>
<h2><a class="header" href="#install" id="install">install</a></h2>
<p>git 环境支持</p>
<p>https://www.rust-lang.org/tools/install</p>
<p>会自动安装 cargo</p>
<p>安装完成后退出再次进入 terminal, rustc 等命令自动加入 path 了</p>
<p>给nightly通道用户的小提示：在更新rust之后使用cargo-sweep来帮助你清理垃圾
对于nightly通道的用户来说，通常在使用过程中会伴随着频繁的升级你的rust版本，而对于日常维护的项目，如果你升级了rust版本之后，target编译文件夹里面会生成多个版本的编译文件。这个时候就是使用cargo sweep的时候了，它会帮你清理掉除了当前版本以外的target目录下多余的文件。</p>
<p>用例： cargo sweep -i -r -v ~/src</p>
<p>-i 是开启保留~/src目录下target文件夹内当前电脑上已安装rust版本的编译文件。
-r 是开启递归（recursively）搜索
-v 是开启详细（啰嗦模式，开启之后会告诉你它干了啥。）
如果你的电脑上没有cargo sweep，可以用以下命令安装： cargo install cargo-sweep</p>
<p>Read More: https://www.reddit.com/r/rust/comments/jfdiao/tip_for_nightly_users_use_cargosweep_after/</p>
<h2><a class="header" href="#命令行工具使用" id="命令行工具使用">命令行工具使用</a></h2>
<pre><code class="language-sh">rustc --version
# 编译单个文件, 生成 xxx 可执行文件
rustc &lt;xxx.rs&gt;
# 编译 运行 dry.rs 下的 test mod, 无需 main函数
rustc --test dry.rs &amp;&amp; ./dry


# 管理 rust 版本, 

rustup update

# rust 有 stable (默认)、nightly 版本之分
rustup install nightly

# 当前项目下生效
rustup override set nightly
rustup override set stable

# 设置默认值, 对全局所有项目生效
rustup default stable
rustup default nightly
</code></pre>
<h2><a class="header" href="#ide" id="ide">IDE</a></h2>
<ol>
<li>
<p>VSCode + rust 插件 + native debug 插件 + TabNine 提示插件 + better toml plugin [ + crates 方便包管理的插件]</p>
</li>
<li>
<p>vscode + rust-analyzer plugin + CodeLLDB plugin (debug) + even better toml plugin (better toml) 格式化 toml [+ crates]</p>
</li>
<li>
<p>clion/idea + rust 插件 + toml 插件 + NativeDebug插件</p>
</li>
</ol>
<p>其他代码提示配置: (推荐 vscode + 插件, 就无需如下的配置了)</p>
<pre><code class="language-sh"># https://www.jianshu.com/p/c952db541d79
# 代码提示
cargo install racer
# 如果不成功, 升级到 nightly
rustup install nightly
# 如果报错，则需要切换到nightly版本的编译器
# 然后再次 安装 racer
rustup default nightly

# 或者 直接
cargo +nightly install racer

# 代码分析
rustup component add clippy

</code></pre>
<h2><a class="header" href="#配置国内镜像" id="配置国内镜像">配置国内镜像</a></h2>
<p>https://www.cnblogs.com/dhcn/p/12100675.html</p>
<pre><code class="language-t">[registry]
token = &quot;xxx crate.io token&quot; # 注册账号后由网站颁发, 用于发布包
# 放到 `$HOME/.cargo/config` 文件中
[source.crates-io]
registry = &quot;https://github.com/rust-lang/crates.io-index&quot;

# 替换成你偏好的镜像源
replace-with = 'rustcc'
#replace-with = 'ustc'

# 清华大学
[source.tuna]
registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;

# 中国科学技术大学
[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;

# 上海交通大学
[source.sjtu]
registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;

# rustcc社区
[source.rustcc]
registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;

# 命令别名
[alias]
b = &quot;build&quot;
t = &quot;test&quot;
r = &quot;run&quot;
rr = &quot;run --release&quot;
ben = &quot;bench&quot;
space_example = [&quot;run&quot;, &quot;--release&quot;, &quot;--&quot;, &quot;\&quot;command list\&quot;&quot;]
</code></pre>
<h1><a class="header" href="#标准库" id="标准库">标准库</a></h1>
<h2><a class="header" href="#path-路径" id="path-路径">path 路径</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// 路径
/// 
/// Path 可从 OsStr 类型创建
/// 
/// Path 分为两种：posix::Path，针对 类 UNIX 系统；以及 windows::Path，针对 Windows。
/// prelude 会选择并输出符合平台类型 的 Path 种类。(prelude 是 Rust 自动地在每个程序中导入的一些通用的东西)
/// 
/// Path 在内部并不是用 UTF-8 字符串表示的，而是存储为若干字节（Vec&lt;u8&gt;）的 vector。
/// 因此，将 Path 转化成 &amp;str 并非零开销的（free），且可能失败（因此它 返回一个 Option）
/// 
fn path_demo() {
    println!(&quot;-------------path_demo-------------&quot;);
    use std::path::Path;

    let path = Path::new(&quot;.&quot;);


    // 路径是否存在
    Path::new(&quot;/etc/hosts&quot;).exists()
    // 或者
    fs::metadata(path).is_ok()

    
    // `display` 方法返回一个可显示（showable）的结构体
    let display = path.display();
    println!(&quot;path = {}&quot;, display);

    // `join` 使用操作系统特定的分隔符来合并路径到一个字节容器，并返回新的路径
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // 将路径转换成一个字符串切片
    match new_path.to_str() {
        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),
        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),
    }


}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#时间" id="时间">时间</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>fn time_demo() {
    let start = SystemTime::now();
    for _ in 0..10000000 {
        let _a = &quot;hello&quot;.to_string();
    }
    println!(&quot;{} ms&quot;, SystemTime::now().duration_since(start).unwrap().as_millis());
}



<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#2015-对比-2018" id="2015-对比-2018">2015 对比 2018</a></h1>
<h2><a class="header" href="#nll" id="nll">nll</a></h2>
<pre><pre class="playpen"><code class="language-rust">// nll 特性
// 2015 edition 的周期检查会认为 变量有效直到作用域结束
// 2018 edition 会分析代码, 确认变量后面不会用到, 则提前销毁变量
{
    let mut x = 2;
    let y = &amp;mut x;
    *y += 1; // 2018 edition 在这一步后, 销毁 y
    println!(&quot;{}&quot;, x); // 2015 到这一步才销毁 y
}




// 非词法作用域生命周期 (Non-Lexical Lifetime, NLL
fn foo&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() % 2 == 0 {
        x
    } else {
        y
    }
}
fn main(){
    let x = String::from(&quot;hello&quot;);
    //2015 中 error, 2018 引入了 nll, 不报错
    let z;
    let y = String::from(&quot;world&quot;);
    z = foo(&amp;x, &amp;y); // 2015 认为到这里 y 已经失效了, 所以报错, 实际这不符合直觉
    println!(&quot;{:?}&quot;, z);
}

// nll 无法解决的问题
fn get_default&lt;'r,K:Hash+Eq+Copy,V:Default&gt;(map: &amp;'r mut HashMap&lt;K,V&gt;,
                                            key: K)
                                            -&gt; &amp;'r mut V {
    match map.get_mut(&amp;key) { // -------------+ 'r
        Some(value) =&gt; value,              // |
        None =&gt; {                          // |
            map.insert(key, V::default()); // |
            //  ^~~~~~ ERROR               // |
            map.get_mut(&amp;key).unwrap()     // |
        }                                  // |
    }                                      // |
}  
// 修正如下:
fn get_default2&lt;'r,K:Hash+Eq+Copy,V:Default&gt;(map: &amp;'r mut HashMap&lt;K,V&gt;,
                                             key: K)
                                             -&gt; &amp;'r mut V {
    if map.contains_key(&amp;key) {
    // ^~~~~~~~~~~~~~~~~~ 'n
        return match map.get_mut(&amp;key) { // + 'r
            Some(value) =&gt; value,        // |
            None =&gt; unreachable!()       // |
        };                               // v
    }

    // At this point, `map.get_mut` was never
    // called! (As opposed to having been called,
    // but its result no longer being in use.)
    map.insert(key, V::default()); // OK now.
    map.get_mut(&amp;key).unwrap()
}



</code></pre></pre>
<h2><a class="header" href="#raw-identifier" id="raw-identifier">Raw identifier</a></h2>
<pre><code class="language-rs">// 利用 Raw identifier 将语言关键字用作函数名 (一般用于 FFI 中，用于避免 C 函数名和 Rust 的关键字或保留字重名)
fn r#match(needle : &amp;str , haystack : &amp;str) - &gt; bool
</code></pre>
<h2><a class="header" href="#简化模式匹配" id="简化模式匹配">简化模式匹配</a></h2>
<pre><code class="language-rs">
// match 模式匹配

fn main() {
    let o = &amp;Some(&quot;h&quot;.to_owned());
    // 2015
    //  ref也是一种模式匹配，是为了 解构 &amp;Some(ref s)中 s 的引用，避免其中的 s 被转移所有权 。
    match o {
        &amp;Some(ref v) =&gt; println!(&quot;{}&quot;, v),
        _ =&gt; (),
    }
    // 2018
    //不 需要再使用引用操作符和 ref来进行解构了。在新的版本中 ， match 匹配会自动处理这种情况
    match o {
        Some(v) =&gt; println!(&quot;{}&quot;, v),
        _ =&gt; (),
    }

    
}

</code></pre>
<h2><a class="header" href="#main-函数可以返回-result" id="main-函数可以返回-result">main 函数可以返回 Result</a></h2>
<pre><code class="language-rs">

// 在 Rust 2015版本中， main 函数并不能返回 Result&lt;T E&gt;。但是在实际开发中， 二进制 可执行库也需要返回错误， 比如， 读取文件的时候发生了错误， 这时需要正常退出程序。于 是在 Rust 2018 版本中，允许 main 函数返回 Result&lt;T, E&gt;了

</code></pre>
<h2><a class="header" href="#impl-trait-抽象类型" id="impl-trait-抽象类型">impl trait 抽象类型</a></h2>
<pre><code class="language-rs">

// 可 以静态分发的抽象类型 impl Trait





</code></pre>
<h1><a class="header" href="#语法" id="语法">语法</a></h1>
<h2><a class="header" href="#注释" id="注释">注释</a></h2>
<pre><pre class="playpen"><code class="language-rust">//! Hello Demo
//!   包注释
//! crate spec...

use std::io::Read;
use std::io;
use std::fmt;
use std::io::{stdout, BufWriter}; 
use std::fs::File;


///
///
/// main 方法的注释
///
/// ```
/// 支持 md
/// ```
fn main() {
    println!(&quot;Hello, world!&quot;);

}



</code></pre></pre>
<h2><a class="header" href="#变量赋值" id="变量赋值">变量赋值</a></h2>
<h3><a class="header" href="#默认是不可变的" id="默认是不可变的">默认是不可变的</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>fn variables() {
    let a = 12;

    // 二次赋值不行
    // 也就是说 a 是不可变变量
    // a = 10;

    // 但是能二次绑定, 重影/遮蔽（Shadowing）
    // 这里的 a 和之前的 a 没关系, 甚至类型都能改变
    let a = 11;
    println!(&quot;a = {}&quot;, a);
    let a = &quot;new a&quot;;
    println!(&quot;a = {}&quot;, a);

    // 可变变量
    // 能够被二次赋值
    let mut b = 10;
    b = 33;
    println!(&quot;b = {}&quot;, b);
    // 这是不行的, 因为 b 已经被使用过了
    // b = &quot;bb&quot;;

    // 手动指定类型, 无符号 64 位整型变量
    // 如果没有声明类型，i 将自动被判断为有符号 32 位整型变量
    let i: u64 = 12;

    

}


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#字面量" id="字面量">字面量</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 字面量
    //
    // 带后缀的字面量，其类型在初始化时已经知道了。
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;
    let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#基本数据类型" id="基本数据类型">基本数据类型</a></h2>
<h3><a class="header" href="#值类型-and-引用类型" id="值类型-and-引用类型">值类型 and 引用类型</a></h3>
<p>值类型是指数据直接存储在栈中的数据类型 ，一些原生类型，比如数值 、布尔值、结构体, 枚举等都是值类型。因此对值类型的操作效率一般比较高，使用完立即会被回收, 这些基本类型实现了 Copy trait, 赋值语句中会执行拷贝</p>
<p>引用类型将数据存储在堆中，而栈中只存放指向堆中数据的地址, 如数组, 字符串; 因此对引用类型的操作效率一般比较低</p>
<h3><a class="header" href="#常量-静态变量" id="常量-静态变量">常量 静态变量</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>// 常量, 静态变量, 在全局声明常量 or 变量
    // 需要手动指定类型
    // 区别/异同:
    // - 都是在编译期求值的，所以不能用于存储需要动态分配内存的类型，比如 HashMap, vec
    // 
    // - 静态变量有固定的内存地址 (分配在静态存储区), 可以是可变的 (用 mut 修饰), 修改需要在 unsafe 中; 
    // - 常量没有固定的内存地址, 不可变 (可以被内联, 在被用到的地方会被复制过去, 用不到内存地址)

    // 普通常量 不能引用 静态变量
    // 在存储的数据比较大、需要引用地址或具有可变性的情况下使用静态变量;否则，应该 优先使用普通常量
    const MAX_POINTS: u32 = 100_000;
    static LANGUAGE: &amp;'static str = &quot;Rust&quot;;//&quot;string&quot; 字面量默认生命周期就是 static 的
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#数字" id="数字">数字</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// 对于 基本数据类型, 数据的克隆, 移动都是在栈上, 无需存储到堆中
fn basic_types() {
    // 整型

    // 占据 8 bit
    const A: i8 = -2; // 有符号
    const B: u8 = 2; // 无符号
                     // const b: u8 = -2; // 错误

    // 占据 16 bit
    // i16 u16

    // 占据 32 bit
    // i32 u32

    // 64 bit
    // i64 u64

    // 128
    // i128 u128

    // arch 类型
    // isize	usize
    //长度取决于所运行的目标平台，如果是 32 位架构的处理器将使用 32 位位长度整型。

    const C: i16 = 10_000; // 10进制
    const D: i16 = 0xff; // 16进制
    const E: i16 = 0o77; // 8 进制
    const F: i16 = 0b1111_0000; // 二进制
    

    // 浮点数
    let x = 2.0; // 默认 f64
    let y: f32 = 3.0; // f32



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#布尔值-字符-字节" id="布尔值-字符-字节">布尔值 字符 字节</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>


<span class="boring">fn main() {
</span>    // 布尔值, 类型 bool
    let is_a = true;

    // 字符, 单引号
    //4 个字节, 支持中文
    const CC: char = 'c';
    let heart_eyed_cat = '😻';


    // 字节字面量, 如 b'*' 表示 42u8
    const G: u8 = b'A'; // 字节, 只能 u8 类型
    const n: u8 = b'\n';

    std::mem:size_of&lt;&amp;[u32; 5]&gt;() //函数可以返回类型的字节数
    // &amp;[u32;5]类型为普通指针，占8个字节:&amp;mut[u32]类型为胖指针，占16 个字节。 可见， 整整多出了一倍的占用空间，这也是称其为胖指针的原因
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#数组" id="数组">数组</a></h3>
<pre><pre class="playpen"><code class="language-rust">
// 对于原始固定长度数组，只有实现 Copy trait 的类型才能作为其元素 ，也就是说，只有 可以在栈上存放的元素才可以存放在该类型的数组中
    // 可以自动推断类型

    let a = [1, 2, 3, 4, 5];
    // a 是一个长度为 5 的整型数组

    let b = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;];
    // b 是一个长度为 3 的字符串数组


    // 明确指定类型, 数组类型可以通过 [T, N] 明确指定, T 为元素类型, N 为 个数; 如 [u8; 4] 这是静态类型 (因为已知大小了)
    // [u8] 只能是动态大小类型, for don't know the size 
    let c: [i32; 5] = [1, 2, 3, 4, 5];
    // c 是一个长度为 5 的 i32 数组

    let d = [3; 5];// 使用默认类型 i32, 元素都为 3, 个数为 5 个
    // 等同于 let d = [3, 3, 3, 3, 3];

    let d = [3u8; 5];// 指定类型

    // 数组访问
    let first = a[0];
    let second = a[1];

    a[0] = 123; // 错误：数组 a 不可变
    
    let mut a = [1, 2, 3];
    a[0] = 4; // 正确
    
    // 数组遍历
    for ele in a.iter() {
        println!(&quot;{}&quot;, ele);
    }

    // 
    // 连接两个 array 可以使用 join


    // 编译时函数执行, 简称 cfe
    //函数会在编译期被执行, 计算出常量结果
    const fn const_fn() -&gt; u8 {2};
    let arr = [0u8, const_fn()];


    // match 语法
    // 通过匹配数组的不同元 可以实现指定的功能 。
    // 挑选出以 3 结尾和第 二个元素为 2 的数组。
    fn pick(arr: [i32; 3])  {// 这个有限制, 参数数组的元素个数不可变, 必须为 3
        match arr {
            [_, _, 3] =&gt; println!(&quot;ends with 3&quot;),
            [a, 2, c] =&gt; println!(&quot;{:?}, 2, {:?}&quot;, a,  c),
        //  match匹配的最后一个分支，必须使用通配符或其他变量来穷尽枚举
            [_, _, _] =&gt; println!(&quot;pass!&quot;),
        }
    }
    // 变长参数
    // 利用数组切 片就可以模拟变长参数的函数
    fn sum(num: &amp;[i32]) { // 原素个数可变
        match num {
            [one] =&gt; println!(&quot; at least two&quot;),
            [first, second] =&gt; println!(&quot;{:?} + {:?} = {:?} &quot;, first, second, first+second),
            _ =&gt; println!(&quot;sum is {:?}&quot;, num.iter().fold(0, |sum, i| sum + i) ),
        }
    }
    fn main() {
        sum(&amp;[1]);
        sum(&amp;[1, 2]);
        sum(&amp;[1, 2, 3]);
        sum(&amp;[1, 2, 3, 5]);
    }


    // 二分查找
    // 根据元素查找索引
    if let Ok(9) = arr.binary_search(&amp;13) {}
    // 等价
    arr.binary_search_by(|x| x.cmp(&amp;13))
    // binary search by_key


    let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
    assert_eq!(s.binary_search(&amp;13),  Ok(9));
    assert_eq!(s.binary_search(&amp;4),   Err(7));
    let r = s.binary_search(&amp;1);
    assert!(match r { Ok(1...4) =&gt; true, _ =&gt; false, });
    let seek = 13;
    assert_eq!(
        s.binary_search_by(|probe| probe.cmp(&amp;seek)),
       Ok(9)
   );
   let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),
              (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),
              (1, 21), (2, 34), (4, 55)];
   assert_eq!(
       s.binary_search_by_key(&amp;13, |&amp;(a,b)| b),
       Ok(9)
   );
    

</code></pre></pre>
<h3><a class="header" href="#range-范围" id="range-范围">Range 范围</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>(1..5) &lt;=&gt; std::ops::Range {start: 1, end: 5}
(1..=5) &lt;=&gt; std::ops::RangeInclusive::new(1, 5)
(3, 6).sum()
for i in 0..4 {
    
}
for i in 0..=4) {
    
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#切片" id="切片">切片</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>///切片
///
/// 切片是对原始数据集合的部分引用, 没有原始 数据集合 的所有权 (原始数据集合可能是 数组, Vec);无法修改原始值
///
/// 若原始值 为 T, 则 切片类型为  &amp;[T] or &amp;mut[T]
/// 
/// ..y 等价于 0..y
/// x.. 等价于位置 x 到数据结束
/// .. 等价于位置 0 到结束
/// 
/// 
/// 
fn slice_vec() {
    let s = String::from(&quot;broadcast&quot;);
    let part1 = &amp;s[0..5];// 截取子串, 字符串切片就是 &amp;str 类型
    let part2 = &amp;s[5..9];
    println!(&quot;{}={}+{}&quot;, s, part1, part2);

    // 被切片引用的字符串禁止更改原始值
    let mut s = String::from(&quot;xxxxxx&quot;);
    let slice = &amp;s[0..3];
    s.push_str(&quot;yes!&quot;); // 错误

    //数组切片
    let arr = [1, 3, 5, 7, 9];
    let part = &amp;arr[0..3];
    for i in part.iter() {
        println!(&quot;{}&quot;, i);//1, 3, 5
    }

    // 两个 const fn 方法: len(), is_empty()

    // 通过 &amp;mut 定义可变切片
    let arr = &amp;mut [1,2,3];
    arr[1] = 0;

    // 动态数组转切片
    let arr = &amp;vec![1,2,3][..];
    
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#str-字符串切片" id="str-字符串切片">str 字符串切片</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 典型的动态大小类型 (DST), 编译期不可知大小, 分配在堆上
//所以编译器要求必须以不可变借用的形式在代码中存在 即 &amp;str, 大小确定(一个指针+长度), &amp;str 存储在栈上
// 
// 字符串字面量是特殊的 str, 特殊在其具有静态生命周期, 必须以类型  &amp;'static  str 接收
//
//fat pointer(胖指针): 包含 DST 的地址信息 和 长度的指针

let ss = &quot;hello world&quot;;
let ptr = ss.as_ptr();
let s = unsafe {
    let slice = std::slice::from_raw_parts(ptr, ss.len());
    std::str::from_utf8(slice).unwrap()
};
if ss == s {
    println!(&quot;equal&quot;);//equal
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#原生指针-row-pointer" id="原生指针-row-pointer">原生指针 row pointer</a></h3>
<p>分为 不可变 row pointer 和 可变 row pointer</p>
<pre><code class="language-rs">#![feature(never_type)]

let mut a = 10;
let a_ptr = &amp;mut a as *mut i32;
let b = Box::new(20);
let b_ptr = &amp;*b as *const i32;
unsafe { 
    *a_ptr += *b_ptr;
}
println!(&quot;{:?}&quot;, a);//30
</code></pre>
<h3><a class="header" href="#never-类型-感叹号" id="never-类型-感叹号">never 类型 感叹号</a></h3>
<pre><code class="language-rs">// 底类型 botto type
// BangType
// 
// Rust 中有很多种情况确 实没有值，但为了类型安全，必须把这些情况纳入类型系统进行统一 处理
// 
// 发散函数 (Diverging Function ): 永远不会有返回值的函数, 如 panic! 或者 std::process: :exit ...
// continue 和 break 关键字
//loop循环
// 空枚举，比如 enumVoid{}

# ! [feature (never_type)]// 需要支持
fn foo() -&gt; i32 {
    // !表示永远不会有返回值的类型
    let x: ! = {
        return 11;// 直接函数退出了, 所以 x 永远不会有返回值
    };

    // panic 宏在 match 分支中使用时, 即使没有返回和其他分支相同的类型, 也没报错, 为什么?
    // 因为返回 了 ! 类型, (never 类型可以转为任何类型)

    // 空枚举的用法场景:
    enum Void {}
    let res: Result&lt;i32, Void&gt; = Ok(11);
    let Ok(num) = res;//当然这里也可以用 if let 语句处理
}
</code></pre>
<h2><a class="header" href="#字符串" id="字符串">字符串</a></h2>
<h3><a class="header" href="#几种字符串区别" id="几种字符串区别">几种字符串区别</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// 字符串
///
/// - str 表示固定长度的字符串, 属 于动态大 小 类型 (DST)，保证 有效 UTF-8 , 在编译期并不能确定其大小，所以在程序中最常见到的是 str 的切片 (Slice)类型 &amp;str。  
//      &amp;str 表示字符串字面量, 是引用类型; 字符串切片就是 &amp;str, 和程序代码段存储在一起(在编译期间地址就知道了), 执行的是复制语义
///
/// - String 类型, 长度可变, 可修改, 存储为由字节组成的 vector（Vec&lt;u8&gt;），但保证了它一定是一个有效的 UTF-8 序列, 字符序列分配在堆, 执行的是移动语义
///
///     String 有一个字符开始位置属性 ptr, 和一个字符串长度属性 len, 和堆分配的容量 capacity, 这些属性位于 栈, 实际字符序列存在 堆
///     str    有  ptr 和 len, 属性, 内容都在 栈
// 
// - CStr， 表示由C分配而被Rust借用的字符串， 一般用于和C语言交互。
// - CString， 表示由 Rust 分配且可以传递给 C 函数使用的 C 字符串 ，同样用 于和 C 语言交互。
// 
// - OsStr， 表示和操作系统相关的字符串。这是为了兼容 Windows系统。
// - OsString，表示 OsStr 的可变版本 。与 Rust 字符串可以相互转换
// - Path，表示路径，定义于 std::path模块中。 Path包装了 OsS衍
// - PathBuf. ft~ Path 配对， 是 Path 的可变版本 。 PathBuf包装了 OsString。
///
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#常用方法" id="常用方法">常用方法</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn str_string() {

    
// 字符串转义
    // 长字符串
    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and \' indentation here 
                        can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);

    
    let str_value: &amp;'static str = &quot;1234&quot;;// 字符串切片
    //简单写法为
    let str_value = &quot;1234&quot;;

    let s = string::new() // 此时还并未在堆上分配空间
    let str1 = String::from(&quot;hello&quot;);
    // 指定堆容量
    let s =  String : :with_capacity (20)
    // 再次分配容量
    s.reserve(lO)
    
    let one = 1.to_string();         // 整数到字符串
    let float = 1.3.to_string();     // 浮点数到字符串
    let slice = &quot;slice&quot;.to_string(); // 字符串切片到字符串
    
    

    // 新增 添加
    //定义一个可变字符串，并对其进行修改
    let mut string_value: String = &quot;1111&quot;.to_string();
    // 或者
    // let string_value = String::from(&quot;222&quot;);
    string_value.push_str(&quot;333&quot;);// 添加字符串切片
    string_value.push('!'); // 添加字符

    // 插入
    s.insert(0, 'f’)
    s. insert_str(O,”bar”)

    // 连接
    // String 类型的字符串也实现了 Add&lt;&amp;str&gt; 和 AddAssign&lt;&amp;str&gt;两个 trait，这意味着可以使用“+”和“+=”操作符来连接字符串
    // 操作符 右边的字符串必须为切片类型 (&amp;str)



    // 替换
    //
    string.replace(&quot;old_str&quot;, &quot;new str&quot;);

    
    // 删除
    s .remove (3) //指定位置
    s.pop()//最后一个字符, 并且返回
    s. truncate (3)//指定位置到末尾删除
    s .clear( );//清空
    s .drain (..beta_offset) .collect()// 截取源的指定范围并返回, 源会改变, 只留下剩下的部分
    s.drain(..)// 等价 clear, 截取源的全部, 源变空


    // 查找
    // 标准库中并没有提供正则表达式支持，这是因为正则表达式算是外部DSL， 如果 直接将其引入标准库中，则会破坏 Rust的一致性
    // 第三方包 regex
    // Rust 中这里使用 的字符匹配算 法并非 KMP，而是它的变种双向( Two-Way)字符串匹配算法 ，该算法的优势在于拥有常量级的空间复杂度。它和 KMP 的共同点在于其时间复杂度也是 O(n)
    // 
    // 存在性判断。 相关方法包括contains (支持 字符/字符串/谓词)、 starts_with (支持字符/字符串)、 ends_with
    // 位置匹配 。相关方法包括 find、 rfind (从右边开始搜索, 支持谓词)。
    // 分割字符串 。相关方法包括 split、rsplit、split_terminator(去掉数组last元素的多余)、rsplit_terminator、splitn (指定分割后的数组长度)、rsplitn。 
    // 捕获匹配, 返回数组。 相关方法包括 matchs、 rmatches、 match_indices (返回的是元组数组, 包含了索引)、 rmatch_indices。 
    // 删除匹配。 相关方法包括 trim(删除两头空格, 不能指定 pattern 参数), trim_left, trim_right , trim_matches(可指定 pattern 参数)、trim_left_matches、trim_right_matches。 
    // 替代匹配。 相关方法包括 replace、 replacen(指定替换字符的个数)
    





    // 统计长度
    // 字符 字节
    //
    let s = &quot;hello&quot;;
    //字节
    let len = s.len();// 5, 字节数, 每个英文字符占位1字节
    let s = &quot;你好&quot;;
    let len = s.len();//6, 因为中文是 UTF-8 编码的，每个字符长 3 字节
    let s = &quot;hello你好&quot;;
    let len = s.bytes().count();//提供了 bytes 和 chars 两个方法来分别返回按字节 和按字符迭代的法代器
    //字符
    let len = s.chars().count();// 7, 统计字符数 (统计字符的速度比统计数据长度的速度慢得多)
    //遍历字符
    for c in s.chars() {
        print!(&quot;{} &quot;, c);
    }
    // or
    let s: String = s.chars() .enumerate() .map(| (i, c) | {}).collect()

    // 按索引访问字符
    let mut result = s.into_bytes();//通过 into_bytes方法将字符串转换为 Vec&lt;u8&gt;序列
    (0..result.len()).for_each ...
    let new_s = String: :from_utf8(result).unwrap()
    

    // 获取单个字符
    let s = String::from(&quot;EN中文&quot;);
    let a = s.chars().nth(2); //nth 函数是从迭代器中取出某值的方法，不要在遍历中这样使用！因为 UTF-8 每个字符的长度不一定相等
    println!(&quot;{:?}&quot;, a);//Some('中')

    
    // 指定索引范围来获取字符串切片
    let v =  String::from(&quot;hello&quot;);
    let s: Some&lt;&amp;str&gt; = v.get(0..1);
    v.get_mut((xxx))
    assert ! (!v .is_char boundary(4)) ;//验证某个索引位置是否为合法的边界, 因为可能某个字符占据了多个索引位置(string的方法默认都是按照字节来处理的, 也就是一个索引位置对应一个字节, 某些字符英文字符外的字符可能不止一个字节)









    // 分割
    let bool_s = s.is_char_boundary(12)
    s.split_at(12)// 需要先检查索引是否是合法字符边界


    // 空格分割, 逆序
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    
    // 字符串分割成字符，排序并移除重复值
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup(); //去重


    

    // trim 首尾去除
    //
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    // 去除 string 首尾的字符, 这些字符在 chars_to_trim 中指定
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);







    // 获取字节 遍历字节
    // as_bytes()
    //
    fn first_word(s: &amp;String) -&gt; usize {
        // 字节数组, 一个英文字符占一个字节
        let bytes = s.as_bytes();
        for (i, &amp;item) in bytes.iter().enumerate() {
            if item == b' ' {// 如果是空格
                return i;
            }
        }
        s.len()
    }
    first_word(&amp;&quot;hello world&quot;.to_owned());// 5

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#字符串转换" id="字符串转换">字符串转换</a></h3>
<pre><code class="language-rs"> //
    //
    // 复杂类型的类型转换 相互转换 互转
    //
    // String =&gt; &amp;str
    let s1 = String::from(&quot;hello&quot;);
    // 方法1
    let s2 = &amp;s1[..]; 
    let ssss = &amp;s1[..2];// 截取子串
    // 方法2
    let sss: &amp;str = &amp;s1.as_str();
    //
    // 方法3
    let new_str = &amp;*s1;
    //
    //
    // &amp;str -&gt; String
    let new_string = new_str.to_string();//to_string底层调用的String::from
    let new_string1 = s2.to_string();
    println!(&quot;new_string = {}, new_string1 = {}&quot;, new_string, new_string1);
    // &amp;str -&gt; String
    let string = &quot;hello&quot;.to_owned(); //最常用, 吧 &quot;hello&quot;从栈转移到堆, to_owned 方法利用 &amp;str 切片字节序列生成新的 String字符串 ， to_string方法是对 String::from 的包装, 两者性能相当

    // &amp;str -&gt; String
    let _s: String = &quot;hello&quot;.into();



    // string -&gt; T
    // std::str模块中提供的 parse泛型方法来将字符串转换为指定的类型
    // 底层是 FromStr::from_str

    //T -&gt; string
    // format!()
    let s = format!(&quot;{}&quot;, xxx); 
</code></pre>
<h3><a class="header" href="#格式化" id="格式化">格式化</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>    // 拼接
    //
    let str1 = String::from(&quot;hello&quot;);
    let str2 = String::from(&quot;world&quot;);
    let str3 = str1 + &quot;-&quot; + &amp;str2;
    // or
    format!(&quot;{} - {}&quot;, str3, str2);



    //
    // 格式化输出
    // 由一些宏(macro)负责输出，这些宏定义在std::fmt中
    //
    // 原理是: 必须实现 std::fmt::Display 这个trait提供的 fmt 方法
    //
    // format!()：向字符串中输出格式化字符串。
    // print()!：向标准输出打印字符串。
    // println()!：向标准输出打印字符串，同时会打印一个换行符。
    // eprint()!：向标准错误打印字符串。
    // eprintln()!：向标准错误打印字符串，同时也会打印一个换行符


    // 占位符 
    // {} -&gt; Display
    // {:?} -&gt; Debug
    // {:#?} -&gt; 格式化的 Debug
    // {:o} -&gt; 八进制
    // {:x} -&gt; 十六进制小写
    // {:X}   十六进制大写
    // {:p}   指针地址
    // {:b}   二进制
    // {:e}   数字格式, 指数小写
    // {:E}   指数大写




    println!(&quot;hello {}&quot;, &quot;world&quot;);
    println!(&quot;{0} {1}&quot;, &quot;hello&quot;, &quot;world&quot;);
    println!(&quot;{h} {w}&quot;, h = &quot;hello&quot;, w = &quot;world&quot;);
    // 以二进制的格式打印数字
    println!(
        &quot;{} of {:b} people know binary, the other half doesn't&quot;,
        1, 2
    );
    // 右对齐宽度为6
    println!(&quot;{number:&gt;width$}&quot;, number = 1, width = 6);// '.....1'
    // 使用字符0填充对齐的字符串
    println!(&quot;{number:&gt;0width$}&quot;, number = 1, width = 6);// '000001'

    let s = format!(&quot;hello {}&quot;, &quot;world&quot;);
    println!(&quot;{}&quot;, s);
    // 十六进制输出
    format!(&quot;0x{:X}&quot;, 100); //-&gt; &quot;0xDEADBEEF&quot;
                            // 八进制输出
    format!(&quot;0o{:o}&quot;, 100); //-&gt; &quot;0o33653337357&quot;


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#调试打印符合类型--debug-trait-display-trait" id="调试打印符合类型--debug-trait-display-trait">调试打印符合类型  Debug trait Display trait</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    //调试
    //
    // fmt::Debug 类似 Display 这个 trait, 但是能够由 rust 自动推导实现, 无需手动实现
    // 
    // fmt::Debug是Rust标准库已经定义好的，我们可以通过继承的方式，获得fmt::Debug的能力, 
    //即定义 struct 时 添加 #[derive(Debug)]
    //其他的还有 #[allow(dead_code)] 用于屏蔽对未使用代码的警告
    #[derive(Debug)] 
    struct DebugDemo(i32);
    let debug_demo = DebugDemo(11);
    println!(&quot;Debug - {:?}&quot;, debug_demo);
    println!(&quot;{0:?}&quot;, debug_demo);// 等效

    //
    // fmt::Display 自定义打印
    //是一个用于自定义格式化输出的接口
    //
    // 对于泛型容器, 如 Vec&lt;T&gt;, 需要自己实现fmt::Display, 或者直接 用fmt::Debug
    //
    struct DisplayDemo(i32);
    impl fmt::Display for DisplayDemo {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {

            write!(f, &quot;({})&quot;, self.0)
        }
    }
    let display_demo = DisplayDemo(11);
    println!(&quot;display - {}&quot;, display_demo);


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#问号操作符-多次写" id="问号操作符-多次写">问号操作符 多次写</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>    // &quot;?&quot; 问号操作符: 尝试解包, 返回值为 解包后的值, 有异常, 返回异常, 没有则继续后续代码
    //
    //考虑这种场景: 对一个结构体想实现 fmt::Display，但是其中的元素需要一个接一个地写出去，
    //问题在于每个 write! 都要生成一个 fmt::Result。
    //
    //解决: write!(f, &quot;{}&quot;, value)?;  多次写
    // 对 `write!` 进行尝试（try），观察是否出错。若发生错误，返回相应的错误。
    // 否则（没有出错）继续执行后面的语句。 同 try!(xxx)
    //
    //
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // 使用元组的下标获取值，并创建一个 `vec` 的引用。
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;//多次写

         // 遍历下标
        for (count, v) in vec.iter().enumerate() {
            // 对每个元素（第一个元素除外）加上逗号。
            // 使用 `?` 或 `try!` 来返回错误。
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // 加上配对中括号，并返回一个 fmt::Result 值。
        write!(f, &quot;]&quot;)
    }

}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#集合" id="集合">集合</a></h2>
<p>std::collections 下有四种集合</p>
<ul>
<li>线性序列: Vec(向量), VecDeque (双端队列), LinkedList (链表)</li>
<li>映射表: hashmap(无序哈希表), BTreeMap(有序哈希表)</li>
<li>集合: hashset(无序集合), btreeset(有序集合)</li>
<li>优先队列: binaryHeap (二叉堆)</li>
</ul>
<h3><a class="header" href="#vec-动态数组" id="vec-动态数组">Vec 动态数组</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// 向量 Vec
/// 动态数组, 类似 java中的 ArrayList
/// 
///Vector数组天生就可以作 为先进后出(FILO)的栈结构使用
/// 
//
    println!(&quot;Vector -------------------------------&quot;);
    //一个 vector 使用 3 个词来表示：一个指向数据的指针，vector 的长度，还有它的容量。此容量指明了要为这个 vector 保留多少内存。
    //vector 的长度 只要小于该容量，就可以随意增长；当需要超过这个阈值时，会给 vector 重新分配一段 更大的容量。
    // 
    // 扩容: 自动按照 2 倍扩容
    //
    let vec: Vec&lt;i32&gt; = Vec::new(); // 创建类型为 i32 的空向量
    // 预分配 10 个单位
    // 真正分配 的堆内存 大 小 等于数组中元素类型所占字节与给定容量值 之积
    Vee::with capacity(1O)
    let vector = vec![1, 2, 4, 8];     // 通过数组和宏创建向量 // v: Vec&lt;i32&gt;
    let v = vec![0; 10]; // ten zeroes
    let mut vec_fixed: Vec&lt;_&gt;= (0..10).collect();
    // 获取
    println!(&quot;{:?}, v[0] = {}&quot;, vec, vec[0]);//下标必须是 usize 类型

    // vec 转换 数组/切片
    let arr = vec[..];

     // 长度
     vec.len();

    // 添加, 删除
    // 类似 栈
    vec.push(6);//尾插
    vec.push(7);
    if let Some(x) = vec.pop() {// 尾部删除返回
        println!(&quot;popped: {}&quot;, x);// 7
    } else {
        println!(&quot;None&quot;);
    }
    println!(&quot;after pop: {:?}&quot;, vec); // [6]

    // 从 0 位置开始清除到末尾, 等同清空数据, 但是内存没有释放, 只是擦除了数据
    vec . truncate (0);
    // 清空
    vec.clear()
    // 释放空闲容量
    vec.shrink_to_fit() //方法，预分配的堆内存被释放了

    // 交换
    v.swap(1, 3);

    // 全部替换
    // copy_from_slice 方法可以使用一个数组切片将原 vec 数 组 中的元素全部替换, 数组切片必须和原数组等长, 只支持实现 Copy 语义的元素
    //  clone_from slice方法的效果和 copy_仕om slice是等价的， 但它们的区别是， clone from slice 方法支持实现 Clone 的类型元素。

    // 添加另外的 vector
    let mut v2 = vec![100, 101];
    vec.append(&amp;mut v2);
    println!(&quot;vec: {:?}&quot;, vec);
    println!(&quot;v2: {:?}&quot;, v2);//v2: []

    // 处理下标越界
    match vec.get(7) { // 返回的是 Option&lt;T&gt;
        Some(x) =&gt; println!(&quot;Item 7 is {}&quot;, x),
        None =&gt; println!(&quot;Sorry, this vector is too short.&quot;)
    }

    //  contains、 starts with和 ends with
    

    // 迭代
    // 迭代出的是元素引用
    for ele in &amp;vec {
        println!(&quot;不可变引用: {}&quot;, ele);
    }
    // 可变迭代
    for ele in &amp;mut vec {
        println!(&quot;可变引用: {}&quot;, ele);
        // 此时可以修改元素
        *ele *= 10;// 第一个* 表示根据地址取得值, 第二个*是运算符
    }
    // 带下标迭代
    for (i, v) in vec.iter().enumerate() {
        println!(&quot;{}: {}&quot;, i,v);
    }
    for ele in vec {
        println!(&quot;本体: {}&quot;, ele);
    }

    // 类型推断
    //
    // 因为有类型说明，编译器知道 `elem` 的类型是 u8。
    let elem = 5u8;
    // 创建一个空向量（vector，即不定长的，可以增长的数组）。
    let mut vec = Vec::new();

    vec.push(elem);
    // 啊哈 聪明！现在编译器知道 `vec` 是 u8 的向量了（`Vec&lt;u8&gt;`）。

    println!(&quot;{:?}&quot;, vec);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#双端队列-vecdeque" id="双端队列-vecdeque">双端队列 VecDeque</a></h3>
<pre><code class="language-rs">// 是一种 同时具有 队列(先进先出)和栈 (后进先出)性质的数据 结构 。 双端队列中的元素可 以从两端弹出，插入和删除操作被限定 在队列的两端进行
// 内部主要维护一个环形缓冲区 (RingBuffer), 由两个指针和 一 个可增长数组组成 。 这两个指针分别为 头指针( Head Pointer)和尾指针( Tail Pointer)。 其中头指针永远指向应该写入数据 的位置，而尾指针永 远指 向可以读取的第一个元素

// 缓冲区溢出
// 假设缓冲区数组初始大小为8, 环形 缓冲区为空 时，两个指针都指向位置 0。当有新元素 插入时，如果 直接插入位置 0，则将用于写入数据 的 Head 指针指向位置 1， 而用于读取数据的 Tail 指针依 旧指向位置 0
// 当插入第 8 个元素时， Head 和 Tail 指针将再次重叠, 
// 如果这时继续给缓冲区添加新元素 ， 那么位置 。 处的数据将被 其他数据覆盖，这就会造成缓冲区溢出攻击; 为了避免这种情况，需要空出一个位置， 不能插入元素 ， 这样才可以区分头和尾
// 要判断环形缓冲区是否为满状态，就必须看容量和大小的差是否为 l
</code></pre>
<h3><a class="header" href="#链表-linkedlist" id="链表-linkedlist">链表 Linkedlist</a></h3>
<p>因为是双向列表， 所以提供了 push back 和 push front 两类方法，方便操作 此链表。也提供了 append 方法 ， 可以用来连接两个链表</p>
<h3><a class="header" href="#hashmap--无序哈希表" id="hashmap--无序哈希表">hashmap  无序哈希表</a></h3>
<p>Key必须是可哈希的类型， Value必须是在编译期已知大小的类型</p>
<h4><a class="header" href="#哈希表基本使用" id="哈希表基本使用">哈希表基本使用</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>///HashMap 的键可以是布尔型、整型、字符串，或任意实现了 Eq 和 Hash trait 的其他类型
///HashMap 在占据了多余空间时还可以缩小 自己
/// 
/// 
/// 
fn hash_table() {
    use std::collections::HashMap;
    
    let mut map = HashMap::new();//不会预分配内 存。若始终不添加元素, 会编译报错, 编译器认为 map 没有初始化

    HashMap::with_capacity(unit) //创建具有一定初始容量的 HashMap
    
    // 从 vector 构造
    let keys = vec![&quot;a&quot;, &quot;b&quot;];
    let values = vec![0, 1];
    let m: HashMap&lt;_, _&gt; = keys.iter().zip(values.iter()).collect();

    // 插入
    // 如果被插入的值为新内容，那么 `HashMap::insert()` 返回 `None`，
    // 否则返回 `Some(被覆盖的 value)`
    map.insert(&quot;color&quot;, &quot;red&quot;);// 没有声明散列表的泛型，是因为 Rust 的自动判断类型机制。
    map.insert(&quot;size&quot;, &quot;10 m^2&quot;);

    //不存在才插入值 red, 并且返回该值的可变借用, (一般的插入则是有则覆盖旧的值)
    // or_insert_with(FnOnce) 传递一个可计算的闭包作为要插入的值, 闭包没有参数
    // key()
    map.entry(&quot;color&quot;).or_insert(&quot;red&quot;);// , 返回 &quot;red&quot; 的 &amp;mut T 

    //删除
    map.remove(&amp;(&quot;Ashley&quot;)); 


    // 获取
    //
    // 接受一个引用并返回 Option&lt;&amp;V&gt;
    let one = map.get(&amp;&quot;color&quot;);
    // or
    let one = map[&quot;color&quot;]
    println!(&quot;one is a Option&lt;&amp;V&gt; ,  {}&quot;, *(one.unwrap()));
    // 可变获取(修改) 
    let mut map = HashMap::new();
    map.insert(1, &quot;a&quot;);
    if let Some(x) = map.get_mut(&amp;1) {
        *x = &quot;b&quot;;
    }

    // 是否包含
    if !book_reviews.contains_key(&quot;rust book&quot;) {
        println!(&quot;find {} times &quot;, book_reviews.len());// 长度
    }
    

    // 迭代
    for p in map.iter() {//迭代元素是表示键值对的元组
        println!(&quot;{:?}&quot;, p);
    }
    for (k, v) in &amp;map {// 元素为 (&amp;'a key, &amp;'a value) 对
        println!(&quot;{}, {}&quot;, k, v);
    }

    // 通过keys和values方法可以分别单独获取HashMap中的键/值的迭代器
    for key in book_reviews.keys() {
        println!(&quot;{}&quot;, key);
    }
   for val in book_reviews.values() {
       println!(&quot;{}&quot;, val);
   }

    // 统计句子中的单词个数
    let text = &quot;aa bb cc bb&quot;;
    let mut counter = HashMap::new();
    for word in text.split_whitespace() {
        let count = counter.entry(word).or_insert(0);// 
        *count += 1;
    }
    for (word, count) in counter {
        println!(&quot;{}, {}&quot;, word, count);
    }



    // 合并多个 HashMap
    // 合并两个或多个 HashMap, 尽量使用 extend或其他迭代器适配器方式， 而不要用 for循环来插入 ,否则会带来性能 问题
    map1.extend(map2);//本质上， 在 extend方法内部也将 HashMap转换为法代器进行操作
    map1.into_iter().chain(map2).collect()//同样是通过 into_iter得到 Chain迭代器 然后操作
    // 被添加的 map_ref 是个引用, 原始 map 不会丢失所有权
    map1.extend(
        map_ref.into_iter()
            .map(|(k, v)| (k.clone(), v.clone()))
   );




<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#复合类型作为-key" id="复合类型作为-key">复合类型作为 key</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    // 基础类型的 浮点数, 无法作为 key

    // 复杂类型作为键 key, 必须实现 Hash和Eq trait
    //
    //f32 和 f64 没有实现 Hash，这很大程度上是由于若使用浮点数作为 散列表的键，浮点精度误差会很容易导致错误
    //
    //对于所有的集合类（collection class），如果它们包含的类型都分别实现了 Eq 和 Hash，
    //那么这些集合类也就实现了 Eq 和 Hash。例如，若 T 实现了 Hash，则 Vec&lt;T&gt; 也实现了 Hash
    //
    //自定义类型可以轻松地实现 Eq 和 Hash，只需加上一行代码：#[derive(PartialEq, Eq, Hash)]
    //
    // Eq 要求你对此类型推导 PartiaEq。
    #[derive(PartialEq, Eq, Hash)]
    struct Account&lt;'a&gt;{
        username: &amp;'a str,
        password: &amp;'a str,
    }
    struct AccountInfo&lt;'a&gt;{
        name: &amp;'a str,
        email: &amp;'a str,
    }
    type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;
    fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
            username: &amp;'a str, password: &amp;'a str){
        println!(&quot;Username: {}&quot;, username);
        println!(&quot;Password: {}&quot;, password);
        println!(&quot;Attempting logon...&quot;);

        let logon = Account {
            username: username,
            password: password,
        };

        match accounts.get(&amp;logon) {
            Some(account_info) =&gt; {
                println!(&quot;Successful logon!&quot;);
                println!(&quot;Name: {}&quot;, account_info.name);
                println!(&quot;Email: {}&quot;, account_info.email);
            },
            _ =&gt; println!(&quot;Login failed!&quot;),
        }
    }



    

}

<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#哈希碰撞攻击" id="哈希碰撞攻击">哈希碰撞攻击</a></h4>
<p>map 底层使用数组存储数据, 需要一个高效的 hash 函数均匀的将元素分散存储在 数组中 </p>
<p>负载因子: 当前的默认扩容策略 为负载因子达到 0.9 时则进行扩容</p>
<p>Rust标准库实现的 HashMap， 默认的 Hash 函数算法是 SipHashl3o 另外，标准库还实现 了 SipHash24, SipHash算法可以防止 Hash碰撞拒绝服务攻击(Hash Collision DoS)，这种
攻击是一种基于各语言 Hash 算法的随机性而精心构造出来的增强 Hash碰撞的手段，被攻击 的服务器 CPU 占用率会轻松地制升到 100%</p>
<p>如何解决哈希碰撞?</p>
<ul>
<li>外部拉链法: 在数组的每个元素位置, 遇到碰撞后, 生长出一个链表, 但是有退化到单链表的风险</li>
<li>开放定址法: 在发生冲突时直接去寻找下一个空的地址, 开放定址法的优点在于计算简单、快捷，处理方便:缺点是它会 产生聚集 现象，并且删除元 素也会变得十分复杂(因为并不能真的删除， 否则会破坏寻址的正确性)
寻找下一个空地址的行为，叫作探测 (Probe)。依次 一 个个地 寻找 叫作 续性探测( Linear Probing), rust 采用这种</li>
</ul>
<blockquote>
<p>在线性探测时，如果遇到空桶， 则正常插入; 如果遇到桶己 经被占用 ，那么 就要看占用这个桶的键值对是经历 过几次 探测才被插入该位置 的， 如果该键值对的探测次数比当前待插入的键值对的探测次数少，则它属于“富翁”， 就把当前的键值对插入该位置，再接着找下一个位置来安置被替换的“富翁”键值对。 正是因 为这种“劫 富济贫 ”的思路，这种 算法才被称 为罗 宾汉算法。</p>
</blockquote>
<h3><a class="header" href="#btreemap-有序哈希表" id="btreemap-有序哈希表">BTreeMap 有序哈希表</a></h3>
<p>基于 B 树的有序映射集实现，按 Key 排序</p>
<h3><a class="header" href="#hashset-无序集合" id="hashset-无序集合">hashset 无序集合</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>// HashSet&lt;K&gt; BTreeSet&lt;K&gt;其实就是 HashMap&lt;K, V&gt;和 BTr巳eMap&lt;K, V&gt;把 Value 设置 为空元组的特定类型，等价于 HashSet&lt;K, ()&gt;和 BTreeSet&lt;K, ()&gt;


//
    //散列集 HashSet
    //
    //union（并集）：获得两个集合中的所有元素（不含重复值）。
    // difference（差集）：获取属于第一个集合而不属于第二集合的所有元素。
    // intersection（交集）：获取同时属于两个集合的所有元素。
    // symmetric_difference（对称差）：获取所有只属于其中一个集合，而不同时属于 两个集合的所有元素。
    //
    use std::collections::HashSet;
    let mut a: HashSet&lt;i32&gt; = vec!(1i32, 2, 3).into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec!(2i32, 3, 4).into_iter().collect();
    a.insert(4); // 如果值已经存在，那么 `HashSet::insert()` 返回 false
    a.contains(&amp;4);//是否存在
    //并集
    let c = a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;();

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#btreeset-有序集合" id="btreeset-有序集合">BTreeSet 有序集合</a></h3>
<h3><a class="header" href="#优先队列-binaryheap" id="优先队列-binaryheap">优先队列 BinaryHeap</a></h3>
<p>使用 peek方法可以 取出堆中的最大值</p>
<h2><a class="header" href="#类型转换" id="类型转换">类型转换</a></h2>
<h3><a class="header" href="#基本的类型转换" id="基本的类型转换">基本的类型转换</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>    // 类型转换
    //
    //Rust 不提供原生类型之间的隐式类型转换（coercion），但可以使用 as 关键字进行显 式类型转换（casting）
    //
    println!(&quot;------类型转换--------------------------&quot;);
    let decimal = 65.4321_f32; // 通过字面量直接声明类型

    // 错误！不提供隐式转换
    let integer: u8 = decimal;
     // 可以显式转换
    let integer = decimal as u8;
    let character = integer as char;



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#转换相关的-trait" id="转换相关的-trait">转换相关的 trait</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>//
//
// 其他转换相关的 trait
//
//from和into 方法是一对，实现了From trait就会自动反过来实现Into
// - std::convert::From 接口定义 “怎么根据另一种类型生成自己”
// - Into trait 就是把 From trait 倒过来而已; 使用 Into trait 通常要求指明要转换到的类型
//
//- TryFrom and TryInto trait 用于易出错的转换，也正因如此，其返回值是 Result 
//
//- ToString trait 要把任何类型转换成 String，只需要实现 to_string 方法。
//然而不要直接这么做，应该实现fmt::Display trait，它会自动提供 ToString，并且还可以用来打印类型
//-  对应的有 FromStr, 只要对目标类型实现了 FromStr trait，就可以用 parse 把字符串转换成目标类型
//
use std::convert::From;
#[derive(Debug)]
struct Number {
    value: i32,
}
impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}
let num = Number::from(30);
println!(&quot;My number is {:?}&quot;, num);
let int = 5;
let num: Number = int.into();// num 类型必须指定
println!(&quot;My number is {:?}&quot;, num);



<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#所有权" id="所有权">所有权</a></h2>
<h3><a class="header" href="#为什么需要所有权-raii机制" id="为什么需要所有权-raii机制">为什么需要所有权 RAII机制</a></h3>
<p>所有权是对堆内存上的数据来说的, 所有权为每个数据规定了主人, 避免了数据竞争, 同时也能减少bug. </p>
<p>栈内存中变量的生命周期是短暂的, 随着方法调用的结束而清理, 堆内存的变量虽然可以长久存在, 但是非线程私有, 其内部的数据需要通过栈内存中的指针来使用</p>
<p>指针在堆上开辟内存 空 间，并拥有其所有权，通过存储于stack中的指针来管理堆内存 , 智能指针的 RAII 机制利用stack的特点，在元素被自动清空时自动调用析构函数，来释放智 能指针所管理的堆内存 空间</p>
<h3><a class="header" href="#基本原则" id="基本原则">基本原则</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 每种编程语言都有自己的一套内存管理的方法。
//有些需要显式的分配和回收内存（如C），
// 有些语言则依赖于垃圾回收器来回收不使用的内存（如Java）。
// 而Rust不属于以上任何一种，它有一套自己的内存管理规则，叫做Ownership。
//
// //
// 1. 在Rust中，每一个值都有对应的变量，这个变量称为值的owner
// 
// 2. 一个值在某一时刻只能有一个owner (在任意给定时刻，某个值只能存在一个可变引用或任意数量的不可变引用 )
//          例如 , let a = 11, let b = Person {}; func(a, b); 
 //           因为函数调用底层实际是 将 a, b 赋值给 函数栈中的临时变量, 造成 a, b 的所有权转移
//            对于 基本类型 a, 实现了 copy trait, 所有权转移的效果是 复制, a 仍然能继续使用
//            对于 符合类型b, 没有 copy trait, 所有权转移后, b 就失效了
//            
// 3. 当owner超出作用域后，值会被销毁


///对于堆中的内存, rust没有类似 c 中 free() 的资源释放函数
///rust编译器会在变量超出其作用域后, 自动添加调用释放资源函数的步骤, 清理对应的堆内存
///
///


// 编写代码需要遵循的规则:
// 
// 在不可变借用期间，所有者不能修改资源，并且也不能再进行可变借用
// 在可变借用期间，所有者不能访问资源，并且也不能再出借所有权


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#字符串赋值的所有权" id="字符串赋值的所有权">字符串赋值的所有权</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn ownership() {
    // 对于 basic type, 数据的互动都发生在栈上, 大小已经确定, 复制起来很快, 所以采用的是复制克隆
    let x = 5;
    let y = x; // 现在栈中将有两个值 5
    println!(&quot;{}, {}&quot;, x, y);// 都有效

    //产生一个 String 对象，值为 &quot;hello&quot;。长度可变, 需要在堆中存储
    // s1 存储在栈, 结构中包含一个 ptr, 指向堆中的String 字符序列
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;// 拷贝 s1  本身给 s2, 堆中的数据还是同一份
    //
    // 此时, s1已经失效了, 表现的像 s1 移动到 s2
    //为什么rust规定此时 s1失效?  因为如果程序在这里结束,  s1 和 s2 都被释放的话堆区中的 &quot;hello&quot; 被释放两次，会出错
    // 为了确保安全，在给 s2 赋值时 s1 已经无效了
    println!(&quot;s2 = {}&quot;, s2);
    println!(&quot;s1 = {}&quot;, s1); // 错误

    // 复制克隆堆中的对象
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();
    // 此时, s1 s2 都有效
    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#函数参数的所有权" id="函数参数的所有权">函数参数的所有权</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>    //
    // 函数 参数的所有权机制
    //
    //如果将变量当作参数传入函数，那么它和移动的效果是一样的 (函数外部的变量失效)
    let s = String::from(&quot;nihao&quot;);
    let a = 11;
    fn fn_basic_type(a: i32) {
        println!(&quot;a = {}&quot;, a);
    } // 函数结束, a基本类型, 资源无需释放
    fn fn_str_type(s: String) {
        println!(&quot;s = {}&quot;, s);
    } // 函数结束, s 资源被释放

    // s 被作为参数传递到函数内, 形参指向 String对象, 那么前面的 s 失效
    //相当于数据被移动了
    fn_str_type(s);
    // 所以这里 s 无效了
    println!(s);//error

    // a 是基本类型, 实现了 copy trait, 传递时是 copy,
    fn_basic_type(a);
    // 所以, 此时 a 仍然有效
    println!(&quot;a = {}&quot;, a);


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#函数返回值所有权" id="函数返回值所有权">函数返回值所有权</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>    //
    // 函数返回值的所有权
    //
    //函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，
    //而不会直接被无效释放。
    fn return_str() -&gt; String {
        let s = String::from(&quot;hello&quot;);
        return s;
    }
    fn give_and_return_str(s: String) -&gt; String {
        s
    }
    let s1 = return_str(); // 函数将内部返回值移动到 s1
    let s2 = String::from(&quot;hello&quot;);
    let s3 = give_and_return_str(s2); // s2 被移动失效


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#复合类型中的所有权" id="复合类型中的所有权">复合类型中的所有权</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>// 所有权机制会带来复杂性
    //
    #[derive(Debug)]
    struct Person {
        name: String,
        email: String,
    }
    let mut p = Person {
        name: &quot;xiaoyu&quot;.to_owned(),
        email: &quot;775000738@qq.com&quot;.to_owned(),
    };

    let _name = p.name;// property &quot;name&quot; was been removed out of p
    println!(&quot;{:?}&quot;, p); // 编译出错 &quot;value borrowed here after partial move&quot; , 属性 name 为 string, 没有 copy trait, 被 move 掉后, 值就为 空了
    p.name = &quot;xy&quot;.to_owned(); // 重新赋值
    println!(&quot;{:?}&quot;, p); // 这时不会报错了

    // 模拟动画渲染示例
    struct Buffer {
        buf: String,
    }
    struct Render {
        current: Buffer,
        next: Buffer,
    }
    impl Render {
        fn update_buffer(&amp;mut self, buf: String) {
            // 编译错误, next 没有实现 copy trait, 被 move 掉后, 就为 空了,
            //一个可选方案是实现 copy trait, 但是这样就没法享受方便的 move 语义了
            //
            self.current = self.next;
            self.next = Buffer {buf,};

            // 解决:
            //需要动用 std::mem::replace(&amp;dest, src) 函数了， 这个函数把 src 的值 move 到 dest 中，然后把 dest 再返回出来
            self.current = std::mem::replace(&amp;mut self.next, Buffer {buf});
        }
    }
}


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#多所有权" id="多所有权">多所有权</a></h3>
<p>需要使用智能指针</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>     

<span class="boring">fn main() {
</span>fn multi_ownership() {
    


    

    }
}


<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#生命周期参数" id="生命周期参数">生命周期参数</a></h2>
<h3><a class="header" href="#什么是生命周期" id="什么是生命周期">什么是生命周期</a></h3>
<pre><code class="language-rs">let a = &quot;hello&quot;;//let绑定了标识符 a和存 储字符串的那块内存，从而 a对那块内存拥有了所有权, a 也可称为一个绑定
let b = a; // a 的所有权被转给b (a 为 &amp;str类型, 无法实现 copy trait); 其实也可以理解为对 a进行解绑，然后重新绑定给 b。

// 绑定具有时效性，也就是指它的生存周期
</code></pre>
<h3><a class="header" href="#为什么存在生命周期注释" id="为什么存在生命周期注释">为什么存在生命周期注释</a></h3>
<p>因为存在生命周期检查, 生命周期注释是用来方便编译器进行生命周期检查的 , 并不能改变任何引用的生命周期长短</p>
<p>为什么要生命周期检查? 因为存在引用, 因为要保证引用的生命周期不能长于出借方的生命周期(防止垂悬引用), 有引用就会有生命周期检查 </p>
<p>为什需要引用呢? 复合类型如果克隆的话, 会有性能问题, 这种情况, 只能传递引用了.</p>
<blockquote>
<p>总结一下就是: 函数参数可 以按值传递， 也可以按 引 用传递。当参数按值 传递肘 ， 会转移所有权或者执行复制( Copy)语义。当参数按引用传递 时， 所有权不会发生 变化 ，但是需要有生命周期参数 。当 符合生命周期参数省略规 则时， 编译器可 以通过自动准 断补齐函数参数的生命周期参数，否则，需要显式地为参数标明生命周期参数</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// 生命周期注释: 用来标注多个变量间生命周期的关系, 比如生命周期是否一样长
/// 
/// 目的: 避免垂悬引用
/// 
/// 生命周期注释并不改变任何引用的生命周期的长短
/// 单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的
/// 
/// 大部分情况, 生命周期都是可以自动推断的, 就像类型推断 , 没法推断时, 就需要手动标注生命周期注释了
// 
// 语法: 
// &amp;’a i32
// &amp;'a mut i32 
/// 
/// 
fn life_cycle() {
    // 看一个有问题的例子:
    let a;
    {
        let x = 1;
        a = &amp;x; // 错误, `x` does not live long enough, 出了x 作用域, a 对 x 的借用就失效了
    }
    println!(&quot;{}&quot;, a);// 此时 a 变为垂悬引用

    &amp;i32        // 常规引用
    &amp;'a i32     // 含有生命周期注释的引用
    &amp;'a mut i32 // 可变型含有生命周期注释的引用
    //

    // 只有一个参数并且直接返回的例子
    // 因为编译器可以自己推导出来，函数 foo() 的参数和返回值都是一个引用，他们的生命周期是一样的，所以，也就可以编译通过
    fn foo (s: &amp;mut String) -&gt; &amp;String {
        s.push_str(&quot;coolshell&quot;);
        s
    }
    let mut s = &quot;hello, &quot;.to_string();
    println!(&quot;{}&quot;, foo(&amp;mut s))

    // 这个例子就不行了 , 编译器无法在编译期间知道会返回哪个变量, 也就无法自动推导出生命周期是否符合要求
    //
    // 这个错误例子只针对返回引用的情况
    //
    fn longer(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {// error, 返回的引用 可能和参数定义的地方不在同一个作用域, 返回的引用孩砸使用的时候, 参数超出作用域而失效了
        if s1.len() &gt; s2.len() {s1}
        else {s2}
    }
    // 正确的写法: 需要手动指定生命周期注释
    //
    fn longer&lt;'a&gt;(s1: &amp;'a str, s2: &amp;'a str) -&gt; &amp;'a str {//函数定义指定了签名中所有的引用必须有相同的生命周期 'a
    // 加上周期注释就是告诉编译器: 函数返回的引用的生命周期 &lt;= 每个传入参数的生命周期, 即返回值在使用过程中, 是安全的, 不会指向空
        if s2.len() &gt; s1.len() {
            s2
        } else {
            s1
        }
    }
    let r;
    {
        let s1 = &quot;rust&quot;;
        let s2 = &quot;ecmascript&quot;;
        r = longer(s1, s2);
    }
    println!(&quot;{} is longer&quot;, r); // 此时 s1, s2 都销毁了, 为什么 r 仍然有效呢? 因为 s1, s2 都是 &amp;str 类型, 分配在 栈中, 在方法退出前, 都有效

    //看 String 的例子:
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;); // 这里就有问题了, String 类型 字符序列分配在 heap, 超出 作用域自行销毁了
        result = longer(string1.as_str(), string2.as_str());// error, borrowed value does not live long enough
                                                                //  string2 生命周期比 result 短
    }
    println!(&quot;The longest string is {}&quot;, result);


    //
    //加不加 'a 都是错误, cannot return value referencing local variable `s`
    // 因为函数结束, s 会离开作用域, 被清理
    // 最好的解决方案是返回一个有所有权的数据类型而不是一个引用，这样函数调用者就需要负责清理这个值了。
    //
    fn as_str&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
        let s = String::from(&quot;hello&quot;);
        s.as_str() 
    }

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#函数中的生命周期参数" id="函数中的生命周期参数">函数中的生命周期参数</a></h3>
<pre><code class="language-rs">fn foo&lt;’a&gt;(s: &amp;’a str, t: &amp;’a str) -&gt; &amp;’a str
// 输出(借用方)的生命周期长度必须 短于/等于 输入(出借方)的生命周期长度
// -》返回的引用必须和输入参数有点关系才行

</code></pre>
<h3><a class="header" href="#结构体中生命周期-省略的规则" id="结构体中生命周期-省略的规则">结构体中生命周期 省略的规则</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 生命周期省略
//
// 省略遵循的规则:
// - 只有一个生命周期参数, 可以省略, 如 fn bar&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a 32 等价 fn bar(x: &amp;i32) -&gt; &amp;i32
// - 每个引用参数都有属于自己的周期参数, 如 fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32), fn bar&lt;'a&gt;(x: &amp;'a i32)
// - 对于 struct 的方法, 第一个参数都是 &amp;self, 那么 self 的周期被赋予所有输出生命周期参数 , 所以 返回参数可以省略周期参数
    //
    // 
    //
    // 加上周期注释, 告诉编译器, 结构体的生命周期 &lt;= 成员引用的生命周期, 即成员的周期要保证结构体周期的安全, 成员的周期必须要更大
    struct Str&lt;'a&gt; {
        content: &amp;'a str // 使用字符串切片引用, 之前都是使用的 String 
    }
    impl&lt;'a&gt; Str&lt;'a&gt; {
        //
        //这里返回值并没有生命周期注释，但是加上也无妨。这是一个历史问题，早
        //期 Rust 不支持生命周期自动判断，所有的生命周期必须严格声明，但主流
        //稳定版本的 Rust 已经支持了这个功能
        fn get_content(&amp;self) -&gt; &amp;str {
            self.content
        }

        //指定: 结构体方法的“引用参数”的生命周期 &gt;= 结构体的生命周期, 保证结构体周期的安全
        // 若没有 ‘a, 会报错
        fn replate(&amp;mut self, new: &amp;'a str) {...}
    }
    let s = Str {
        content: &quot;string_slice&quot; // 方便多了
    };
    println!(&quot;s.content = {}&quot;, s.get_content());

   
}


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#静态生命周期注释" id="静态生命周期注释">静态生命周期注释</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span> //静态生命周期
    //
    //'static 所表示的生命周期从程序运行开始到程序运行结束。
    //
    //所有字符串字面量都是 &amp;'static str ，
    let s: &amp;'static str = &quot;hello&quot;;
    // 等价
    let s = &quot;hello&quot;;

    //一个综合例子🌰
    use std::fmt::Display;
    fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
        where T: Display
    {
        println!(&quot;Announcement! {}&quot;, ann);
        if x.len() &gt; y.len() {
            x
        } else {
            y
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#生命周期约束" id="生命周期约束">生命周期约束</a></h3>
<pre><code class="language-rs">// T:’a， 表示T类型中的任何引用都要“活得” 和 ’a 一样长。
// T: Trait + ‘a，表示 T类型必须实现 Trait这个 trait，并且 T类型中任何引用都要“活得”和 ’a 一样长。

</code></pre>
<h2><a class="header" href="#引用" id="引用">引用</a></h2>
<h3><a class="header" href="#引用基本介绍" id="引用基本介绍">引用基本介绍</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>/// 借用(引用)
/// &quot;&amp;&quot;符号用于从变量借用所有权, 生成一个变量的引用
/// ref 声明某个变量为引用类型, 用来更改赋值行为, 使得普通的变量赋值行为变为给引用赋值 ; 可用于先声明某个引用类型, 后赋值
/// 
///
///
/// 引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置
///
/// 引用不会获得值的所有权, 引用只能租借（Borrow）值的所有权, 所以 变量 a 的值被借用为 b 时，a 本身仍然有效。
/// 
/// 解引用 使用 * ---- 在等号右边 (会获得原始值的所有权)
/// 取地址 使用 &amp; ---- 在等右边
/// 解构 使用 &amp; --- 在等号左边
/// 
/// match的模式匹配的匹配项上只能使用 ref，
/// 在函数声明上只能使用&amp;来表示引用类型
/// 
/// 一个引用的作用域从声明的地方开始一直持续到最后一次使用为止
/// 
/// 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用

// 
/// 分为可变, 不可变引用
// 
// 一个原始值, 存在可变借用, 就无法存在其他借用了, 无论是可变借用还是不可变借用 (可变借用具有独占性)
// 存在不可变借用, 还能存在其他不可变借用 (相当于内存的读写锁 ，同一时刻，只能 拥有一个写锁，或者多个读锁，不能同时拥有)
/// 
let a = 20;  
let b = &amp;a;  // 取地址
if a==*b  // true  , *号为解引用符号
{  
println!(&quot;a and *b are equal&quot;);  // 将打印这句
}  

else  
{  
println!(&quot;they are not equal&quot;);  
}  




    //
    //
    // ref 关键字
    //
    let ref a=2;
    let a = &amp;2; // 等效, 两个值都是&amp;i32类型

    let ref b: i32; // 先声明一个引用类型
    //b = 1;// 错误, 类型不匹配, expected `&amp;i32`, found integer. expected &amp;i32，consider borrowing here: `&amp;1`
    b = &amp;1;// 再赋值
    //
    // 为参数声明类型的时候, 只能用 &amp;, 不能用 ref, ref 只用于变量类型声明
    //
    struct B&lt;'l&gt; {
        pub a: &amp;'l u32,
        pub b: ref u32, //错误, expected type, found keyword `ref`
    }
    let ref a = &amp;1;
    let b = B{ a: a };

    fn test(a: ref i32) {    } // 错误


    let v = 2;
    let mut v_mut = 2;
    match v {
        // ref 会声明 val 是 &amp;i32 类型, 通过 val 接收 v
        ref val =&gt; println!(&quot;val 是引用, val = {}&quot;, val),// 打印, *val 也可, 打印时可以省略 *
    }
    match v_mut {
        ref mut val =&gt; {
            // 需要 val 声明为 mut
            *val = 3; 
            println!(&quot;val 是可变引用, val = {}&quot;, val);
        },
    }





    // 解引用
    let r=&amp;1;// r 是引用类型 &amp;i32
    let &amp;a=r;// a 是普通类型, i32
    let c=*r; // c 同 a, 是 i32 (解引用)


    //
    // match 中使用解引用
    let r = &amp;1;
    match r {
        &amp;val =&gt; println!(&quot;通过解引用获取值: {}&quot;, val), 
    }

    
    match r {
        *val =&gt; println!(&quot;使用 * 解引用: {}&quot;, val),// 错误, * 不能用来做声明
    }
    // 需要先解引用, 再内部使用
    match *r {
        val =&gt; println!(&quot;匹配前先解引用: {}&quot;, val),
    }
    


}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#不可变引用" id="不可变引用">不可变引用</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>println!(&quot;------------------引用/借用---------------------------&quot;);
    let s1 = String::from(&quot;hello&quot;);
    let s2 = &amp;s1; // 获取引用
    println!(&quot;s1 is {}, s2 is {}&quot;, s1, s2);

    // 函数调用
    fn calculate_length(s: &amp;String) -&gt; usize {
        s.len()
    }
    let s1 = String::from(&quot;hello&quot;);
    let len = calculate_length(&amp;s1);
    println!(&quot;The length of '{}' is {}.&quot;, s1, len);// s1 还有效

    let s1 = String::from(&quot;hello&quot;);
    let s2 = &amp;s1;
    // 错误, 执行这句, s1 会移动而失效
    // 造成 s2 对 s1 的租借也失效
    let s3 = s1;
    println!(&quot;{}&quot;, s2);//error

    let s1 = String::from(&quot;hello&quot;);
    let mut s2 = &amp;s1;
    let s3 = s1;
    s2 = &amp;s3; // // 重新从 s3 租借所有权, 要求 s2 是 mut 的
    println!(&quot;s2 = {}&quot;, s2);

    //
    // 引用的所有权是租借的, 不允许修改值
    //
    let s1 = String::from(&quot;run&quot;);
    let s2 = &amp;s1;
    println!(&quot;{}&quot;, s2);
    s2.push_str(&quot;oob&quot;); // 错误，禁止修改租借的值

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#可变引用" id="可变引用">可变引用</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>


<span class="boring">fn main() {
</span>fn borrow() {
    

    //
    //可变引用
    //
    // 可修改值的租借
    let mut s1 = String::from(&quot;run&quot;);
    // s1 是可变的
    let s2 = &amp;mut s1;
    // s2 是可变的引用
    s2.push_str(&quot;oob&quot;);
    println!(&quot;可变引用, s2 = {}&quot;, s2);//runoob
    println!(&quot;s1 = {}&quot;, s1);//runoob

    //
    //可变引用不允许多重引用
    //
    //一个值被可变引用时不允许再次被任何引用。
    // 主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生
    let mut s = String::from(&quot;hello&quot;);
    let r1 = &amp;mut s;
    // 错误, 因为 两个可变引用指向了 s;
    let r2 = &amp;mut s;

    // 类似的多重引用问题
    //
    let mut s = String::from(&quot;hello&quot;);
    let r1 = &amp;s; // 没问题
    let r3 = &amp;mut s; // 大问题
    println!(&quot;{}&quot;, r1);


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#垂悬引用问题dangling-references" id="垂悬引用问题dangling-references">垂悬引用问题（Dangling References)</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>


<span class="boring">fn main() {
</span>    //
    //垂悬引用（Dangling References）---- 如何解决 -&gt; 生命周期注释
    //
    //
    // 垂悬引用（Dangling References): 没有实际指向一个真正能访问的数据的指针
    //
    //在 Rust 语言里不允许出现
    fn dangle() -&gt; &amp;String {
        let s = String::from(&quot;hello&quot;);
        //函数的结束，其局部变量的值本身没有被当作返回值，被释放了。但它的引用却被返回
        &amp;s
    }
    
    // 再比如:
    //
    let r;
    {
        let x = 3;
        r = &amp;x; //`x` does not live long enough,  r 所引用的值已经在使用之前被释放
    }
    println!(&quot;r = {}&quot;, r);
    //
    // 再比如:
    fn longer(s1: &amp;str, s2: &amp;str) -&gt; &amp;str {
        if s2.len() &gt; s1.len() {
            s2
        } else {
            s1
        }
    }
    // //上个函数错误, 无法编译, 原因是返回值引用可能会返回过期的引用, 例如这样使用:
    let r;
    {
        let s1 = &quot;rust&quot;;
        let s2 = &quot;ecmascript&quot;;
        r = longer(s1, s2);
    }
    println!(&quot;{} is longer&quot;, r); // r 被使用的时候源值 s1 和 s2 都已经失效了, 需要使用生命周期注释, 为返回值声明一个注释, 贴到 参数上







<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#裸指针" id="裸指针">裸指针</a></h2>
<pre><code class="language-rs">// 原生 指针是指形如* const T 和*mut T 这样的类型 。
// 可以通过 as操作符随意转换，例如&amp;Tas *constT和&amp;mutT as *mutT。
// 原生指针可 以在 unsafe 块下任意使用，不受 Rust 的安全检查规则的限制，而引用则必须受到编译器安 全检查规 则的限制 。
</code></pre>
<h2><a class="header" href="#智能指针" id="智能指针">智能指针</a></h2>
<h3><a class="header" href="#智能指针介绍" id="智能指针介绍">智能指针介绍</a></h3>
<p>智能指针就是一个结构体，其行为类似于引用, 指向一块内存的地址, 智能指针拥有资源的所有权，而普通引用 只 是对所有权 的借用 。</p>
<p>智能指针区别于常规结 构体的特性在于，它实现了 Deref 和 Drop 这两个 trait, Deref 提供了解引用能力 ， Drop 提 供了自动析构的能力 ;</p>
<p>比如: String 和 Vee 类型 也是一种智能指针, 它们也都实现了 Deref和Drop</p>
<pre><code class="language-rs">let x =Box::new(”hello”);
let y = x;
// error, 因为智能指针拥有原始值的所有权, x已经被转移了
// 对于box&lt;T&gt;, 若包含的 T是移动语义, 则box 也是, 若T是复制语义, 则box 也是复制语义
println1(”(:?}”, x);
</code></pre>
<h3><a class="header" href="#raii机制-实现内存回收" id="raii机制-实现内存回收">RAII机制 实现内存回收</a></h3>
<p>RAII: 智能指针在堆内存上开辟空间存储数据, 自身存储在栈上, 在函数调用结束时, 指针变量被清理, 指针执行自身的drop方法, 来释放智 能指针所管理的堆内存 空间</p>
<p>RAII , 智能指针, 均起源于现代 C++</p>
<h3><a class="header" href="#box-无痛使用堆内存" id="box-无痛使用堆内存">Box 无痛使用堆内存</a></h3>
<h4><a class="header" href="#box基本使用" id="box基本使用">Box基本使用</a></h4>
<p>通过 Box，开发者可以方便无痛地使用堆内存， 并且无须手工释放堆内存， 可以确 保内存安全</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// 智能指针
// Rust 中的值默认被分配到stack内存。 可以通过 Box &lt;T&gt;将值装箱(在堆内存中分配)
/// 当箱子实例离开作用域时，它的析构函数会被调用，内部的对象会被 销毁，堆上分配的内存也会被释放
// 
//  Box&lt;T&gt;指针对所管理的堆内存有唯一拥有权， 所以并不共享

/// 
/// 使用 * 运算符进行解引用；这会移除掉一层装箱
///
///核心作用就是可以定义动态大小的类型, 实际大小要到运行期才能确定, 如 用在 递归中 and 用在包装 trait 中 
fn box_demo() {
    println!(&quot;-------------box_demo--------------&quot;);
    let b = Box::new(5);//使用 box 在堆上储存一个 i32 值
    println!(&quot;b = {}&quot;, b);//5
    println!(&quot;*b = {}&quot;, *b);//5

    // 使用场景:
    // 定义递归的结构中使用, 
    // 尝试构造链表
    enum List {
        Cons(i32, List),// error, 无限递归, 编译器检测出了无限大小
        Nil,
    }
    // 正确: (这种方法存在限制, 构造出的 链表无法存在多个引用, 使用一次就失效了, 没法给第二个使用者使用了, 解决: Rc)
    #[derive(Debug)]
    enum List {
        Cons(i32, Box&lt;List&gt;),
        Nil,
    }
    use List::Cons;
    use List::Nil;
    let l = Cons(
        1,
        Box::new(Cons(
            2,
            Box::new(Cons(
                3,
                Box::new(Nil),
            ))
        ))
    );
    println!(&quot;{:?}&quot;, l);//Cons(1, Cons(2, Cons(3, Nil)))

<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#自定义智能指针" id="自定义智能指针">自定义智能指针</a></h4>
<pre><code class="language-rs">    

    // 自定义智能指针
    //
    struct MyBox&lt;T&gt;(T);
    impl&lt;T&gt; MyBox&lt;T&gt; {
        fn new(x: T) -&gt; MyBox&lt;T&gt; {
            MyBox(x)
        }
    }
    //实现 Deref trait 允许我们重载 解引用运算符
    use std::ops::Deref;
    impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
        type Target = T;

        fn deref(&amp;self) -&gt; &amp;T {
            &amp;self.0
        }
    }
    let x = 5;
    let y = MyBox::new(x);
    println!(&quot;y = {}&quot;, *y);




    // 隐式解引用 (解引用多态)
    fn hello(name: &amp;str) {
        println!(&quot;Hello, {}!&quot;, name);
    }
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
    //在 MyBox&lt;T&gt; 上实现了 Deref trait，Rust 可以通过 deref 调用将 &amp;MyBox&lt;String&gt; 变为 &amp;String。
    //标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。
    //Rust 再次调用 deref 将 &amp;String 变为 &amp;str，这就符合 hello 函数的定义了。


</code></pre>
<h4><a class="header" href="#包装动态大小类型" id="包装动态大小类型">包装动态大小类型</a></h4>
<pre><code class="language-rs">    // 动态大小类型
    // 编译期间无法知道大小, 只有到运行时才知道
    //
    // 动态大小类型的值必须通过指针访问 , 如 Box&lt;str&gt;, Rc&lt;str&gt;
    //
    //
    // 如:
    // - str 在编译期无法知道大小, &amp;str 的大小可以在编译期知道 (&amp;str 存储了 str 的地址 和长度)
    // - trait , 任何 trait 都是动态大小类型, 应该这么使用: Box&lt;XXXTrait&gt;
    //
    // Sized trait
    // 实现了这个 trait 的类型, 在编译期即可确定大小
    fn xxx_fn&lt;T&gt;(t: T) {} // T 为编译期知道大小的类型
    // 等价:
    fn xxx_fn&lt;T: Sized&gt;(t: T) {}
    // 放宽限制
    fn xxx_fn&lt;T: ?Sized&gt;(t:T) {}// T 可能是 sized 的, 也可能不是 sized 的
}





</code></pre>
<h3><a class="header" href="#rc-和-weak-共享堆内存" id="rc-和-weak-共享堆内存">Rc 和 Weak 共享堆内存</a></h3>
<p>提供多个所有权给多个对象</p>
<h4><a class="header" href="#rc-强引用" id="rc-强引用">Rc 强引用</a></h4>
<p>都是引用计数指针, 用于记录存储在堆上的值的引用数, 可 以共享同 一块堆内存, 内部包含的数据是不可变的</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// Rc&lt;T&gt; 的类型。其名称为 引用计数（reference counting）
/// 允许 &quot;不可变数据&quot; 有多个所有者, 数据本身无法修改 (将多个所有权共享给多个变量)
// 
// 内部维护着一个引用计数器，每clone一次(共享一次)， 计数器加1， 当它们都离开作用域肘， 计 数器会被清零，对应的堆内存也会被自动释放。
// 
// 常用方法:
// 
// 
// 
// 
// 
///
let x =Rc::new(45)
let yl = x .clone() ; //+强引用计数, 并非 克隆, 只是增加计数
let y2 = x.clone(); //增加强引用计数
priηtln!(”{:?}”, Rc::strong_count(&amp;x));//3
letw= Rc::downgrade(&amp;x); //增加弱引用计数
println!(” {:?) ”, Rc : :weak_count(&amp;x));
let y3 = &amp;*x; //不增加计数

// 
// 构造链表
// 通过 box 构造链表存在问题: 链表只能被使用一次, 演示:
enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}
use List::{Cons, Nil};
let a = Cons(5,
                Box::new(Cons(10,
                            Box::new(Nil))));
let b = Cons(3, Box::new(a)); //a 被移动到了 b 内部
let c = Cons(4, Box::new(a));//  error 错误, value used here after move

// 使用 Rc 解决
enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}
use List::{Cons, Nil};
use std::rc::Rc;
let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
//每次调用 Rc::clone，Rc&lt;List&gt; 中数据的引用计数都会增加，Rc::strong_count(&amp;a) 获取 a 的被引用个数
// 直到有零个引用之前其数据都不会被清理
//
//也可以调用 a.clone() 而不是 Rc::clone(&amp;a), 两者意思是一样的, 只会增加引用计数，不会作深度复制
//
// 这里, b, c 共享 a 的所有权, a 中的数据不可修改
let b = Cons(3, Rc::clone(&amp;a));
let c = Cons(4, Rc::clone(&amp;a));


<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#对内部值进行修改" id="对内部值进行修改">对内部值进行修改</a></h4>
<pre><code class="language-rs">

///
///如果你要修改 Rc 里的值，Rust 会给你两个方法，一个是 get_mut()，一个是 make_mut() ，这两个方法都有副作用或是限制
/// - get_mut() 需要做一个“唯一引用”的检查，也就是没有任何的共享才能修改
///- make_mut() 则是会把当前的引用给clone出来，再也不共享了， 是一份全新的
// 更好的修改方法:
/// RefCell&lt;T&gt; 能够在对象被认为是不可变的情况下修改内部字段;
/// Cell&lt;T&gt;，它类似 RefCell&lt;T&gt; 但有一点除外：它并非提供内部值的引用，而是把值拷贝进和拷贝出 Cell&lt;T&gt;。
///
/// 
//
//修改引用的变量 - get_mut 会返回一个Option对象
//但是需要注意，仅当（只有一个强引用 &amp;&amp; 没有弱引用）为真才能修改
if let Some(val) = Rc::get_mut(&amp;mut strong) {
    *val = 555;
}
// 或者:
//此处可以修改，但是是以 clone 的方式，也就是让strong这个指针独立出来了。
*Rc::make_mut(&amp;mut strong) = 555;


</code></pre>
<h4><a class="header" href="#weak-弱引用" id="weak-弱引用">Weak 弱引用</a></h4>
<pre><code class="language-rs">


// 弱引用

/// 弱引用: Weak&lt;T&gt;
// Weak 共享的指针没有所有权, 称为弱引用
/// - 通过 Rc::downgrade 传递 Rc 实例的 reference, 得到 Weak 类型的指针, 同时将 weak_count +1, 不是 strong_count +1
/// - 即使 weak_count 不为零, 也可能使得 Rc 实例被清理, 只要 strong_count == 0 就行了 (解决循环链表造成的内存泄漏)
/// - 可以通过 Rc::upgrade 返回 Option&lt;Rc&lt;T&gt;&gt; 升级成强引用
///
/// 这么麻烦，我们为什么还要 Weak ? 这是因为强引用的 Rc 会有循环引用的问题……

// 基本使用
use std::rc::Rc;
use std::rc::Weak;

let weak: Weak&lt;i32&gt;;
let strong: Rc&lt;i32&gt;;
{
    let five = Rc::new(5); //局部变量
    strong = five.clone(); //进行强引用
    weak = Rc::downgrade(&amp;five); //对局部变量进行弱引用
}
//此时，five已析构，所以 Rc::strong_count(&amp;strong)=1， Rc::weak_count(&amp;strong)=1

//如果调用 drop(strong)，那个整个内存就释放了
//drop(strong);

//如果要访问弱引用的值，需要把弱引用 upgrade 成强引用，才能安全的使用
//这个升级可能会不成功，因为内存可能已经被别人清空了
match  weak_five.upgrade() {
    Some(r) =&gt; println!(&quot;{}&quot;, r),
    None =&gt; println!(&quot;None&quot;),

}

// 解决循环引用的内存泄漏问题
use std::{
    cell::RefCell,
    rc::{Rc, Weak},
};
fn main() {
    struct Node {
        head: Option&lt;Weak&lt;RefCell&lt;Node&gt;&gt;&gt;,
        next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
    }
    impl Drop for Node {
        fn drop(&amp;mut self) {
            println!(&quot;dropping&quot;)
        }
    }

    let one = Rc::new(RefCell::new(Node {
        head: None,
        next: None,
    }));
    let two = Rc::new(RefCell::new(Node {
        head: None,
        next: None,
    }));
    let three = Rc::new(RefCell::new(Node {
        head: None,
        next: None,
    }));
    one.borrow_mut().next = Some(two.clone());
    two.borrow_mut().next = Some(three.clone());
    three.borrow_mut().head = Some(Rc::downgrade(&amp;one));// 弱引用, 即使计数没有归零, 仍然可回收内存
}



    

</code></pre>
<h3><a class="header" href="#refcell-和-cell-提供内部可变性" id="refcell-和-cell-提供内部可变性">RefCell 和 Cell 提供内部可变性</a></h3>
<p>变量有唯一所有权, 类似 box</p>
<p>/// 需要注意的是 Cell 和 RefCell 不是线程安全的。在多线程下，需要使用Mutex进行互斥。</p>
<h4><a class="header" href="#cell" id="cell">Cell</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Cell&lt;T&gt;
// 
// 
// 提供了一种内部可变性, 如, 某个 struct 是不可变的, 但是 内部某个字段需要可变

    #[derive(Debug)]
    struct P {
        x: i32,
        y: Cell&lt;i32&gt;,// 这里定义的是 Cell的不可变类型, 但是 内部的数组确实可以修改的, 合法的避开的借用检查
    }
    let p = P { x: 0, y: Cell::new(11)};
    println!(&quot;{:?}&quot;, p);
    p.y.set(1); // set() 对内部数据的类型没有要求
    println!(&quot;{}&quot;, p.y.get());// 内部的数据必须是 copy trait 才能使用 get(), 这里实际是获取拷贝, 若是非 copy类型, 提供 get_mut() 获取内部数据的可变引用
    println!(&quot;{:?}&quot;, p);

<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#refcell" id="refcell">RefCell</a></h4>
<pre><code class="language-rs">
/// RefCell&lt;T&gt;
/// 它类似 Cell&lt;T&gt;,  但有一点除外：提供内部值的引用, 而不是拷贝了, 因此对于内部数据的类型没有 copy trait 要求
// 虽然没有分配空间， 但它是有运行时开销的，因为它自己维护着一个运行 时借用检查器, 比如获取多个可变引用, 会Panic
///
// 主要两个方法:
// borrow_mut() 获取可变引用
// borrow(), 获取不可变引用
let v = RefCell::new(vec![1]);
println!(&quot;{:?}&quot;, v.borrow());//1
v.borrow_mut().push(1);
println!(&quot;{:?}&quot;, v.borrow());//1, 1


let x = RefCell::new(vec![1, 2, 3, 4]);
println!(&quot;{:?}&quot;, *x.borrow()); //[1, 2, 3, 4]
{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
// 若上面的可变借用不另开一个 作用域, 这里报错: 可变借用后, 不允许再次不可变借用了
// 另开一个作用域的效果: my_ref 这个可变借用到这里的时候已经被释放了
println!(&quot;{:?}&quot;, *x.borrow()); //[1, 2, 3, 4, 1]



// RefCell&lt;T&gt; 的一个常见用法是与 Rc&lt;T&gt; 结合构造链表, rc 允许多重引用, 抱在外层, refcel 获取可变引用
//
//他们提供了 set()/get() 以及 borrow()/borrow_mut() 的方法
//
#[derive(Debug)]
enum List1 {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List1&gt;),
    Nil,
}
use List1::{Cons, Nil};
let value = Rc::new(RefCell::new(5));
let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));
let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));
*value.borrow_mut() += 10;
println!(&quot;a after = {:?}&quot;, a);
println!(&quot;b after = {:?}&quot;, b);
println!(&quot;c after = {:?}&quot;, c);






// 实例:
// 定义一个 trait, 定义发送方法 send, 这里 self 是不可变的
// 后续会通过 这个不可变 self 得到可变的成员变量
    trait MsgSender {
        fn send(&amp;self, msg: &amp;str); // 这个 trait 已经固定, &amp;self 不允许改成 &amp;mut self
    }
    // 监控器
    struct LimitTracker&lt;'a, S: MsgSender&gt; {
        sender: &amp;'a S,
        max: usize, // 最大限量阈值
        value: usize, // 已经使用了多少
    }
    impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where
        T: MsgSender,
    {
        fn new(sender: &amp;'a T, max: usize) -&gt; Self {
            LimitTracker {
                sender,
                max,
                value: 0,
            }
        }

        fn set_value(&amp;mut self, value: usize) {
            self.value = value;

            let percent = self.value as f64 / self.max as f64;
            if percent &gt;= 1.0 {
                self.sender.send(&quot;&gt;= 1.0&quot;);
            } else if percent &gt;= 0.8 {
                self.sender.send(&quot;&gt;= 0.8&quot;);
            }
        }
    }

    use std::cell::RefCell;
    //消息发送模拟器
    struct MsgSenderMock {
        // 为什么要包装?
        //后面需要通过 不可变的 &amp;self 拿到可变的 msg_send (不可变 &amp;self 是在 trait 中定义的, send方法获取的是 self不可变引用)
        //如果不包装一下, 则这里无法修改 msg_send 来记录发送的消息
        msg_send: RefCell&lt;Vec&lt;String&gt;&gt;,// 记录发送的信息, 发送的消息会存储到这里
    }
    impl MsgSenderMock {
        fn new() -&gt; Self {
            MsgSenderMock {
                msg_send: RefCell::new(vec![]),
            }
        }
    }
    impl MsgSender for MsgSenderMock {
        fn send(&amp;self, msg: &amp;str) {
            // 改为 refcell后, 通过 borrow_mut 得到可变引用, 类型 Ref, 类似普通引用
            self.msg_send.borrow_mut().push(msg.to_string());
        }
    }
    // 测试
    let mock_sender = MsgSenderMock::new();
    let mut tracker = LimitTracker::new(&amp;mock_sender, 10);
    tracker.set_value(8);
    println!(&quot;{}&quot;, mock_sender.msg_send.borrow()[0]); // 获取不可变引用
</code></pre>
<h3><a class="header" href="#rc-box-refcell-cell-几种指针的区别对比" id="rc-box-refcell-cell-几种指针的区别对比">Rc Box RefCell Cell 几种指针的区别对比</a></h3>
<pre><code class="language-rs">
/// 区别:
/// - Rc&lt;T&gt; 允许相同数据有多个所有者；Box&lt;T&gt; 和 RefCell&lt;T&gt; 只能允许有单一所有者。
/// - Box&lt;T&gt; 在编译时执行借用检查(检查 可变/不可变)；Rc&lt;T&gt;也允许在编译时执行借用检查(但是仅仅检查 不可变)；RefCell&lt;T&gt; 允许在运行时执行借用检查(不可变或可变)。
/// -  box 借用规则检查在编译期, refCell 借用规则检查在运行期
///

// - Cell&lt;T&gt;使用 set/get 方法直接操作包裹的值 (底层是将内部值拷贝出, 修改后在拷贝进去, 适合于实现Copy的类型即复制语义类型)， 
//      RefCell&lt;T&gt;通过 borrow/borrow_mut 返回 包装过的引用 Ref&lt;T&gt;和 RefMut&lt;T&gt;来操作包裹的值 (适合没有实现Copy的类型, 即移动语义类型。)
// - Cel&lt;T&gt;无运行 时开销，并且永远不 会在运行 时引发 panic 错 误。 
//       RefCell&lt;T&gt;需要在运行时执行借用检查，所以有运行时开销，一旦发现违反借用规则的情况，则会引发线程 panic 
///



</code></pre>
<h3><a class="header" href="#cow-写时复制" id="cow-写时复制">Cow 写时复制</a></h3>
<p>写时复制( Copy on Write)技术是一种程序中的优化策略, 翻译成人话就是 拖延到需要对数据进行写操作时才复制一份拷贝, 比如 Linux 中父进程创建于进程时 ， 并不是立刻让子进程复制一份进程空间，而是先让子进程共享父进 程的进程空间 ， 只有等到子进程真正需要写入的时候才复制进程空间。</p>
<pre><code class="language-rs">// 是一个枚举体的智能指针
// Borrowed， 用于包裹引用。表示是对数据的借用
// Owned， 用于包裹所有者。表示是对数据的拥有
// 
// 以不可变的方式访问借用内容，以及在需要可变借用或所有权 的时候再克隆一份数据
//旨在减少复制操作，提高性能， 一般用于读多写少的场景
// 
// - Cow&lt;T&gt;实现了 Deref， 这意味着可以直接调用其包含数据的不可变 方法。
// - to_mut 方法来获取可变借用. 
//      若 T 是 借用, 该方法会产生克隆，但仅克隆一次 ， 如果多次调用，则只会使用第一次的克隆对象
//      如果 T 本身拥有所有权，则此时调用 to_mut不会发生克隆. 所有权转移
// into_owned方法来获取一个拥有所有权的对象
//      若 T 是借用, 发生克隆，井创建新的所有权对 象
//      如果 T 是所有权对象， 则会将所有权转移到新的克隆对象。


use std::borrow::Cow;
// 求元素绝对值
fn abs_all(input: &amp;mut Cow&lt;[i32]&gt;) {
    for i in 0..input.len() {
        let v = input[i];
        if v &lt; 0 {
            // 获取可变引用
            //to_mut 方法会在第一次调用时克隆一个新的对象，在后续的 for 循环中 继续用新的克隆对象
            input.to_mut()[i] = -v;
        }
    }
}
// 求和
fn abs_sum(ns: &amp;[i32]) -&gt; i32 {
    let mut lst = Cow::from(ns);
    abs_all(&amp;mut lst);
    lst.iter().fold(0, |acc, &amp;n| acc + n)
}
fn main() {
    let s1 = [1,2,3];
    let mut i1 = Cow::from(&amp;s1[..]);
    // i1 中的元素都为正, 不会进入if逻辑, 不涉及到可变需求，所以不会克隆
    abs_all(&amp;mut i1);
    println!(&quot;IN: {:?}&quot;, s1);//1,2,3
    println!(&quot;OUT: {:?}&quot;, i1);//1,2,3
    
    
    let s2 = [1,2,3, -45, 5];
    let mut i2 = Cow::from(&amp;s2[..]);
    // 这里有可变需求，且穿进cow 的数据是个引用, 没有所有权, 所以会克隆, i2 实际是克隆出的新对象
    abs_all(&amp;mut i2);
    println!(&quot;IN: {:?}&quot;, s2);//[1, 2, 3, -45, 5]
    println!(&quot;OUT: {:?}&quot;, i2);//[1, 2, 3, 45, 5]
    
    // 这里不会克隆，因为数据本身拥有所有权
    let mut v1 = Cow::from(vec![1,2,-3,4]);//v1是本身就是可变的
    abs_all(&amp;mut v1);
    println!(&quot;IN/OUT: {:?}&quot;, v1);//[1, 2, 3, 4]
}


// 另一个用处是统一实现规范
use std::borrow::Cow;
use std::thread;
#[derive(Debug)]
struct Token&lt;'a&gt; {
    raw: Cow&lt;'a, str&gt;,//该用&amp;str类型还是 String类型呢?为了寻求统一，这里使用了 Cow&lt;T&gt;
}
impl&lt;'a&gt; Token&lt;'a&gt; {
    pub fn new&lt;S&gt;(raw: S) -&gt; Token&lt;'a&gt;
    where
        S: Into&lt;Cow&lt;'a, str&gt;&gt;,
   {
        Token { raw: raw.into() }
   }
}
fn main() {
   let token = Token::new(&quot;abc123&quot;);
   let token = Token::new(&quot;api.example.io&quot;.to_string());
// 还可以跨线程安全传递
   thread::spawn(move || {
       println!(&quot;token: {:?}&quot;, token);
   }).join().unwrap();

//    使用动态字符串切片，则会因为生命周期的问题而无法跨线程安全传递
    //error
    let raw = String::from(&quot;abc&quot;);
    let s = &amp;raw[..];
    let token = Token::new(s);
    thread::spawn(move || {
        println!(&quot;token: {:?}&quot;, token);
    }).join().unwrap();
}
</code></pre>
<h2><a class="header" href="#函数" id="函数">函数</a></h2>
<h3><a class="header" href="#函数基本语法" id="函数基本语法">函数基本语法</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// 如果不指定返回值类型, 默认 返回类型为 () 空元组
// 同名函数在存在于多个作用域(比如 main 外, main 内, main 内的新作用域 分别有三个同名函数), 会发生屏蔽

fn sum(aa: i8, bb: i8) -&gt; i8 {
    // 返回值明确指定类型
    // 若带 return, 就是语句, 需要分号
    // return aa +bb;

    // 不带 return, 就是表达式, 没有分号
    aa + bb
}
let sum = sum(3, 9);
println!(&quot;sum = {}&quot;, sum);

// 函数参数支持模式匹配
fn a(mut b: [i32; 2]) { // 参数为数组可变类型, 不是引用类型 (mut 无法放在冒号后面)
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#函数体表达式" id="函数体表达式">函数体表达式</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 1;

// 函数体表达式
let b = {
    let x = 2;
    // 块末尾是表达式, 不是语句, 没有分号, 没有 return
    x + 1
    // return x + 1;
};
println!(&quot;x = {}&quot;, x); //1
println!(&quot;b = {}&quot;, b); //3
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#函数作为参数" id="函数作为参数">函数作为参数</a></h3>
<pre><pre class="playpen"><code class="language-rust">//
    // 函数作为参数传递
    //
    fn inc1(num: i32) -&gt; i32 { num + 1}
    fn print_num(num: i32, func: fn(i32) -&gt;i32) {
        println!(&quot;{}&quot;, func(num));
    }
    print_num(1, inc1);

// mut 参数
// 这里形式参数类型并非引用, 所以传入实际参数时, 会转移所有权, 实际参数是不是 mut 都可以
fn modify (mut v: Vec&lt;u32&gt; ) - &gt; Vec&lt;u32&gt;
// 这里形参为引用, 所以实际参数必须为 &amp; mut
fn modify(v: &amp;mut [u32]) ;


// 函数参数支持模式匹配
// (函数中的参数等价于一个隐式的 let绑定，而 let绑定本身是一个模式匹配的行为)
#[derive(Debug)]
struct S { i: i32 }
//表示 参数为不可变引用, 相对的, ref mut 表示参数为可变引用
fn f(ref _s: S) {
    println!(&quot;{:p}&quot;, _s); //0x7ffdd1364b80
}
fn main() {
    let s = S { i: 42 };
    f(s);
    // error, 所有权转移
    println!(&quot;{:?}&quot;, s);
}

// 利用了模式匹配来解构元组
fn swap((x, y) : (&amp;str, i32)) {}



</code></pre></pre>
<h3><a class="header" href="#result-返回值" id="result-返回值">Result 返回值</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>// 即便是没有显式返回值的函数，其实 也相当于返回了一个单元值()。如果需要返回多个值，亦可使用元组类型



/// 函数返回值 Result&lt;T, E&gt; 见 error_handling
/// 
/// 
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#发散函数" id="发散函数">发散函数</a></h3>
<p>感叹号 惊叹号</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>/// 发散函数: 返回值类型为 &quot;!&quot; (never type), 标识函数永远不会返回值, 比如 函数包含死循环, 或者 panic
///     发散函数可以作为任何类型. 应用:可以在正常有返回值函数中 panic, 在if 判断中 panic (因为 panic 返回类型为 never type)
///     https://www.zhihu.com/question/54540714/answer/146231560
/// 

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#泛型函数" id="泛型函数">泛型函数</a></h3>
<pre><code class="language-rs">//调用时, 编译器来进行自动推断
// 无法自动推断, 则需要显式指定, 如为接收的变量指定类型, 或者方法调用的时候, 使用 turbofish操作符
let a: i32 = square(37 , 41) ;
let a= square::&lt;u32&gt;(37, 41)
</code></pre>
<h3><a class="header" href="#高阶函数" id="高阶函数">高阶函数</a></h3>
<h4><a class="header" href="#函数指针" id="函数指针">函数指针</a></h4>
<pre><code class="language-rs">// 函数指针
// 
// 
// 函数可以作为参数进行传递
// 实现这一切的基础在于 Rust支持类似 CIC++语言中的函数指针
fn math(op: fn(i32, i32) -&gt; i32, a: i32, b: i32) -&gt; i32
// 
fn hello(){
    println!(&quot;hello function pointer&quot;);
}
fn main(){
    // 必须显式指定函数指针类型 fn()
    let fn_ptr: fn() = hello;
    println!(&quot;{:p}&quot;, fn_ptr); // 0x562bacfb9f80
    // 若没指定函数指针类型, 就不是指针, other_fn 的类型实际上是 fn() {hello}，这其实是函数 hello 本身的类型，而非函数指针类型
    let other_fn = hello;
    // error
    println!(&quot;{:p}&quot;, other_fn);  // not function pointer
    
    hello();
   other_fn();
   fn_ptr();
   (fn_ptr)();
}

// 对于函数指针类型，可以使用 type 关键字为其定义别名 
type MathOp = fn (i32 ， i32) - &gt; i32
fn math(op: MathOp, a: i32, b: i32) -&gt; i32
fn math(op: &amp;str) -&gt; MathOp



</code></pre>
<h4><a class="header" href="#禁止函数捕获外部环境中变量" id="禁止函数捕获外部环境中变量">禁止函数捕获外部环境中变量</a></h4>
<pre><code class="language-rs">// error, // 因为函数不能捕捉动态环境中的变量i, 变量 绑定 i 会随着帧的释放而释放，需要闭包才可以捕获
fn counter(i: i32) -&gt; fn(i32) -&gt; i32 {
    fn inc(n: i32) -&gt; i32 {
        n + i  // error[E0434]: can't capture dynamic environment in a fn item
    }
    inc
}
fn main() {
    let f = counter(2);
    assert_eq!(3, f(1));
}

// 正确, 
fn counter() -&gt; fn(i32) -&gt; i32 {
    fn inc(n: i32) -&gt; i32 {
        n + 1
    }
    inc
}
fn main() {
    let f = counter();
    assert_eq!(2, f(1));
}

// 若果一定要捕获环境变量, 需要闭包
// 2015 edition:
fn counter(i: i32) -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {//放到了 Box&lt;T&gt;中， 因为闭包的大 小在编译期是未知的
    Box::new(move |n: i32| n + i )
}
// or 2018:
// 以大写字母 F 开头的 Fn 并不是函数指针类型 Fn(i32)-&gt;i32， 它是一个trait
fn counter(i: i32) -&gt; impl Fn(i32) -&gt; i32 {//动态大小类型  impl Trait, 这样就不需要使用 Box&lt;T&gt;了
    move |n: i32|{ n + i }
}


</code></pre>
<h2><a class="header" href="#闭包" id="闭包">闭包</a></h2>
<h3><a class="header" href="#闭包基本使用" id="闭包基本使用">闭包基本使用</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>///闭包 (匿名函数): 是一个持有外部环境变量的函数。 外部环境是指闭包定义时所在的词法作用域
/// 
/// 延迟执行 。
// 捕获环境变量 。闭包会获取其定义时所在作用域中的自由变 量 ，以供之后调用时使用
/// 
// 两个定义一模一样的闭包 也并不一定属于同 一种类型, 无法将它们保存到一个数组中。因为数组只能保 存相同类型的元素
/// 
fn closure_demo() {
    println!(&quot;------------------------ closure demo&quot;);
    
    let inc = |num: i32| -&gt; i32 { ////返回值类型推导: 无论后面是否被调用, 返回值都可省略, 但是无法两次推导不同的参数/返回值类型
        num + 1
    };
    // num 的参数类型可以省略, 返回值类型可以省略, 花括号可以省略; 
    //这是因为后面 print_num 函数中已经有类型信息了, 单独定义闭包, 没有后面的调用信息, 则参数类型不能省
    let inc0 = |num| num+1

    fn inc1(num: i32) -&gt; i32 { num + 1} 
    // 函数作为参数传递
    fn print_num(num: i32, func: fn(i32) -&gt;i32) {
        println!(&quot;{}&quot;, func(num));
    }
    print_num(1, inc1);
    print_num(1, inc);
    print_num(1, inc0)

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#rust-实现闭包的原理" id="rust-实现闭包的原理">rust 实现闭包的原理</a></h3>
<pre><code class="language-rs">// 在 Rust 中，闭包是一种语法糖, 是在基本语法功能之上又提供的一层方便开发者编程的语法
// 
// 最初闭包是通过  装箱( Boxed) 闭包 实现的, 性能差, LLVM 难以对其进行内联和优化。
// 如: 闭包 || {a+b} 的实现可以通过函数指针 和捕获变量指针组合来实现。指针放stack上，捕获变量放到堆上



// 非装箱 CUnboxed) 闭包 (现在的实现方式): 支持闭包按值和按引用绑定环境变量 ; 支持三种不同的闭包访问， 对应 self、&amp;self和&amp;mut self三种方法
// 将函数调用抽象为三种, 新增三个 trait 表示
// 
// 这样, 方法调用 a(b, c, d)变为一下三种执行方式:
// 
// Fn::call(&amp;a, (b, c, d))          - 调用 参数为 &amp;self， 这意味着它会对方法接收者进行不可变借用 ，也就是说，这种方法调用可以被调用多次。
// FnMut::callmut(&amp;muta, (b, c, d)) - 调用参数为&amp; mut self，这意味着它会对方法接收者进行可变借用
// FnOnce::call once(a, (b, c, d)) - 调用参数为 self，这意味着它会转移方法接收者的所有权。换句话说，就是这 种方法调用只能被调用 一次
// 
// 现在实现闭包就简单了, 直接定义一个 struct 表示 闭包, 内部使用一个字段表示捕获的自由变量, 在调用的时候使用这个变量即可
// 实际上, 闭包表达式会由编译器自动翻译为结构体实例，并为其实现 Fn、FnMut、FnOnce三个 trait 中的 一个
// 手动实现如下:
#![feature(unboxed_closures, fn_traits)]
struct Closure {
    env_var: u32,
}
impl FnOnce&lt;()&gt; for Closure {
    type Output = u32;
    // 将函数参数中的元 组类型做动态扩展，以便支持可变长参数。
    // 因为在 Fn、 FnMut、 FnOnce 这三个 trait 里的方 法要接收闭包的参数，而编译器本身并不可能知道开发者给闭包设定的参数个数，所以这里 只能传元组，然后由 rust-callABI在底层做动态扩展
    // 需要 unboxed closures特性支持
    extern &quot;rust-call&quot; fn call_once(self, args: ()) -&gt; u32 {
        println!(&quot;call it FnOnce()&quot;);
        self.env_var + 2
    }
}
impl FnMut&lt;()&gt; for Closure {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: ()) -&gt; u32 {
        println!(&quot;call it FnMut()&quot;);
        self.env_var + 2
    }
}
impl Fn&lt;()&gt; for Closure {
    extern &quot;rust-call&quot; fn call(&amp;self, args: ()) -&gt; u32 {
        println!(&quot;call it Fn()&quot;);
        self.env_var + 2
    }
}
let env_var = 1;
let mut c = Closure { env_var: env_var };
// 结构体实例可以像函数那样被调用, 因为 定义方法时候, 使用了 extern 关键字，表示使用指定的 ABI (Application Binary Interface， 程 序二进制接口)
c();
c.call(());
c.call_mut(());
c.call_once(());
</code></pre>
<h3><a class="header" href="#捕获环境变量-and-三种闭包类型" id="捕获环境变量-and-三种闭包类型">捕获环境变量 and 三种闭包类型</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// 闭包中可以捕获外部环境中的变量

    //捕获环境变量
    // 有三种方式, 根据捕获变量方式不同, 将闭包定义为三种 trait:
    // 
    // Fn，表示闭包以不可变借用的方式来捕获环境中的自由变 量 ，同时也表示 该闭 包没有 改变环境的能力 ， 并且可以多次调用。闭包接收者是不可变引用, 对应 &amp;self。
    //                  等号右侧闭包表达式  没加 move, 内部无写操作
    //              未捕获任何环境变量的闭包会自动实现 Fn
    //              捕获的自由变量若为复制语义类型, 则闭包实现了 Fn (不需要对外部变量进行写操作)
    //              使用 move 关键字则自动实现 Fn
    // FnMut，表示闭包以可变借用的方式来捕获环境中的自由变 量 ，同时意味 着该 闭包有 改变环境的能力 ，也可以 多次 调用 。 闭包接收者是可变引用, 对应&amp;mut self。
    //                      没加 move, 内部有写操作
    //                     修改环境变量以自动实现 FnMut
    // FnOnce， 表示闭包通过转移所有权来捕获环境中的自由变量，同时意味着该闭包没 有改变环境的能力，只能调用一次，因为该闭包会消耗自身。闭包接收者是值, 并非引用, 对应 self。
    //                      加了 move
    //              由于所有所有闭包都可以至少调用一次, 所以涉及到捕获环境变量 的所有闭包都实现了 FnOnce 
    //
    // 
    // 三种 trait 包含关系: fn 属于(继承于) fnmut 属于(继承于) fnonce;
    // ，如果要实现 Fn， 就必须实现 FnMut和 FnOnce;如果要实现 FnMut, 就必须实现 FnOnce; 如果只需要实现 FnOnce， 就不需要实现 FnMut 和 Fn
    // 
    // 
    // 
    // 闭包捕获其环境变量的方式:
    // 
    // 对于复制语义类型 ，若 表达式加了 move , 以 copy 的形式进行捕获
    //                  若未加 move, 以 引用/可变引用 的形式进行捕获
    // 
    // 对于移动语义类型 ，转移所有权来进行捕获 (无论加没加 move)
    //              移动语义类型自动实现了 FnOnce
    // 
    // 对于可变绑定，并且在闭包中包含对其进行修改的操 作，则以可 变引用 (&amp;mut T) 来进行捕获 。
    // 
    // 
    // 
    let mut i = 1;
    // 修改了 自由变量, 没加 move, 闭包为 FnMut, 需要声明为 可变
    let mut func =  || {
        i+=1;
    };
    func();
    println!(&quot;{}&quot;, i);//2

    let mut i = 1;
    let mut plus_one = move || {// move 可选, 涉及到多线程并发, 一定要加 move, i 所有权移动到闭包, 对于基本类型, 相当于复制了一份, 在闭包内的操作不影响外部的 i
        i += 1;                // 但是  , 若有返回值, 就变为复制引用了
    };
    plus_one(); 
    println!(&quot;i = {}&quot;, i); //1,  

    
    //
    // 对于复杂类型的 捕获
    //
    let v = vec![1,2,3];
    let eq = move |x| x==v; // v的所有权移动到了闭包内部, 外部的 v 失效了
    println!(&quot;eq? {}&quot;, eq(vec![1,2,3]));//true
    println!(&quot;v = {:?}&quot;, v);// 错误, borrow of moved value: `v`





// 更多示例对比

let mut i = 11;
// 没有 move, 闭包内部是 引用, 
let mut fu1 = || i += 1;
fu1();
println!(&quot;{}&quot;, i) //12

//-----------Move的情况----------- (对于基本类型, 实现了 copy trait, 是 copy, 对于 符合类型, 若没有实现 copy trait, 则所有权转移)
// 存在 move, 闭包内是复制
let mut fu1 = move || i += 1; // 局部变量被丢弃
fu1();
println!(&quot;{}&quot;, i);//11


// 存在返回值的情况
let mut fu = || {
    i += 1;
    i
};
fu();
println!(&quot;{}&quot;, i)//12
//-----------Move的情况-----------
let mut fu = move || {
    i += 1;
    i
};
fu();
println!(&quot;{}&quot;, i)//11




//对于没有实现 Copy 的 复合类型，
// 在闭包中可以调用其方法，是“借用”，
// 存在返回值, 返回值了就发生所有权转移, 因为 返回值有可能在别的地方使用, 为了安全, 所有权转移了
//
//
let s = String::from(&quot;coolshell&quot;);
let take_str = || s; // 移动
println!(&quot;{}&quot;, s); //ERROR
println!(&quot;{}&quot;,  take_str()); // OK

let mut s1 = String::from(&quot;hello&quot;);
let mut change_s1 = || s1.push('!');// 没有返回值, 不会移走, 只会可变借用
println!(&quot;{}&quot;, s1);// error, 单独出现没错, 但是和下面函数调用一起出现出错了, 可变借用后, 没法进行不可变借用了
change_s1();
println!(&quot;{}&quot;, s1);// hello!



struct Person {
    name: String,
    age: u8,
}
let p = Person{name: &quot;xiaoyu&quot;.to_string(), age: 11};
let age = |p: Person| p.age; // 存在返回值, 所有权移动
println!(&quot;{}&quot;, age(p));
let name = |p: Person| p.name;
println!(&quot;{}&quot;, name(p));// name(p)编译错误, p 丢失所有权

// 改为 引用版本
//
// 对于 基本类型 的属性, 存在 copy trait, 返回的是 copy
let age = |p: &amp;Person| p.age;
// 现在可以重复使用了
println!(&quot;{}&quot;, age(&amp;p));
println!(&quot;{}&quot;, age(&amp;p));

// 错误, 因为name 为 string 类型, 没有 copy trait
// 函数结束, p.name 被释放, 出错, 若存在 copy trait, 会返回 复制, 没有 copy trait, 只能通过返回引用解决
let name = |p: &amp;People| p.name;
// 解决: 生命周期, 延缓 p.name  被释放的时间
let name: for &lt;'a&gt; fn(&amp;'a Person) -&gt; &amp;'a String = |p: &amp;Person| &amp; p.name;// 闭包返回值必须为引用, 不能把 name move 走
//or ; 参数类型省略了
let name: for&lt;'a&gt; fn(&amp;'a People) -&gt; &amp;'a String = |p| &amp;p.name;



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#闭包作为返回值-or-参数" id="闭包作为返回值-or-参数">闭包作为返回值 or 参数</a></h3>
<h4><a class="header" href="#逃逸闭包-非逃逸闭包" id="逃逸闭包-非逃逸闭包">逃逸闭包 非逃逸闭包</a></h4>
<pre><pre class="playpen"><code class="language-rust">
// Box&lt;Fn()&gt;是一个 trait对象, 
// trait对象是动态分发的，在运行时通过查找虚表( vtable〕来确定调用哪个闭包
fn boxed_closure(c: &amp;mut Vec&lt;Box&lt;Fn()&gt;&gt;){
    let s = &quot;second&quot;;
    c.push(Box::new(|| println!(&quot;first&quot;)));
    // 需要将 s copy 一份, 在方法外使用
    c.push(Box::new(move || println!(&quot;{}&quot;, s)));//逃逸闭包 (escapeclosure): 在函数栈帧结束后才使用的闭包, 如果是跟随函数一起调用的闭包， 则 是非逃逸闭包 (non-escape closure)。
    c.push(Box::new(|| println!(&quot;third&quot;)));
}
fn main(){
    let mut c: Vec&lt;Box&lt;Fn()&gt;&gt; = vec![];
    boxed_closure(&amp;mut c);
    for f in c {
        f(); // first / second / third
    }
}


</code></pre></pre>
<h4><a class="header" href="#闭包作为参数" id="闭包作为参数">闭包作为参数</a></h4>
<pre><code class="language-rs">// 实现 vec.any 条件匹配

// 通过泛型, 实现静态分发
use std::ops::Fn;
trait Any {
    fn any&lt;F&gt;(&amp;self,  f: F) -&gt; bool where
        Self: Sized,//当Any被作为 trait 对象使用时，该方法不能被动态调用, 只能静态分发，这属于一种优化策略
        F: Fn(u32) -&gt; bool;
}
impl Any for Vec&lt;u32&gt; {
    fn any&lt;F&gt;(&amp;self, f: F) -&gt; bool where
    Self: Sized,
   F: Fn(u32) -&gt; bool
   {
       for &amp;x in self {
           if f(x) {
               return true;
           }
       }
       false
   }
}
fn main(){
    let  v = vec![1,2,3];
    let b = v.any(|x| x == 3);
    println!(&quot;{:?}&quot;, b);
}


// 通过将闭包作为 trait 对象的方式, 实现动态分发
// 代码更加简练, 动态分发比静态分发的性能 低 一些, 但完全可以接受
trait Any {
  fn any(&amp;self,  f: &amp;(Fn(u32) -&gt; bool)) -&gt; bool;// &amp;(Fn(u32) -&gt; bool) 即为 trait object
}
impl Any for Vec&lt;u32&gt; {
    fn any(&amp;self, f: &amp;(Fn(u32) -&gt; bool)) -&gt; bool {
        for &amp;x in self.iter() {
            if f(x) {
                return true;
            }
       }
      false
   }
}
fn main(){
   let  v = vec![1,2,3];
   let b = v.any(&amp;|x| x == 3);
   println!(&quot;{:?}&quot;, b);
}

</code></pre>
<h4><a class="header" href="#闭包作为返回值" id="闭包作为返回值">闭包作为返回值</a></h4>
<pre><code class="language-rs">// 作为返回值, 必须使用 trait对象
fn square() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|i| i*i )
}

// error
// 对于编译期无法确定大小的值，不能移动其所有权
// 如果要调用闭包 Box&lt;Fn0nce(i32)-&gt;i32&gt;， 就必须先把 Fn0nce(i32)-&gt;i32 从 Box&lt;T&gt;中移出 来。而此时 Box&lt;T&gt;中的 T无法在编译期确定大小，不能移动所有权，所以就报错
fn square() -&gt; Box&lt;FnOnce(i32) -&gt; i32&gt; {
    Box::new( |i| {i*i })
}
// 正确
// 使用 impl trait 的方式
fn square() -&gt; impl FnOnce(i32) -&gt; i32 {
    |i| {i*i }
}



//返回的闭包还必须使用 move 关键字
//          它表明闭包内所有的捕获都是通过值进行的(是一份拷贝, 是安全独立的)。
//          因为若果没有 move, 闭包是按引用捕获变量，函数结束, 闭包将引用返回, 但是引用指向的数据将被释放, 在闭包中留下无效的引用
//
fn create_fn() -&gt; impl Fn() {
    let text = &quot;Fn&quot;.to_owned();
    move || println!(&quot;This is a: {}&quot;, text)
}
fn create_fnmut() -&gt; impl FnMut() {
    let text = &quot;FnMut&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}
let fn_plain = create_fn();
let mut fn_mut = create_fnmut();
fn_plain();
fn_mut();


</code></pre>
<h4><a class="header" href="#闭包参数中的生命周期" id="闭包参数中的生命周期">闭包参数中的生命周期</a></h4>
<pre><code class="language-rs">trait DoSomething&lt;T&gt; {
    fn do_sth(&amp;self, value: T);
}
// 为&amp;usize类型实现了该 trait
impl&lt;'a, T: Debug&gt; DoSomething&lt;T&gt; for &amp;'a usize {
    fn do_sth(&amp;self, value: T) {
        println!(&quot;{:?}&quot;, value);
    }
}
// 泛型 trait 作为 trait object时需要标注生命周期参数
// error
// 这里生命周期参数让编译器误解: 把 foo 的生命周期和内部 s 的生命周期关联起来, 即在 foo()调用的 生命周期内, s 必须始终有效
//然而 b 内部的 &amp;usize引用 本来应该和 foo 函数没有任何关系
fn foo&lt;'a&gt;(b: Box&lt;DoSomething&lt;&amp;'a usize&gt;&gt;) {
    let s: usize = 10;
    // s 在 foo 函数调用结束后就会被析构，从而&amp;s就会变 成悬垂指针
    b.do_sth(&amp;s) // error[E0597]: `s` does not live long enough
}
// 正确
// 高阶生命周期 (Higher-Ranked Lifetime)语法: for&lt;'f&gt; , 表示此生命周期参数只针对其后面所跟 着 的“对象&quot;
// 这里在 box 内部声明一个周期注释, 标注 &amp;usize, 和 外层的bar 函数无关
fn bar(b: Box&lt;for&lt;'f&gt; DoSomething&lt;&amp;'f usize&gt;&gt;) {
    let s: usize = 10;
    b.do_sth(&amp;s);
}
fn main(){
    let x  = Box::new(&amp;2usize);
    foo(x); // 相当于 let _a = foo(x);
    bar(x);
}

// 模拟闭包的行为
struct Pick&lt;F&gt; {
    data: (u32, u32),// 存储闭包参数 
    func: F, // 存储逻辑行为
}
impl&lt;F&gt; Pick&lt;F&gt;
    // trait限定中使用了 引用类型, 编译器自动为其补齐了生命周期参数
    where F: Fn(&amp;(u32, u32)) -&gt; &amp;u32
    // 显式指定周期参数:
    where F: for&lt;'f&gt; Fn(&amp;'f (u32, u32)) -&gt; &amp;'f u32, // 
{
    // 生命周期参数可省略    
    fn call(&amp;self) -&gt; &amp;u32 {
        (self.func)(&amp;self.data)
    }

    // 若要添加周期参数, 这种是错误的:  
    fn call&lt;'a&gt;(&amp;’a self)一〉&amp;’a u32, //不能让 call方法自身的生命周期和 self.func方法的生命周期相关联, 因为闭包 的捕获引用是从外部环境获取的，和 call 方法没有关系

    
}
fn max(data: &amp;(u32, u32)) -&gt; &amp;u32 {
    if data.0 &gt; data.1{
        &amp;data.0
    }else{
        &amp;data.1
    }

}
fn main() {
   let elm = Pick { data: (3, 1), func: max };
   println!(&quot;{}&quot;, elm.call());
}

</code></pre>
<h3><a class="header" href="#迭代器" id="迭代器">迭代器</a></h3>
<h4><a class="header" href="#什么是迭代器" id="什么是迭代器">什么是迭代器</a></h4>
<pre><code class="language-rs">
/// 迭代器
/// 
/// 迭代器是惰性的, 调用方法使用迭代器前, 不会有任何效果
/// 
/// 每个迭代器都实现 Iterator trait
/// 
/// trait Iterator {
///     // 这里为什么不使用 泛型呢? 若用泛型语法, 会造成这样的结果: 使用者可以通过泛型, 为一个 struct 实现多种 Iterator trait
///     // 调用时, 编译器无法知道使用哪个 trait 实现
///     type Item;// 关联元素类型
///     // 需要实现的方法
///     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
/// }
/// 
/// for 结构会使用 .into_iterator() 方法将一些集合类型 转换为迭代器
// 
// 
// 外部迭代器 (External Iterator): 在容器外部, 可以控制整个迭代过程 (如手动调用 next() 获取下一个元素)
// 内部迭代器 (internal Iterator):通过法代器自身来控制法代下一个元素，外部无法干预, 一旦开始, 必须全部迭代完毕才能结束
// 
// 外部迭代器
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    // for循环是一个典型的外部迭代器
    // 其实是一个语法糖, 底层实现是 into_iter方法声明了一个可变法代器 iterator
    for i in v {
        println!(&quot;{}&quot;, i);
    }
}
// 等价于
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    {  // 等价于for循环的scope
        let mut _iterator = v.into_iter();
        loop {
            match _iterator.next() {
                Some(i) =&gt; {
                    println!(&quot;{}&quot;, i);
                }
               None =&gt; break,
           }
       }
   }
}

// 自定义内部迭代器
trait InIterator&lt;T: Copy&gt; {
    fn each&lt;F: Fn(T) -&gt; T&gt;(&amp;mut self, f: F);
}
impl&lt;T: Copy&gt; InIterator&lt;T&gt; for Vec&lt;T&gt; {
    fn each&lt;F: Fn(T) -&gt; T&gt;(&amp;mut self, f: F) {
        let mut i = 0;
        while i &lt; self.len() {
            self[i] = f(self[i]);
            i += 1;
        }
    }
}
fn main(){
    let mut v = vec![1,2,3];
    v.each(|i| i * 3);
    assert_eq!([3, 6, 9], &amp;v[..3]);
}

</code></pre>
<p>闭包最常见的应用场景是， 在遍历集合容器中的元素的同时，按闭包内 指定的逻辑进行操作, 即迭代器</p>
<h4><a class="header" href="#iterator-trait" id="iterator-trait">Iterator trait</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// 
fn iter_demo() {

// 
// 获取迭代器时, 根据对源容器的处理, 可以分为几类迭代器:
// 
// - Intolter，转移所有权，对应 self。
// - Iter， 获得不可变借用 ， 对应&amp;self。
// - IterMut，获得可变借用，对应&amp; mut self。
// 
// Iter和 IterMut迭代器的典型应用就是 slice 
// 特殊的: Drain 迭代器, String类型和 HashMap 特有, 可以迭代删除指定范围内的值


// 相应的就有多个获取迭代器的方法:
// 
// iter() 迭代出引用, 迭代出的类型为 &amp;T
// iter_mut() 迭代出可变引用, 类型为  &amp;mut T
// into_iter() 迭代出值, 不是引用, 元素所有权变更 (推荐)
// 
//size_hint() (usize, Option&lt;usize&gt;)，此元组表示迭代器剩余长度的边界信息, 元素 1: 下限, 元素 2: 上限, 默认返回 (0, None)
//       用来和容器合作时, 精确的拓展容器容量, 从而避免不必要的容量检查，提高性能
//          对于数组, 上下限是相同的, 代表迭代器当前指针到末尾指针的距离
// 


    let mut v = vec![1,2,3];
    for ele in v.iter() { //等同于
        println!(&quot;{}&quot;, ele);
    }

    // 迭代出的类型为 &amp;i32
    let mut it = v.iter();
    for _ in 0..3 {//`for` 遍历 `Iterator` 直到返回 `None`，每个 `Some` 值都被解包（unwrap），然后绑定给一个变量, 这里是 &quot;_&quot;
        println!(&quot;{}&quot;, it.next().unwrap());// 需要 it 可变, 解引用可省略
    }

    // 迭代出可变引用
    //
    let mut it_mut = v.iter_mut();// 需要 v 为 可变
    let ele_first = it_mut.next().unwrap();
    *ele_first = 100; // 需要写操作, 先解引用
    println!(&quot;v = {:?}&quot;, v); // [100,2,3]

    // 迭代器的上下限, 表示
    // 
    let a : [i32; 3]= [1, 2, 3];
    let mut iter = a.iter();
    assert_eq!((3, Some(3)), iter.size_hint());
    iter.next();//的剩余长度就会减少， 直到减为 0为止
    assert_eq!((2, Some(2)), iter.size_hint());
    // 使用迭代器追加字符串
    let mut message = &quot;Hello&quot;.to_string(); 
    message . extend (&amp;[' ', 'R', 'u', 's', 't']) ; // 这个方法里面就用到了 size_hint 用于 String 扩容
    assert_eq ! (” Hello Rust” ,&amp; message );


    // Intolterator trait
    
    let arr = [1, 2, 3];
    // 并没有为[T]类型实现 IntoIterator，需要调用 iter() 生成迭代器
    for i in arr.iter() {
        println!(&quot;{}&quot;, *i);
    }
    // 为&amp;’a [T]和&amp;’a mut [T]类型实现 了 Intoiterator
    for i in &amp;arr {
        println!(&quot;{}&quot;, *i);
    }


    // 
    // 求和
    let total: i32 = v.iter().sum();
    println!(&quot;total = {}&quot;, total);

    // `take(n)` 方法提取 `Iterator` 的前 `n` 项。
    //

    // `skip(n)` 方法移除前 `n` 项，从而缩短了 `Iterator` 
    //

    
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#迭代器适配器-收集器-函数式风格" id="迭代器适配器-收集器-函数式风格">迭代器适配器 收集器 函数式风格</a></h4>
<pre><code class="language-rs">
    // 
    // 迭代器的适配器, 适配器都会返回新的集合
    // 
    // • Map，通过对原始注代器中的每个元素调用指定 闭包来产生一个新的迭代器。
    // • Chain，通过连接两个迭代器来创建一个新的迭代器。
    // • Cloned，通过拷贝原始迭代器中全部元素来创建新的迭代器。
    // • Cycle，创建一个永远循环迭代的迭代器，当完毕后 ，再返回第一个元素开始法代。
    // • Enumerate，创建一个包含计数的迭代器，它会返回 一个元组(i,val)， 其中 i 是 usize 类型 ，为迭代的 当前索 引， val 是迭代器返回 的值 。
    // • Filter，创建一个基于谓词判断式( predicate，产生布尔值的表达式)过滤元素的迭代器 。
    // • FlatMap，创建一个类似 Map 的结构的法代器，但是其中不会含有任何嵌套。
    // • FilterMap，相当于 Filter和 Map两个法代器依次使用后的效果。
    // • Fuse，创建一个可 以快速结束遍历 的迭代器。在遍历迭代器时，只 要返回过一次 None,那么之后所有的遍历结果都为 None。该迭代器适配器可以用于优化。
    // • Rev，创 建一 个可以反向遍历的迭代器 
    //
    // 
    
    // map, 
    // Map是一个泛型结构体，它只有两个成员字段，一个是iter， 一个f， 分别存 储的是迭代器和传入的闭包
    // 实现了 Iterator trait
    let a = [1, 2, 3];
    let mut iter =a.into_iter() .map(|x| 2 * x);

    let arr1 = [1, 2, 3, 4, 5];
    let c1 = arr1.iter().map(|x| 2 * x).collect::&lt;Vec&lt;i32&gt;&gt;();
    assert_eq!(&amp;c1[..], [2, 4, 6, 8, 10]);
    let arr2 = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;h&quot;];
    let c2 = arr2.iter().filter_map(|x| x.parse().ok()).collect::&lt;Vec&lt;i32&gt;&gt;();
    assert_eq!(&amp;c2[..], [1,2,3]);
    let arr3 = ['a', 'b', 'c'];
   for (idx, val) in arr3.iter().enumerate() {
       println!(&quot;idx: {:?}, val: {}&quot;, idx, val.to_uppercase());
   }
    
    let v = vec![1,2,3];
    let scaled : Vec&lt;i32&gt; = v.iter().map(|&amp;x| x * 10).collect(); // 返回新的 vec, 原始 vec 不受影响, x 不加&amp;亦可
    println!(&quot;scaled = {:?}&quot;, scaled);
    let scaled1: Vec&lt;_&gt; = v.iter_mut().map(|&amp;mut x| x* 10).collect(); //等效, 返回新的 vec, 不改变原始 v
    println!(&quot;scaled1 = {:?}&quot;, scaled1);
    println!(&quot;v = {:?}&quot;,v);//不变
    let plused: Vec&lt;_&gt; = scaled.into_iter().map(|x| x +1).collect();// 获取scaled 所有权,  直接在原始值上修改
    println!(&quot;plused = {:?}&quot;, plused);

    // filter
    let filtered: Vec&lt;_&gt; = v.into_iter().filter(|&amp;x| x &gt; 3).collect();// 直接在原始 vec 上修改, v 所有权失效 // 存疑, 为什么需要 &amp;x
    println!(&quot;filtered = {:?}&quot;, filtered); // [100]
    println!(&quot;v = {:?}&quot;, v); // 错误, into_iter() 使得 v 失去值得所有权
    

    // 逆序
    let mut iter= a.iter().rev()
    iter.next();//从反向开始迭代
    // or
    // 通过 普通迭代器的 next_back() 方法反向迭代
    // next() 和 next_back() 有各自独立的指针, 互不影响, 但是当指针相遇时, 就迭代不出值了, 返回 none




// 收集器
// 
    // any 谓词, 判断
    // 闭包参数为 引用
    let v = vec![1,2,3];
    let contain = v.iter().any(|&amp;x| x == 2);
    println!(&quot;contains 2?  : {}&quot;, contain);
    let contain = v.into_iter().any(|x| x == 3);
    println!(&quot;contains 3?  : {}&quot;, contain);
    let a = [1, 2, 3];
    assert_eq!(a.iter().any(|&amp;x| x != 2), true);// 存在不为 2 的元素
    let arr = [1, 2, 3];
    let result1 = arr.iter().any(|&amp;x| x != 2);
    let result2 = arr.iter().any(|x| *x != 2);
    // error:
    // the trait bound `&amp;{integer}: std::cmp::PartialEq&lt;{integer}&gt;` is not satisfied
    let result2 = arr.iter().any(|x| x != 2);
    assert_eq!(result1, true);
    assert_eq!(result2, true);

    // fold
    // 闭包参数为引用
    let arr = vec![1, 2, 3];
    let sum1 = arr.iter().fold(0, |acc, x| acc + x);
    let sum2 = arr.iter().fold(0, |acc, x| acc + *x);
    let sum3 = arr.iter().fold(0, |acc, &amp;x| acc + x);
    let sum4 = arr.into_iter().fold(0, |acc, x| acc + x);
    assert_eq!(sum1, 6);
    assert_eq!(sum2, 6);
    assert_eq!(sum3, 6);
   assert_eq!(sum4, 6);

    // find 查找
    let v = vec![1,2,3];
    let find2 = v.iter().find(|&amp;&amp;x| x == 2).unwrap();
    println!(&quot;find2 = {}&quot;, find2);//2
    let find3 = v.into_iter().find(|&amp;x| x == 3).unwrap();
    println!(&quot;find2 = {}, find3 = {}&quot;, find2, find3);// 出错
    println!(&quot;find3 = {}&quot;, find3);






    // 函数式风格
    //
    let upper = 3;
    let sum: u32 =(0..).map(|n| n * n)             // 所有自然数取平方
             .take_while(|&amp;n| n &lt; upper) // 取小于上限的
             .filter(|&amp;n| is_odd(n))     // 取奇数
             .fold(0, |sum, i| sum + i); // 最后加起来
    println!(&quot;sum = {}&quot;, sum);

    // 处理迭代中的错误
    //
    //
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let possible_numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .filter_map(Result::ok) // 过滤出成功的result
        .collect();
    println!(&quot;Results: {:?}&quot;, possible_numbers);
    // 
    // 另外的处理方式:
    //Result 实现了 FromIter, Vec&lt;Result&lt;T, E&gt;&gt;可以转为 Result&lt;Vec&lt;T&gt;, E&gt;, 一旦找到一个 Result::Err ，遍历就被终止
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
    //
    //分组收集
    //
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre>
<h4><a class="header" href="#自定义迭代器" id="自定义迭代器">自定义迭代器</a></h4>
<pre><code class="language-rs">
    //
    // 自定义 iterator
    //
    struct Counter {
        count: u32,
        max: u32,
    }
    impl Counter {
        fn new(max: u32) -&gt; Self {// new 方法不能放到下面的 iterator 实现中
            Counter {
                count: 0,
                max
            }
        }
    }
    impl Iterator for Counter {
        type Item = u32;
        fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
            self.count += 1;
            if self.count &lt;= self.max {
                Some(self.count)
            } else {
                None
            }
        }
    }
    let mut counter = Counter::new(5);
    loop {
        if let Some(count) = counter.next() {
            println!(&quot;count = {}&quot;, count);
        } else {
            break;
        }
    }



</code></pre>
<h4><a class="header" href="#自定义适配器-收集器" id="自定义适配器-收集器">自定义适配器 收集器</a></h4>
<pre><code class="language-rs">
// 第三方包Itertools 亦可实现自定义适配器


use std::iter::FromIterator;
#[derive(Debug)]
struct MyVec(Vec&lt;i32&gt;);
impl MyVec {
    fn new() -&gt; MyVec {
        MyVec(Vec::new())
    }
    fn add(&amp;mut self, elem: i32) {
        self.0.push(elem);
   }
}
// 实现FromIterator就可以拥有Collect的能力
impl FromIterator&lt;i32&gt; for MyVec {
   fn from_iter&lt;I: IntoIterator&lt;Item = i32&gt;&gt;(iter: I) -&gt; Self {
       let mut c = MyVec::new();
       for i in iter {
           c.add(i);
       }
       c
   }
}
fn main() {
   let iter = (0..5).into_iter();
//    直接调用 MyVec::from_iter方法和使用 collect方法的效果是一样的。
   let c = MyVec::from_iter(iter);
   assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
   let iter = (0..5).into_iter();
   let c: MyVec = iter.collect();
   assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
   let iter = (0..5).into_iter();
   let c = iter.collect::&lt;MyVec&gt;();
   assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
}


// 自定义适配器
// 按指定步数迭代
#[derive(Clone, Debug)]
#[must_use = &quot;iterator adaptors are lazy and do nothing unless consumed&quot;]
pub struct Step&lt;I&gt; {
    iter: I,
    skip: usize,
}
impl&lt;I&gt; Iterator for Step&lt;I&gt;
    where I: Iterator,
{
    type Item = I::Item;
    fn next(&amp;mut self) -&gt; Option&lt;I::Item&gt; {
        let elt = self.iter.next();
        if self.skip &gt; 0 {
            self.iter.nth(self.skip - 1);
        }
       elt
    }
}
// 产生 Step适配器
pub fn step&lt;I&gt;(iter: I, step: usize) -&gt; Step&lt;I&gt;
    where I: Iterator,
{
    assert!(step != 0);
    Step {
        iter: iter,
            skip: step - 1,
    }
}
// 定义了一个继承自 Iterator 的子 trait
pub trait IterExt: Iterator {
    fn step(self, n: usize) -&gt; Step&lt;Self&gt;
        where Self: Sized,
    {
        step(self, n)
    }
}
impl&lt;T: ?Sized&gt; IterExt for T where T: Iterator {}
fn main() {
    let arr = [1,2,3,4,5,6];
    let sum = arr.iter().step(2).fold(0, |acc, x| acc + x);
    assert_eq!(9, sum); // [1, 3, 5]
}




</code></pre>
<h2><a class="header" href="#条件循环" id="条件循环">条件循环</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>fn condition_loop() {
    let a = 1;
    let b;
    if a &gt; 0 {
        b = 1
    } else if a &lt; 0 {
        b = -1;
    } else {
        b = 0;
    }
    println!(&quot;b = {}&quot;, b);

    // if 用在 let 句子中, 返回值类型相同
    let c = if a &gt; 0 { true } else { false };
    println!(&quot;c = {}&quot;, c);

    // while 循环
    // 死循环不要使用 while true, 因为若在 循环体中 return xx; 编译器会认为无效, 编译器只会认为 while true 会返回空即 &quot;()&quot;
    let mut d = 3;
    while d &gt; 0 {
        println!(&quot;d = {}&quot;, d);
        d -= 1;
    }

    // for 循环
    let a = [3, 4, 5];
    let mut i = 0;
    for ele in a.iter() {
        println!(&quot;a[{}] = {}&quot;, i, ele);
        i += 1;
    }

    for i in 0..3 {// 不包括尾巴, 0..3 是一个 Range 类型, 是一个 iterator
        println!(&quot;a[{}] = {}&quot;, i, a[i]);
    }

    //loop 循环 死循环
    let s = ['R', 'U', 'N', 'O', 'O', 'B'];
    let mut i = 0;
    loop {
        let ch = s[i];
        if ch == 'O' {
            break;
        }
        i += 1;
    }
    println!(&quot;O index = {}&quot;, i);

    // 带返回值的 loop 循环, 用break
    let mut i = 0;
    let location = loop {
        if s[i] == 'O' {
            break i;
        }
        i += 1;
    };
    println!(&quot;O index = {}&quot;, location);
}


<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#泛型" id="泛型">泛型</a></h2>
<h3><a class="header" href="#单态化" id="单态化">单态化</a></h3>
<p>单态化是编译器 进行静态分发 的一种策略, 编译器要将一个泛型函数生 成多个具体类型对应的函数</p>
<p>好处是性能好 ， 没有运行 时开销;缺点是容易造成编译后生成的二进制文件膨胀 (如 果变得太 大，可以根 据具体的情况重构代码来解决问题)</p>
<h3><a class="header" href="#多重约束-加号" id="多重约束-加号">多重约束 加号</a></h3>
<p>trait Bound</p>
<p>包含 trait 限定的泛型属于静态分发，在编译期通过单态化分别生成具体类型的实例，所以调用 trait 限定中的方法也都是运行时零成本的，因为不需要在运行时再进行方法查找 。</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// 泛型
/// 
/// 
fn generic() {

    fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T { // 多重约束使用 + 号 (且的关系)
        let mut largest = list[0];
        for &amp;ele in list.iter() {
            if largest &lt; ele {
                largest = ele;
            }
        }
        largest
    }

    use std::ops::Add;
    fn sum&lt;T: Add&lt;T, Output=T&gt;&gt;(a: T, b: T) -&gt; T{
        a + b
    }




    // 结构体中的泛型
    //
    #[derive(Debug)]
    struct Point&lt;T&gt; {
        x: T,
        y: T,
    }
    impl&lt;T&gt; Point&lt;T&gt; {
        fn x(&amp;self) -&gt; &amp;T {
            &amp;self.x
        }
    }

    //有条件的实现方法
    //
    //
    struct A&lt;T&gt; {}
    // 这段代码声明了 A&lt;T&gt; 类型必须在 T 已经实现 B 和 C 特性的前提下才能有效实现此 impl 块
    impl&lt;T: B + C&gt; A&lt;T&gt; {
        fn d(&amp;self) {}
    }

    // 使用 where 重构 trait 约束
    fn foo&lt;T, K, R&gt;(a: T, b: K, c: R) where T: A, K: B+C, R: D {. .}



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#默认泛型参数-and-关联类型" id="默认泛型参数-and-关联类型">默认泛型参数 and 关联类型</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>    // 默认泛型参数, 如 std中的 Add trait:
    // (为什么要使用关联类型的方式而不在泛型中指定两个参数呢?
    //      使用单泛型参数更灵活, 可传可不传, 使得代码更精简)
    //
    // sometype 表示符号右边的类型
    trait Add&lt;SomeType=Self&gt; {// Self 表示为泛型参数指定默认值 Self (Self是每个trait都带有的隐式类型参数, 代表实现当前 trait 的具体类型); 若实现 add 方法没有指定具体泛型, 则默认为 Self
        type Output; // 关联类型
        fn add(self, xx: SomeType) -&gt; Self::Output ;
    }

    // string 也实现了 Add trait
    let s  = &quot;hello&quot;.to_string();
    let ns = s + &quot;world&quot;;

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#空约束" id="空约束">空约束</a></h3>
<pre><code class="language-rs">


    // 空约束
    struct Cardinal;
    struct BlueJay;
    struct Turkey;
    trait Red {}
    trait Blue {}
    impl Red for Cardinal {}
    impl Blue for BlueJay {}
    // 这些函数只对实现了相应的 trait 的类型有效。
    fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;red&quot; }
    fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;blue&quot; }
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;
    // 由于约束，`red()` 不能作用于 blue_jay （蓝松鸟），反过来也一样。
    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));
    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));
    println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));// 错误


</code></pre>
<h3><a class="header" href="#turbofish-操作符-and-返回值自动推导" id="turbofish-操作符-and-返回值自动推导">turbofish 操作符 and 返回值自动推导</a></h3>
<pre><code class="language-rs">
    // turbofish操作符 类型推导
    // 
    // 当 Rust 无法从上下文中自动推导出类型的时候, 可以手动指定类型
    let x = &quot;1&quot;;
    println!(”{:?}”, x.parse() .unwrap()) //error, parse() 是个泛型方法
    // 手动指定类型 rust 会自动类型推导
    let intx:i32= x.parse().unwrap();
    // 或者, 通过 turbofish 操作符
    // 语法: ::&lt;T&gt;
    assert_eq!( x.parse::&lt;i32&gt;().unwrap(), 1)




}


</code></pre>
<h2><a class="header" href="#trait" id="trait">trait</a></h2>
<h3><a class="header" href="#trait-基本使用" id="trait-基本使用">trait 基本使用</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>///特性（trait）概念接近于 Java 中的接口（Interface）
/// 
fn trait_demo() {
    trait Descriptive {
        fn describe(&amp;self) -&gt; String;

        // 默认 trait, 类似 java 接口默认实现
        fn fn1(&amp;self) -&gt; String {
            String::from(&quot;default impl trait&quot;)
        }
    }

    struct Person {
        name: String,
        age: u8
    }
    // user.show 等价于 User: :show(&amp;user)这样的 函数调用
    impl Descriptive for Person {
        fn describe(&amp;self) -&gt; String {
            format!(&quot;{} {}&quot;, self.name, self.age)
        }
    }
    let p = Person {
        name: String::from(&quot;xiaoyu&quot;),
        age: 11
    };
    println!(&quot;{}&quot;, p.describe());
    println!(&quot;{}&quot;, p.fn1());


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#孤儿规则" id="孤儿规则">孤儿规则</a></h3>
<p>orphan rule: 要为 struct b 实现某个 trait a, 则 a, b 至少有一个必须在当前 crate 中定义 (不能a, b 都是在别处定义的比如都是在 std 中定义的)</p>
<p>目的: 防止对别人 crate 中的类型行为进行破坏性改写</p>
<pre><code class="language-rs">// 如 要为 u32 类型实现  add, 使得可以加上 u64 类型数字
// 直接实现 标准库中的 Add 不行, 因为 u32 和 Add 都在其他 crate 中

// 需要自己定义 在当前 crate : ˚Add trait
// 当然，除了在本地定义 Addtrait这个方法，还可以在本地创建一个新的类型，然后为此 新类型实现Add


// 局限性
// 对于一些本地类型， 如果将其放到一些容器中，比如Rc&lt;T&gt;或Option&lt;T&gt;， 那么这些本地类型就会变成远程类型 (因为这些容器类型都是在标准库中定义的 ， 而非本地。)
// rust 使用 #[fundamental]的属性标识，来为特定的trait 规避孤儿限制
//  Box&lt;T&gt;，还有 Fn、 FnMut、 FnOnce、 Sized 等都上了#[fundamental]属性
</code></pre>
<h3><a class="header" href="#特化-specialization" id="特化-specialization">特化 Specialization</a></h3>
<pre><code class="language-rs">// 问题: 重叠规则：不能为重叠的类型实现同一个trait 
impl&lt;T&gt; AnyTrait for T
impl&lt;T&gt; AnyTrait for T where T: Copy // Copy 和上面的 T 重叠了
impl&lt;T&gt; AnyTrait for String

// 解决: 特化 (类似 java 中的方法重写/覆盖)
#![feature(specialization)]
struct Diver&lt;T&gt; {
    inner: T,
}
trait Swimmer {
    // 带有默认实现的 方法
    fn swim(&amp;self) {
        println!(&quot;swimming&quot;)
    }
}
// 先为 Diver&lt;T&gt;实现该 trait
impl&lt;T&gt; Swimmer for Diver&lt;T&gt; {}

// 为Diver&lt;&amp;’staticstr&gt;实现了 该 trait (也就是 特殊类型, 特殊处理)
impl Swimmer for Diver&lt;&amp;'static str&gt; {
    fn swim(&amp;self) {
        println!(&quot;drowning, help!&quot;)
    }
}

let x = Diver::&lt;&amp;'static str&gt; { inner: &quot;Bob&quot; };
x.swim();
let y = Diver::&lt;String&gt; { inner: String::from(&quot;Alice&quot;) };
y.swim();

</code></pre>
<h3><a class="header" href="#trait-作为参数-需要-impl-前缀" id="trait-作为参数-需要-impl-前缀">trait 作为参数 需要 impl 前缀</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>    //
    // 特性做参数
    //
    fn print(p: impl Descriptive) {
        println!(&quot;{}&quot;, p.describe())
    }
    //
    // 写法2: (风格类似泛型的语法糖)
    fn output&lt;T: Descriptive&gt;(object: T) {
       println!(&quot;{}&quot;, object.describe());
    }
    fn output_two&lt;T: Descriptive&gt;(arg1: T, arg2: T) {
        println!(&quot;{}&quot;, arg1.describe());
        println!(&quot;{}&quot;, arg2.describe());
    }


    //
    //
    //特性作类型表示时如果涉及多个特性，可以用 + 符号
    fn notify(item: impl Summary + Display)
    fn notify&lt;T: Summary + Display&gt;(item: T)
    //
    //复杂的实现关系可以使用 where 关键字简化
    //如: 
    fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U)
    //可以简化成：
    fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
        where T: Display + Clone,
            U: Clone + Debug
    //
    // 取最大值
    //
    trait Comparable {
        fn compare(&amp;self, object: &amp;Self) -&gt; i8;
    }
    fn max&lt;T: Comparable&gt;(array: &amp;[T]) -&gt; &amp;T {
        let mut max_index = 0;
        let mut i = 1;
        while i &lt; array.len() {
            if array[i].compare(&amp;array[max_index]) &gt; 0 {
                max_index = i;
            }
            i += 1;
        }
        &amp;array[max_index]
    }
    impl Comparable for f64 {
        fn compare(&amp;self, object: &amp;f64) -&gt; i8 {
            if &amp;self &gt; &amp;object { 1 }
            else if &amp;self == &amp;object { 0 }
            else { -1 }
        }
    }
    let arr = [1.0, 3.0, 5.0, 4.0, 2.0];
    println!(&quot;maximum of arr is {}&quot;, max(&amp;arr));



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#trait-作为-返回值-返回动态类型" id="trait-作为-返回值-返回动态类型">trait 作为 返回值 返回动态类型</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>     //特性做返回值
    //
    //
    fn person() -&gt; impl Descriptive {
        Person {
            name: String::from(&quot;Cali&quot;),
            age: 24
        }
    }

    // 在同一个函数中所有可能的返回值类型必须完全一样
    //如果希望返回不同的struct, 使用  Box&lt;dyn Animal&gt; 作为返回值 ----- 多态
// 
    // 错误, 因为 A, B 虽然都实现了 Descriptive, 但是 A B 是不同的类型
    fn some_function(bool bl) -&gt; impl Descriptive {
        if bl {
            return A {};
        } else {
            return B {};
        }
    }
    //
    // 那么如何返回不同的 struct?
    //使用 Box&lt;dyn xxx&gt;, box 是一种数据结构, 效果类似引用,
    //
    fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {// 返回类型内存大小确定了, 编译可以通过
        if random_number &lt; 0.5 {
            Box::new(Sheep {})
        } else {
            Box::new(Cow {})
        }
    }


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#派生-trait-和-自动推导-trait实现" id="派生-trait-和-自动推导-trait实现">派生 trait 和 自动推导 trait实现</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
    

<span class="boring">fn main() {
</span>    // 推导 派生 trait
    // 下面以下是可以自动推导的 trait
   /*
    Eq, PartialEq, Ord, PartialOrd (比较类的 trait)
    Clone, 用来从 &amp;T 创建副本 T。当处理资源时，默认的行为是在赋值或函数调用的同时将它们转移。但是我们有时候也需要 把资源复制一份。
    Copy，使类型具有 “复制语义”（copy semantics）而非 “移动语义”（move semantics）。
    Hash，从 &amp;T 计算哈希值（hash）。
    Default, 创建数据类型的一个空实例。
    Debug，使用 {:?} formatter 来格式化一个值
   */

    #[derive(Debug, Clone, Copy)]
    struct Nil;

    // `Centimeters`，可以比较的元组结构体
    #[derive(PartialEq, PartialOrd)]
    struct Centimeters(f64);

    // `Inches`，可以打印的元组结构体
    #[derive(Debug)]
    struct Inches(i32);
    impl Inches {
        fn to_centimeters(&amp;self) -&gt; Centimeters {
            let &amp;Inches(inches) = self;

            Centimeters(inches as f64 * 2.54)
        }
    }
    let foot = Inches(12);
    println!(&quot;One foot equals {:?}&quot;, foot);
    let meter = Centimeters(100.0);
    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };
    println!(&quot;One foot is {} than one meter.&quot;, cmp);


    // `Seconds`，不带附加属性的元组结构体
    struct Seconds(i32);
    let _one_second = Seconds(1);
    // 报错：`Seconds` 不能打印；它没有实现 `Debug` trait
    println!(&quot;One second looks like: {:?}&quot;, _one_second);
    // 报错：`Seconds`不能比较；它没有实现 `PartialEq` trait
    let _this_is_true = (_one_second == _one_second);

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#运算符重载" id="运算符重载">运算符重载</a></h3>
<p>操作符重载</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>    //
    //
    // 很多运算符可以通过 trait 来重载
    //这些运算符可以根据它们的 输入参数来完成不同的任务。这之所以可行，
    //是因为运算符就是方法调用的语法糖。例 如，a + b 中的 + 运算符会调用 add 方法（也就是 a.add(b)）。这个 add 方 法是 Add trait 的一部分
    // 
    // Add trait  重载 + 运算符
    //
    /// Deref trait 重载解引用符号, 就是 &quot;*&quot; 号

    //
    //在 std::ops 下有全部重载的 trait
    // 在std::cmp 下则是比较操作的操作符
    //
    //
    // 例子: 对象排序
    //
    // 有四个Trait : Ord、PartialOrd 、Eq 和 PartialEq  。
    //
    use std::cmp::{Ord, PartialOrd, PartialEq, Ordering};
    #[derive(Debug)]
    struct Employee {
        name : String,
        salary : i32,
    }
    impl Ord for Employee {
        fn cmp(&amp;self, rhs: &amp;Self) -&gt; Ordering {
            self.salary.cmp(&amp;rhs.salary)
        }
    }
    impl PartialOrd for Employee {
        fn partial_cmp(&amp;self, rhs: &amp;Self) -&gt; Option&lt;Ordering&gt; {
            Some(self.cmp(rhs))
        }
    }
    impl Eq for Employee {
    }
    impl PartialEq for Employee {
        fn eq(&amp;self, rhs: &amp;Self) -&gt; bool {
            self.salary == rhs.salary
        }
    }

    //使用
    let mut v = vec![
        Employee {name : String::from(&quot;Bob&quot;),     salary: 2048},
        Employee {name : String::from(&quot;Alice&quot;),   salary: 3208},
        Employee {name : String::from(&quot;Tom&quot;),     salary: 2359},
        Employee {name : String::from(&quot;Jack&quot;),    salary: 4865},
        Employee {name : String::from(&quot;Marray&quot;),  salary: 3743},
        Employee {name : String::from(&quot;Hao&quot;),     salary: 2964},
        Employee {name : String::from(&quot;Chen&quot;),    salary: 4197},
    ];
    //用for-loop找出薪水最多的人
    let mut e = &amp;v[0];
    for i in 0..v.len() {
        if *e &lt; v[i] { 
            e = &amp;v[i]; 
        }
    }
    println!(&quot;max = {:?}&quot;, e);
    //使用标准的方法
    println!(&quot;min = {:?}&quot;, v.iter().min().unwrap());
    println!(&quot;max = {:?}&quot;, v.iter().max().unwrap());
    //使用标准的排序方法
    v.sort();
    println!(&quot;{:?}&quot;, v);

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#trait-继承" id="trait-继承">trait 继承</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    // 
    //
    trait Person1 {
        fn name(&amp;self) -&gt; String;
    }
    // Student is a supertrait of Person.
    // Implementing Student requires you to also impl Person.
    trait Student: Person1 {
        fn university(&amp;self) -&gt; String;
    }
    trait Programmer {
        fn fav_language(&amp;self) -&gt; String;
    }
    trait CompSciStudent: Programmer + Student {
        fn git_username(&amp;self) -&gt; String;
    }
    fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
        format!(
            &quot;My name is {} and I attend {}. My Git username is {}&quot;,
            student.name(),
            student.university(),
            student.git_username()
        )
    }
    //
    //
    // 菱形继承问题: 某个 struct 实现两个 trait, 需要实现两个同名方法
    //
    // 完全限定语法
    &lt;Descriptive as Person&gt;::xxx_fn() //类似于强制转换
    //
    // 看例子
    trait UsernameWidget {
        fn get(&amp;self) -&gt; String;
    }
    trait AgeWidget {
        fn get(&amp;self) -&gt; u8;
    }
    struct Form {
        username: String,
        age: u8,
    }
    impl UsernameWidget for Form {
        fn get(&amp;self) -&gt; String {
            self.username.clone()
        }
    }
    impl AgeWidget for Form {
        fn get(&amp;self) -&gt; u8 {
            self.age
        }
    }
    let form = Form{
        username: &quot;rustacean&quot;.to_owned(),
        age: 28,
    };
    // error, &quot;multiple `get` found&quot;. Because, after all, there are multiple methods named `get`.
    println!(&quot;{}&quot;, form.get());
    //ok
    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);
    assert_eq!(&quot;rustacean&quot;.to_owned(), username);
    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);
    assert_eq!(28, age);
    

}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#静态分发-动态分发" id="静态分发-动态分发">静态分发 动态分发</a></h3>
<p>imp! Trait代表静 态分发 ， dyn Trait 代表动态分发 。</p>
<pre><code class="language-rs">      trait Fly {
        fn can_fly(&amp;self) -&gt; bool;
    }
    struct Duck;
    struct Pig;
    impl Fly for Duck {
        fn can_fly(&amp;self) -&gt; bool {
            true
        }
    }
    impl Fly for Pig {
        fn can_fly(&amp;self) -&gt; bool {
            false
        }
    }
    // 使用泛型, 定义静态分发的函数
    // 编译阶段, 泛型已经被展开 为具体类型的代码, 没有抽象开销
    // 可以使用 impl trait 改写
    fn fly_static&lt;T: Fly&gt;(t: &amp;T) -&gt; bool {
        t.can_fly()
    }
    // 使用 dyn 定义动态分发的函数
    // 运行期决定到底是什么类型, 有额外开销
    fn fly_dyn(t: &amp;dyn Fly) -&gt; bool { // 抽象类型是 trait object, 是有要求的
        t.can_fly()
    }

    let pig = Pig;
    let duck = Duck;
    println!(&quot;{}&quot;, fly_static::&lt;Pig&gt;(&amp;pig));
    println!(&quot;{}&quot;, fly_dyn(&amp;duck));
</code></pre>
<h3><a class="header" href="#抽象类型" id="抽象类型">抽象类型</a></h3>
<h4><a class="header" href="#trait对象" id="trait对象">trait对象</a></h4>
<pre><code class="language-rs">// AbstractType ExistentialType
// 相对于具体类型而言，抽象类型无法直接实例化， 但是它的每个实例都 是具体类型的实例
// 编译器可能无法确定其确切的功能和所占的空间大 小 。 所以 Rust 目前有两种方法来处理抽象类型: trait 对象和 impl Trait

// 方式 1: trait 对象
#[derive(Debug)]
struct Foo;
trait Bar {
    fn baz(&amp;self);
}
impl Bar for Foo {
    fn baz(&amp;self) { println!(&quot;{:?}&quot;, self) }
}
fn static_dispatch&lt;T&gt;(t: &amp;T) where T:Bar {
    t.baz();
}
// 动态分发, 有性能开销
fn dynamic_dispatch(t: &amp;Bar) { // 这里参数是一个 trait object, 无法确定大小, 必须使用 引用 &amp; or box
    t.baz();
}
let foo = Foo;
static_dispatch(&amp;foo);
dynamic_dispatch(&amp;foo);

// 为什么 将 trait对象称为动态 分发?
// 
// std 中  为 trait object 定义了一个 struct
// 包含连个指针:
// 1. data ptr
//          指向 类型数据
// 2. vtable ptr
//          指向 virtual table (cpp 中的概念), 就是一个结构体, 包含 析构函数, 大小, 方法...
// 
// 在编译期 ， 编译器只知道 TraitObject 包含指 针 的信息 ， 并且指针的大 小 也是确定的 ，并 不知道 要 调用哪个 方法
//在运行期 ， 当有 trait_object.method()方法被调 用时， TraitObject 会 根据虚表指针从虚表中查出正确的指针，然后再进行动态调用 

</code></pre>
<h4><a class="header" href="#trait对象安全问题-sized-trait" id="trait对象安全问题-sized-trait">trait对象安全问题 Sized trait</a></h4>
<p>对象安全的本质就是为 了让 trait 对象可以安全地调用相应的方法</p>
<pre><code class="language-rs">// 并不是每个 trait都可以作为 trait对象被使用
//每个 trait, Self默认有一个隐式的 trait 限定 ?Sized, 形如&lt;Self: ?Sized&gt; , ?Sized trait 包括了所有的动态大小类型和所有可确定大小 的类型。
// Rust 中大部分类型都默认是可确定大小的类型，也就是&lt;T: Sized&gt;，这也是泛型代 码可以正常编译的原因 
// 
// 当 trait对象在运行期进行动态分发，也必须确定大小，否则无法为其正确分配内存空 间 。所 以必须同时满足以下两条规则的 trait 才可以作为 trait 对象使用
//  trait对象 能够编译通过的要求是, trait 必须是对象安全的, 满足:
// 1.  trait 的 Self类型参数不能被限定为 Sized, 必须是 默认的 ?Sized (因为 trait objec 在编译期无法确定具体类型, 大小未知)
// 2.  trait 中所有的方 法都必须是对象安全的, 满足三点之一
//          - 方法受 Self: Sized 约束
//          - trait 中 不能包含关联常 量( Associated Constant, 其定义方法和关联类型差不多， 只不过需要使用 const关键字)
//          - 方法满足没有额外 Self类型参数的非泛型成员方法(分解开来就是三点)
    //          - 必须不包含任何泛型参数 (因为如果包含泛型 ，trait 对 象在 虚表Vtable中查找方法时将不确定该调用哪个方法)
    //          - 第一个参数必须为 Self 类型或可以解引用为 Self 的类型 (比如 self、 &amp;self、&amp;mutself和 self: Box&lt;Selt&gt;)
    //          - Self不能出现在除第一个参数之外的地方， 包括返回值中 (因为如果出现 Self,那就意味着 Self和 self、 &amp;self或&amp;mutself的类型能够相匹配。 但是对于 trait对象来说， 根本无法做到保证类型匹配)
// 
// 这个trait 就无法作为 trait object在动态分发中使用, 不是对象安全的
trait Foo: Sized {...}//表示要为某类型实现 Foo，必须先实现 Sized, Foo 中 的隐式 Self被设定为是 Sized 的




// 标准的对象安全的 trait
trait Bar {
    fn bax(self, x: u32);
     fn bay (&amp;self) ;
     fn baz (&amp;mut self) ;
}

// 典型的对象不安全的 trait
// 
// 对象不安全的 trait
trait Foo {
    fn bad&lt;T&gt;(&amp;self, x: T);
    fn new() -&gt; Self;
}

//对象安全的 trait ， 将不安全 的方法拆 分 出 去
trait Foo {
    fn bad&lt;T&gt;(&amp;self, x: T);
}
trait Bar:Foo {
    fn new() -&gt; Self;
}

//对象安全的trait，使用where子句
// 只不过在 traitFoo作为 trait对象且有?Sized限定时， 不允许调用该 new方法
trait Foo {
    fn bad&lt;T&gt;(&amp;self, x: T);
    fn new() -&gt; Self where Self: Sized;
}
</code></pre>
<h4><a class="header" href="#impl-trait" id="impl-trait">impl trait</a></h4>
<p>可 以静态分发的抽象类型 impl Trait, 可以用来替代泛型约束, 可以使用加号 (impl Fly+Debug)</p>
<p>目前 impl Trait 只可以在输入的参敬和返回值这两个位置使用</p>
<pre><code class="language-rs">// ’static 是一种生命周期参数 ， 它限定了 impl Fly+Debug 抽象类 型不可能是引用类型
fn dyn_can_fly( s : impl Fly+Debug+ ’static) -&gt; Box&lt;dyn Fly&gt; {}
</code></pre>
<h3><a class="header" href="#trait的类型转换" id="trait的类型转换">trait的类型转换</a></h3>
<p>隐式类型转换 (Implicit Type Conversion)和显式类型转 换 (ExplicitType Conversion)</p>
<pre><code class="language-rs">// 隐式类型转换基本上只有 自动解 引用
// 引用使用&amp;操作符， 而解引用使用*操作符。可以通过实现Deref trait来自定

// as 操作符 最常用的场景就是转换 Rust 中的基本数据类型
let a: i64 = 11 as i64
// 短(大小)类型转换为长(大小)类型的时候是没有问题的， 但 是如果反过来，则会被 截断处理
// 当从有符号类型 向无符号类型转换 的时候， 最好使用标准库中提供的专门的方法，而不要直接使用 as操作符

// 类型和子类型相互转换
// 生命周期标记可看作子类型。 比如&amp;’static str类型是&amp;’a str类型的子类 型; 
//’a 和 'static 都是生命周期标记，其中’a 是泛型标记， 是 &amp;str的通用形式， 而’static则是特指静态生命周期的&amp;str字符串


</code></pre>
<h3><a class="header" href="#from-trait-into-trait" id="from-trait-into-trait">From trait Into trait</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 定义于 std::convert 模块中的两个 trait。 它们定义了 from 和 into 两个方 法，这两个方法互为反操作

let s = String: :from(”hello”);

struct Person {
    name, String,
}
impl Person {
    //允许传入的参数是&amp;str类型或 String 类型 ，方便进行开发 (&amp;str和 String类型都实现了 Into, 当参数是&amp;str类型时，会通过 into转换为 String)
    fn new&lt;T: Into&lt;String&gt;&gt;(name: T) -&gt; Self {
        Person {name: name.into()}
    }
}

// 如果类型 U实现了 From&lt;T&gt;，则 T类型实例调用 into方 法就可以转换为类型 U (rust 自动帮我们实现了 Into)
// impl&lt;T, U&gt; Into&lt;U&gt; for T where U: From&lt;T&gt; {}
// 所以 ， 一般情况下 ， 只需要实现 From 即可 ， 除非 From 不容易实现，才需要考虑实 现 Into
let a = &quot;hello&quot;;
let b:String = a.into();//String 类型实现了 From&lt;&amp;str&gt;，所以可以使用 into 方法将 &amp;str 转换为 String



// TryFrom 和 TryInto 两种 trait，是 From 和 Into 的错误处理版本

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#derefmut和-deref" id="derefmut和-deref">DerefMut和 Deref</a></h3>
<p>用于自定义解除引用运算符(*)的行为</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>  let a = 11;  
  let b = Box::new(a);  
  print!(&quot;Value of *b is {}&quot;,*b); //11, box 可以像普通引用一样解引用

// 构造自己的 box
#[derive(Debug)]
struct MyBox&lt;T&gt;(T);
impl&lt;T&gt; MyBox&lt;T&gt; {
    pub fn new(v: T) -&gt; Self {
        return MyBox(v);
    }
}
use std::ops::Deref;
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

let b = MyBox::new(32);
println!(&quot;{:?}&quot;, b);
println!(&quot;b inner = {}&quot;, *b); //32
println!(&quot;b inner2 = {}&quot;, *b.deref());// 32, deref() 返回内部数据的引用

//自动解包 , deref 的强制效果
fn prin(v: &amp;i32) {
    println!(&quot;{}&quot;, v);
}
prin(&amp;b) // 自动将 &amp;MyBox 包装解除, 成为 &amp;i32


<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-rs">// 如果一个类型 T 实现了 Deref&lt;Target=U&gt;， 则该类型 T 的引用 (或智能指针)在应用的时候会被 自动转换为类型 U
// String类型实现了 Deref
let a = &quot;hello&quot;.to string();
let b = &quot; world&quot;.to string();
let c = a÷ &amp;b;//&amp;b，它应该是一个&amp;Sting类型，而 String类型实现的 add方法的右值参数必须是&amp;str类型, 但现在它是可 以正常运行的。原因就是 String 类型实 现了 Deref&lt;Target=str&gt;
println!(”{:?)’”, c); // &quot;hello world&quot;

// 标准库中常用的其他类型都实现了 Deref， 比如 Vec&lt;T&gt;
fn foo(s : &amp;[i32]){}
let v= vec![1,2,3)
foo(&amp;v);//所以&amp;Vec&lt;T&gt; 会被自动转换为 &amp;[T]类型，

// Box&lt;T&gt;、 Rc&lt;T&gt;、 Arc&lt;T&gt;
let x = Re::new(&quot;hello&quot;);
println1 (”{:?}”, x.chars());

// 当某类型和其解引用目标类型中包含了相同的方法时，编译器不知道该用哪一个了,此时就需要手动解引用
//  clone方法在Rc和&amp;str类型中都被实现了，所以调用时会直接调用 Re 的 clone 方法，如果想调用 Re 里面 &amp;str 类型的 clone 方法，则需要使用“解 引用”操作 符 手动解引用
let x= Re::new(”hello”),
let y=x.clone(); //Rc&lt;&amp;str&gt;的 clone 方法
let z = (*x) .clone() ; // &amp;str 的 clone 方法

// match 引用时也需要手动解引用
// 
let x = &quot;hello&quot;. to_string (); 
match &amp;x {//手动解引用把&amp; String 类型转换成&amp; str
        // match x.deref()，
        //match x.as_ref()
        //match x.borrow()
        //match &amp;*x 使用“解引用 ”操作符，将 String转换为 str，然后再用“引用”操作符转为&amp; str
        //match&amp;x[..]，这是因为String类型的index操作可以返回&amp;由类型
    &quot;hello&quot; =&gt; {println! (&quot;xxx&quot;)}
}
// DerefMut和 Deref类似， 只不过它是返回可变引用的。 Deref中包含关联类型 Target, 它表示解引用之后的目标类型

</code></pre>
<h3><a class="header" href="#asref-trait-asmut-trait" id="asref-trait-asmut-trait">AsRef trait AsMut trait</a></h3>
<p>可以将值分别转换为不可变引用和 可变引用</p>
<p>AsRef和标准库的另外一个 Borrow trait功能有些类似，但是 AsRef比较轻量级， 它只是简单地将值转换为引用，而 Borrow trait 可以用来将某个复合类型抽象为拥有借用语义 的类型</p>
<h3><a class="header" href="#borrow-trait" id="borrow-trait">Borrow trait</a></h3>
<h3><a class="header" href="#debug-trait" id="debug-trait">Debug trait</a></h3>
<pre><code class="language-rs">// 实现了最常用 的 Debug trait， 就可 以拥有在 println!宏语句中 使用{ :?}格式进行打印的行为，
// 也可以使用 #[derive(Debug)I属性帮助开发者自动实现 Debug trai
use std::fmt::*;
struct A {
    a: i32, 
}
impl Debug for A {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;Point [&quot;)?;
        write!(f, &quot;a = {}&quot;, self.a)?;
        write!(f, &quot;b = {}&quot;, self.b)?;
        write!(f, &quot;]&quot;)?;
        Ok(())
    }
}


</code></pre>
<h3><a class="header" href="#drop-trait-资源释放" id="drop-trait-资源释放">Drop trait 资源释放</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 用于在变量超出范围时从堆内存中释放空间 (rust 会隐式调用 drop()), 如释放 Box &lt;T&gt;指向的堆上的空间, 
// 如 释放文件或网络连接等资源
// 
// 有时，有必要在范围结束之前删除该值。如果想提前删除该值，那么使用std::mem::drop函数来删除

    //
    //
    // 释放资源 Drop trait
    /*
    Drop trait 只有一个方法：drop，当对象离开作用域时系统会进行资源释放, 同时会自动调用该 方法, 用于释放类似于文件或网络连接的资源。, 这个方法不允许手动调用, 编译器会自动调用, 用于释放类似于文件或网络连接的资源, 或者释放 box 所指向的堆空间

    也可以 drop(a) 手动调用释放, 使用 std::mem::drop(xxx)

    Box，Vec，String，File，以及 Process 是一些实现了 Drop trait 来释放 资源的类型。
    */


// 析构顺序
// 
// - 本地变量遵循先声明的变量后析构的规则 (这也缘于桔结构先进后 出的特性)
// - 元组整体来说也属于本地变量, 所以析构顺序和局部变量的析构顺序一致
//         但内部元素是按元素的出现顺序依次进行析构的
// - 结构体和枚举体 内部元素按照定义时的次序析构 (类似元组的析构)
// - 闭包捕获变 量 的析构顺序和闭包内该变量的排列顺序 一致, 与捕获变 量声 明的顺序是没有关系的
// 
struct PrintDrop(&amp;'static str);
    impl Drop for PrintDrop {
        fn drop(&amp;mut self) {
            println!(&quot;Dropping {}&quot;, self.0)
    }
}
// 顺序: y, x
let x = PrintDrop(&quot;x&quot;);
let y = PrintDrop(&quot;y&quot;);

// 顺序: x, y, z, a,b,c
let tup1 = (PrintDrop(&quot;a&quot;), PrintDrop(&quot;b&quot;), PrintDrop(&quot;c&quot;));
let tup2 = (PrintDrop(&quot;x&quot;), PrintDrop(&quot;y&quot;), PrintDrop(&quot;z&quot;));

// 顺序: y,x, a,b,c
let tup1 = (PrintDrop(&quot;a&quot;), PrintDrop(&quot;b&quot;), PrintDrop(&quot;c&quot;));
let tup2 = (PrintDrop(&quot;x&quot;), PrintDrop(&quot;y&quot;), panic!());//线程的崩愤触发了 tup2 的提前析构, 这 种提前析构的顺序正好和局部变量的析构顺序一致: 先声明的元素后析构。


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#clone-trait" id="clone-trait">Clone trait</a></h3>
<p>实现 clone, colon_from 方法</p>
<p>如果一个类型是 Copy的， 它的clone方法仅d需要返回*self即可 </p>
<h3><a class="header" href="#标签-trait" id="标签-trait">标签 trait</a></h3>
<p>即 内部没有任何内容的 trait, 只是作为一个标签, 起到标识作用</p>
<h4><a class="header" href="#send-trait-和-sync-trait" id="send-trait-和-sync-trait">Send trait 和 Sync trait</a></h4>
<pre><code class="language-rs">// 很多其他语言通过各种成熟的并发解决 方案来支持并发编程, 解决数据竞争， 比如 Erlang提供轻量级进程和 Actor并发模型: Golang提供了协程和 CSP并发模型。而 Rust则从正面解决了这个问题，它的“秘密武器” 是类型系统和所有权机 制。

// 可以安全地跨线程传递和访 问 的类型用 Send 和 Sync 标记，否则用! Send 和!Sync 标记 

// 实现了 Send 的类型 ，可以安全地在线程间传递值 ，也就是说可 以跨线程传递所有权
// 实现了 Sync 的类型 ，可以跨线程安全地传递共享( 不可变)引用 。
// 
// 有了这两个标签 trait，就可 以把 Rust 中所有的类型归为两类:可以安全跨线程传递的值 和引用 ， 以及 不可以跨线程传递的值和引用 。 再配合所有权机制，带来的效果就是， Rust 能 够在编译期就检查出数据竞争的隐患， 而不需要等到运行时再排查

// 之所以可以正常地move变量，也是因为数组x中的元素均为原生数据类型， 默认都实现了 Send 和 Sync 标签 trait，所以它们跨线程传递和访问都很安全
let mut x=vec![1, 2, 3, 4] ;
thread::spawn(move || x.push(1));

// error
//Rc 没有实 现 Send 和 Sync，所以不能在线程之间传递变 量 x
// 因为 Rc是用于引用计数的智能指针， 如果把 Rc类型的变量 x传递到另一个线程中，会 导致不同线程的 Rc 变量引用同一块数据， Re 内 部实现并没有做任何线程同步的处理
let x = Rc::new(vec! [1, 2, 3, 4]);//
thread::spawn( move || x[1]);


// 对于自定义的数据类型，如果其成员类型全部实现 Send 和 Sync，此类型才会被自 动实现 Send 和 Sync
</code></pre>
<h4><a class="header" href="#copy-trait" id="copy-trait">Copy trait</a></h4>
<p>区分值语义和引用语义</p>
<pre><code class="language-rs">// Copy trait，用来标识 可 以按位 复制其值 的类型
// Copy 告诉编译器这个类型默认采用 copy 语义，而不是 move 语义; 在执行变量绑定、函数参数传递、函数返回等场景下, 执行的是内存拷贝操作

// 引用类型无法实现 copy trait, 虽然引用语义类型不能实现 Copy， 但可以实现 Clone 的 clone 方法， 以 实现深复制

// Copy trait继承自 Clone trait, 要实现 Copy trait 的类型，必须实现 Clone trait 中定义的方法
//  Rust 提供了更方便的 derive 属性供我们完成这项重复的工作
#[derive (Copy , Clone)]
struct xxx {}
// 某个类型标注为 Copy后, 就不能随便实现 Clone 的 clone 方法了, 调用 t.clone() 时, 执行的操作必须等同于“简单内存拷贝”;
// 所以 一般使用 #[derive(Copy, Clone)] 这种方式，这种情况下它们俩最好一起出现，避免手工实现 Clone 导致错误



// Rust 为很多基本数据类型实现了 Copy trait，比如常用的数字类型、字符( Char)、布尔 类型、单元值、不可变引用等
// 检测哪些类型实现 了 Copy trait:
fn test copy&lt;T: Copy&gt;(t : T) { //如果实现了Copy trait的类型， 则可以正常编译: 如果没有实现，则会报错。
    println(”hhh”);
}




// 并非所有类型都可以 实现 Copy trait。 
// 对于自定义类型来说，必须让所有的成员都实现 了 Copy trait， 这个类型才有资格 实现 Copy trait。
// 如果是数组类型 ， 且其内部元素都是 Copy 类型， 则数组本身就是 Copy 类型;
// 如果是元组类型，且其内部元素都是 Copy 类型， 则该元 组会自动实现Copy


</code></pre>
<h4><a class="header" href="#sized-trait--和-unsized-trait-和-动态类型" id="sized-trait--和-unsized-trait-和-动态类型">Sized trait  和 Unsized trait 和 动态类型</a></h4>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>// sized trait 用来标识编译期可确定大小的类型
// Unsize trait， 目前该 trait 为实验特性，用于标识动态大小类型 (DST)

// 目前 Rust 中的动态类型有 trait 和 [T]， 其中 [T]代表一定数量的 T 在内存 中依次排列
// 用 Unsize 来标记


// Dynamical sized type -&gt; DST
// 运行期才知道大小的类型
// 典型如 str (不是 &amp;str 哦), 编译器不可知大小
//      &amp;str 这个类型的值包含两个部分, str 的地址, str 的长度, 所以 &amp;str 的大小类型可以确定 即 2*usize
// 典型如 trait, 都是动态类型

// 所以为了能够编译通过, 必须将动态类型放到指针背后

// Sized trait 决定 类型的大小是否在编译期可知, 
//
// compiler默认为 类型加上了 Sized trait, 如:
fn xxx&lt;T: Sized&gt;(t: T); // 指定 t 为可知大小类型, Sized 可省略, 编译器默认添加了

// ?Sized 包含 Sized 和 unsized
fn xxx&lt;T: ?Sized&gt; (t: T);// t 为 编译期间不可知大小的类型 or 为 可知大小类型, 告诉 编译器, 到底是那种类型不确定



// 但是动态大小类型不能随意使用，还需要遵循如下三条限制规则:
// 
// 1. 只可以通过胖指针来操作 Unsize类型，比如&amp;[T]或&amp;Trait
// 2. 变量、参数和枚举变量不能使用动态大小类型
// 3. 结构体中只有最后一个字段可以使用动态大小类型，其他字段不可以使用



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#default-trait" id="default-trait">Default trait</a></h3>
<pre><code class="language-rs">// 为 struct 提供默认值
struct ColoredString {
    input: String,
    fgcolor: String,
    bgcolor: String,
}
impl Default for ColoredString {
    fn default() -&gt; Self {
        ColoredString {
            input: String::default(),// 这样使用即可
            fgcolor: String::new(),
            bgcolor: String::new(),
        }
    }
}

</code></pre>
<h3><a class="header" href="#extend-trait" id="extend-trait">Extend trait</a></h3>
<pre><code class="language-rs">// 通过 iterator中的元素, 扩充集合
// 包含方法:
// fn extend&lt;T: IntoIterator&lt;Item = A&gt;&gt;(&amp;mut self, iter: T);

let mut s = &quot;Hello&quot;.to_owned();
s.extend(&amp;[' ', 'R', 'u', 's', 't']);
println!(&quot;{}&quot;, s);//Hello Rust

// String 刚好实现了这个 trait


</code></pre>
<h3><a class="header" href="#any-trait" id="any-trait">Any trait</a></h3>
<pre><code class="language-rs">// use std::any::Any;

</code></pre>
<h3><a class="header" href="#和比较排序相关的trait" id="和比较排序相关的trait">和比较排序相关的trait</a></h3>
<pre><code class="language-rs">// PartialEq、 Eq、 PartialOrd 和 Ord
// - PartialEq代表部分等价关系，其中定义了 eq和 ne (不等, 有默认实现)两个方法
// - Eq 代表等价关系，该 trait 继承自 PartialEq， 但是其中没有定义任何方法 。 它实际上 相当于标记实现了 Eq 的类型拥有等价关系
// - PartialOrd对应于偏序，其中定义了 partial_cmp (必须实现)、 lt、 le(小于等于)、 gt和 ge五个方法
// - Ord对应于全序，其中定义了 cmp、 max和 min三个方法
// 
// 枚举体为 Ordering， 用于表示 比较结果，其中定义了 小于、等于和大于三种状态。


   let mut v = [-5i32, 4, 1, -3, 2];
//    默认升序
    v.sort();
    assert!(v == [-5, -3, 1, 2, 4]);
    // 而 sort_by 是按 a 和 b 的比较结果是否等于 Less 的规则进行排序 的， 若等于 less, 则 a 小于 b，为升序排列
    v.sort_by(|a, b| a.cmp(b));
    assert!(v == [-5, -3, 1, 2, 4]);
    v.sort_by(|a, b| b.cmp(a));
    assert!(v == [4, 2, 1, -3, -5]);
    v.sort_by_key(|k| k.abs());
   assert!(v == [1, 2, -3, 4, -5]);


   let result = 1.0.partial_cmp(&amp;2.0);//浮点数，只能用偏序比较
    assert_eq!(result, Some(Ordering::Less));
    let result = 1.cmp(&amp;1);
    assert_eq!(result, Ordering::Equal);
    let result = &quot;abc&quot;.partial_cmp(&amp;&quot;Abc&quot;);
    assert_eq!(result, Some(Ordering::Greater));
    let mut v: [f32; 5] = [5.0, 4.1, 1.2, 3.4, 2.5];
    v.sort_by(|a, b| a.partial_cmp(b).unwrap());
    assert!(v == [1.2, 2.5, 3.4, 4.1, 5.0]);
    v.sort_by(|a, b| b.partial_cmp(a).unwrap());
    assert!(v == [5.0, 4.1, 3.4, 2.5, 1.2]);
</code></pre>
<h2><a class="header" href="#元组" id="元组">元组</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>


<span class="boring">fn main() {
</span>    // 元组,
    //类型可以不同
    const tup: (i32, f64, u8, &amp;'static str) = (500, 6.4, 1, &quot;holla&quot;);
    // tup.0 等于 500
    // tup.1 等于 6.4
    // tup.2 等于 1

    // 结构元组
    let (x, y, z, w) = tup;
    // y 等于 6.4

    // 当元组中只有一个值的时候，需要加逗号，即(0,)

    // 空元组 / 单元类型
    ()
    // 零大小类型(Zero Sized Type, ZST), 不占空间
    // 
    // 使用场景:
    // 1. 在开发时, 查看数据类型; 
    let a: () = vec![();10];// error, 提示 expected (), foundstruct 、std: :vec·:Vee, 这样就知道了右值 vec![(); 10]是向量类型
    // 2. 在需要循环指定次数的位置, 用来提高性能 (因为 Vee 内部迭代器中 会针对 ZST 类型做一些优化)
    let v: Vee&lt;()&gt;= vec![(); 10];
    for i in v {
        // xxx
    }
    // 3. 官方标准库 中的 HashSet&lt;T&gt; 和 BTreeSet&lt;T&gt;
    // 其实只是把 HashMap&lt;K, T&gt;换成了 HashMap&lt;K, ()&gt;， 然后就可 以共用 HashMap&lt;K, T&gt;之前的代码，而不需要再重新实现一遍 HashSet&lt;T&gt;了。


<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#结构体" id="结构体">结构体</a></h2>
<h3><a class="header" href="#结构体基本使用" id="结构体基本使用">结构体基本使用</a></h3>
<pre><pre class="playpen"><code class="language-rust">
/// 结构体
/// 结构体（Struct）与元组（Tuple）都可以将若干个类型不一定相同的数据捆绑在一起形成整体
/// 但是结构体可以给每个数据起个名字
/// 这样访问它成员的时候就不用记住下标了
///
/// 和 c 不同,  Rust 里 struct 语句仅用来定义，不能声明实例，结尾不需要 ; 符号
///
/// 结构体必须掌握字段值所有权，因为结构体失效的时候会释放所有字段, 所以字符串字段使用 String 不用 &amp;str (因为 &amp;str 是借用的所有权)
///
/// 没有身体的结构体为单元结构体（Unit Struct）, 如 struct UnitStruct;
/// 
///
fn struct_demo() {
    // 定义
    #[derive(Debug)] // 在定义 struct 时导入调试库, 才能 print
    struct Site {
        domain: String,
        name: String,
        nation: String,
        found: u32,
    }
    // 实例化, 若是空 struct,     let inner_a = InnerA {};
    let domain = String::from(&quot;xiaoyureed.github.io&quot;);
    let st = Site {
        domain, // 有字段名称和现存变量名称一样的，可以简化书写, 类似 JavaScript
        name: String::from(&quot;xiaoyu&quot;),
        nation: String::from(&quot;China&quot;),
        found: 2013,
    };
    // 部分更新
    // 因为没有实现了 Copy trait, 所有 st 所有权会转移
    let st1 = Site {
        domain: String::from(&quot;new domain&quot;),
        ..st
    };

    // 输出结构体
    // 需要定义 struct 时导入调试库 #[derive(Debug)]
    println!(&quot;st = {:?}&quot;, st1);
    // 格式化输出 {:#?}
    println!(&quot;st = {:#?}&quot;, st1);


// 只有 成员都为 复制语义,  struct 才能自动 Copy derive 
#[derive(Debug,Copy,Clone)]
struct Book&lt;'a&gt; {
    name: &amp;'a str,
    isbn: i32,
    version: i32,
}
fn main(){
    let book = Book {
        name: &quot;Rust编程之道&quot; , isbn: 20181212, version: 1
    };
    let book2 = Book { version: 2, ..book};
    println!(&quot;{:?}&quot;,book);// book 由于 实现 了 Copy trait, 所有权没有转移
    println!(&quot;{:?}&quot;,book2);
}
</code></pre></pre>
<h3><a class="header" href="#元组结构体-and-单元结构体" id="元组结构体-and-单元结构体">元组结构体 and 单元结构体</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>


<span class="boring">fn main() {
</span>    // 元组结构体
    // 简化的结构体, 没有字段名称, 只有字段类型
    // 是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据
    struct Color(u8, u8, u8);
    struct Point(f64, f64);
    let black = Color(0, 0, 0);
    let origin = Point(0.0, 0.0);
    // 使用和元组一样, 通过下标访问字段
    println!(&quot;black = ({}, {}, {})&quot;, black.0, black.1, black.2);
    println!(&quot;origin = ({}, {})&quot;, origin.0, origin.1);
    // 直接打印结构体 错误
    // 要打印, 两种方法:
    // 1. 定义 struct 时继承 #[derive(Debug)], 然后 使用 {:?} or {:#?} 打印
    // 2. 为 struct 实现 fmt::Display 接口, 然后使用 {} 即可
    // println!(&quot;tuple struct - {}&quot;, black);



    // 单元结构体 即 空的结构体, 零大小类型(Zero Sized Type, ZST), 不占空间
    // 
    // 在Debug编译模式下, 多个 空结构体 实例是不同 的对象
    // 在在Release编译模式下, 会被优化为同一个 对象 (内存地址相同)
    //
    // 标准库中表示全范围()的 RangeFull， 就是一个单元结构体

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#结构体方法" id="结构体方法">结构体方法</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>    //
    // 结构体方法
    //
    impl Site {
        // &amp;self 关键字 总是第一个参数, 类似 Python
        fn to_string(&amp;self) -&gt; String {
            // self 表示 struct 实例
            format!(&quot;to string -&gt; {:?}&quot;, self)
        }
    }
    println!(&quot;st.to_string() = {}&quot;, st.to_string());

    //
    // 结构体关联函数
    //类似 Java 中的静态方法, 调用不依赖 struct 实例
    //
    //没有 &amp;self 参数
    impl Site {
        fn create() -&gt; Site { // Site 可用 Self 替代
            Site {
                domain: String::from(&quot;new domain create()&quot;),
                name: String::from(&quot;xiaoyu&quot;),
                nation: String::from(&quot;nation&quot;),
                found: 2020,
            }
        }
    }
    let create_site = Site::create();
    println!(&quot;create_site = {:?}&quot;, create_site);

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#new-type-模式-和-类型别名-self别名" id="new-type-模式-和-类型别名-self别名">new type 模式 和 类型别名 Self别名</a></h3>
<p>当一个元组结构体只有一个字段的时候，称之为 New Type 模式</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 使用场景:
// - 明确语义: 为同类型的数据分别定义新的类型进行区分, 如 为 i32 类型分别定义 Hour, Second 类型 (这是为了能保证在编译时，编译期间即可发现错误。), 包装了一层
// - 使复制语义的 类型具有移动语义; 比如 f64 本来是复制语义 ，而包装为 Miles(f64)之 后，因为结构体本身不能被自动实现 Copy，所以 Miles(f64)就成了移动语义。
// - 隐藏实际类型， 限制功能; 使用 Newtype模式包装的类型并不能被外界访问，除非提 供相应方法。
// - 给标准库中的结构实现标库中的 trait, 如给 Vector 实现 Display trait.
//         由于孤儿规则, 这明显不行, 可以通过给 Vector 包装一层来达到目的
    struct Wrapper(Vec&lt;String&gt;);
    impl std::fmt::Display for Wrapper {
        fn .....
    }

    //new type 惯用法
    //
    //
    struct Years(i64);
    struct Days(i64);
    impl Years {
        pub fn to_days(&amp;self) -&gt; Days {
            Days(self.0 * 365)
        }
    }
    impl Days {
        /// 舍去不满一年的部分
        pub fn to_years(&amp;self) -&gt; Years {
            Years(self.0 / 365)
        }
    }
    fn old_enough(age: &amp;Years) -&gt; bool {
        age.0 &gt;= 18
    }
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));// 只能传年单位的数字
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days)); //出错, 编译期间即可发现 // 不能传天单位的数字






    // 类型别名
    // 也可以使用 type关键字为一个类型创建别名，如代码第 2行为 i32类型创建了一个别名 Int， 但是其本质还是 i32 类型，它所拥有的行为和 i32 是一样 的 。相 比之下， New Type 模式 属于 自定义类型，更加灵活
    //别名的主要用途是避免写出冗长的模板化代码（boilerplate code）。如 IoResult&lt;T&gt; 是 Result&lt;T, IoError&gt; 类型的别名。
    enum VeryVerboseEnumOfThingsToDoWithNumbers {
        Add,
        Subtract,
    }
    // Creates a type alias
    type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;
    let x = Operations::Add; // 能这么用
    impl VeryVerboseEnumOfThingsToDoWithNumbers {
        fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
            match self {
                // Self 别名
                Self::Add =&gt; x + y,
                Self::Subtract =&gt; x - y,
            }
        }
    }
    // `NanoSecond` 是 `u64` 的新名字。
    type NanoSecond = u64;
    type Inch = u64;

    // 通过这个属性屏蔽警告。
    #[allow(non_camel_case_types)]
    type u64_t = u64;
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#案例-彩色命令行输出" id="案例-彩色命令行输出">案例 彩色命令行输出</a></h3>
<p>main.rs </p>
<pre><code class="language-rs">mod color;
use color::Colorized;

fn main() {
    let s=  &quot;hello&quot;.red().on_yellow();
    println!(&quot;{}&quot;, s);
}
</code></pre>
<p>color.rs </p>
<pre><code class="language-rs">use std::fmt::Display;

pub struct ColorString {
    input: String, // 内容
    fg: String,    // 前景
    bg: String,    // 背景
}
// 实现默认值, 对 color string 进行初始填充
impl Default for ColorString {
    fn default() -&gt; Self {
        ColorString {
            input: String::default(),
            fg: String::default(),
            bg: String::default(),
        }
    }
}
pub trait Colorized {
    // 关联常量, 和联类型类似， 由实现该 trait 的类型来指定常量的值
    // 这里指定了默认值
    const FG_RED: &amp;'static str = &quot;31&quot;;
    const BG_YELLOW: &amp;'static str = &quot;43&quot;;

    fn red(self) -&gt; ColorString;

    fn on_yellow(self) -&gt; ColorString;
}

impl Colorized for ColorString {
    fn red(self) -&gt; ColorString {
        ColorString {
            fg: String::from(Self::FG_RED),
            ..self
        }
    }

    fn on_yellow(self) -&gt; ColorString {
        ColorString {
            bg: String::from(Self::BG_YELLOW),
            ..self
        }
    }

    const FG_RED: &amp;'static str = &quot;31&quot;;

    const BG_YELLOW: &amp;'static str = &quot;43&quot;;
}

impl&lt;'a&gt; Colorized for &amp;'a str {
    fn red(self) -&gt; ColorString {
        ColorString {
            input: String::from(self),
            fg: String::from(Self::FG_RED),
            ..ColorString::default()
        }
    }

    fn on_yellow(self) -&gt; ColorString {
        ColorString {
            input: String::from(self),
            bg: String::from(Self::BG_YELLOW),
            ..ColorString::default()
        }
    }

    const FG_RED: &amp;'static str = &quot;31&quot;;

    const BG_YELLOW: &amp;'static str = &quot;43&quot;;
}
impl ColorString{
    // 组装 ansi 码
    // \xlB[43;31m, 
    fn compute_style(&amp;self) -&gt; String {
        let mut res = String::from(&quot;\x1B[&quot;);// ansi 码起始
        let mut has_wrote = false;
        if !self.bg.is_empty() {
            res.push_str(&amp;self.bg);
            has_wrote = true;
        }
        if !self.fg.is_empty() {
            if has_wrote {
                res.push(';');
            }
            res.push_str(&amp;self.fg);
        }
        res.push('m');// ansi 码结束
        res
    }
}
impl Display for ColorString {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        f.write_str(&amp;self.compute_style())?;
        write!(f, &quot;{}&quot;, self.input)?;
        write!(f, &quot;\x1B[0m&quot;)?;
        Ok(())
    }
}
</code></pre>
<h2><a class="header" href="#枚举" id="枚举">枚举</a></h2>
<h3><a class="header" href="#枚举基本使用" id="枚举基本使用">枚举基本使用</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// 枚举类
///
/// 枚举元素可以各不相同
///
fn enum_demo() {
    println!(&quot;-------------enum demo-----------------------&quot;);

    #[derive(Debug)]
    enum Book {
        Papery,
        Book1(i32),
        Book2(String),
        Book3 {field1: String, field2: String},
    }
    let book = Book::Papery;
    println!(&quot; enum book = {:?}&quot;, book);

    // 实例化带属性的枚举类
    let boot1 = Book::Book1(11);
    // 错误, 没这个语法
    println!(&quot;book1.0 = {}&quot;, boot1.0);
    // 正确
    println!(&quot;book1 = {:?}&quot;, boot1);

    // 访问枚举类的属性, 必须借助 match
    let book3 = Book::Book3{
        field1: String::from(&quot;hello&quot;),
        field2: String::from(&quot;world&quot;),
    };
    match book3 {
        Book::Papery =&gt; println!(&quot;book&quot;),
        // 对于 元组, 由于没有字段名称, 需要临时指定一个形参
        Book::Book1(i) =&gt; println!(&quot;book1.i = {}&quot;, i),
        Book::Book2(s) =&gt; println!(&quot;book2.s = {}&quot;, s),
        Book::Book3{field1, field2} =&gt; {
            println!(&quot;book3.field1 = {}, book3.field2 = {}&quot;, field1, field2);
        },
        _ =&gt;  println!(&quot;no match&quot;),
    }


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#option" id="option">Option</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>// Option 枚举类
    //是 Rust 标准库中的枚举类，这个类用于填补 Rust 不支持 null 引用的空白
    //
    // enum Option&lt;T&gt; {
    //    Some(T),
    //    None,
    // }
    // 

    // 解开可以通过 match 模式匹配, 
    // or:
    // 通过 unwrap 系列方法
    // - expect(&quot;error message&quot;) 解开 Some, 若 None, 则 panic!(&quot;error message&quot;)
    // -  unwrap()    解开 Some, 若碰到 None, 则 panic
    // - unwrap_or(T)  解开 Some, 若碰到 None, 则 返回指定的默认值
    // - unwrap_or_else(FnOnce()-&gt;T) 解开 Some, 碰到 None, 则执行一段闭包 


    let opt = Option::Some(&quot;Hello&quot;); // opt 允许为空
    match opt {
        Option::Some(something) =&gt; {
            println!(&quot;{}&quot;, something);
        },
        Option::None =&gt; {
            println!(&quot;opt is nothing&quot;);
        }
    }
    // 直接定义一个 &amp;str 类型的空值
    //Option 是 Rust 编译器默认引入的，在使用时可以省略 Option:: 直接写 None 或者 Some()。
    let opt: Option&lt;&amp;str&gt; = None;
    match opt {
        Some(something) =&gt; {
            println!(&quot;{}&quot;, something);
        },
        None =&gt; {
            println!(&quot;opt is nothing&quot;);
        }
    }


    // 
    // 流式处理
    // 组合算子 combinator: 简化 match 处理
    // 
    // map()
    // map_or() 可以为 None 指定默认值
    // map_or_else()
    //
    // 接受一个函数f, 返回一个option, 这个函数f:
    //  - 参数为option包含的元素, 返回值为处理后的元素
    //
    // 
    // 要求处理的option中元素可以是不同类型
    // 
    // 
    #[derive(Debug)] enum Food { Apple, Potato, Banana}
    #[derive(Debug)] struct Peeled(Food);//削皮的食物
    #[derive(Debug)] struct Chopped(Food);//切块的食物
    #[derive(Debug)] struct Cooked(Food);// 烹煮的食物
    fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
        food.map(|foo| Peeled(foo))// 闭包参数是Food 类型, 这里是解开了 Option, 返回 Option&lt;Peeled&gt; 类型
            .map(|Peeled(foo)| Chopped(foo)) // 参数是 Peeled 类型, 这里解开了Option, Peeled
            .map(|Chopped(foo)| Cooked(foo))
    }
    match process(Some(Food::Apple)) {
        Some(cooked) =&gt; println!(&quot;cooked: {:?}&quot;, cooked),
        _ =&gt; println!(&quot;error&quot;),
    }

    //
    // and_then() 
    //
    //接受一个函数f作为参数, 返回option, 函数f满足: 
    //- 参数为 option 包含的元素, 返回为option
    // 
    // 要求处理的option中元素是相同类型, 比如都属于某个枚举类
    // 
    //
    fn to_potato(food: Food) -&gt; Option&lt;Food&gt; {
        Some(Food::Potato)
    }
    fn to_banana(food: Food) -&gt; Option&lt;Food&gt; {
        Some(Food::Banana)
    }
    match to_potato(Food::Apple).and_then(to_banana) {
        Some(banana) =&gt; println!(&quot;banana: {:?}&quot;, banana),
        _ =&gt; println!(&quot;error&quot;),
    }




<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#c-风格的枚举" id="c-风格的枚举">c 风格的枚举</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    //
    // 拥有隐式辨别值（implicit discriminator，从 0 开始）的 enum
    enum Number {
        Zero,
        One,
        Two,
    }
    // c 风格枚举
    // 拥有显式辨别值（explicit discriminator）的 enum
    enum Color {
        Red = 0xff0000,
        Green = 0x00ff00,
        Blue = 0x0000ff,
    }
    // `enum` 可以转成整形。
    println!(&quot;zero is {}&quot;, Number::Zero as i32);//0
    println!(&quot;one is {}&quot;, Number::One as i32);//1
    println!(&quot;roses are #{:06x}&quot;, Color::Red as i32);//ff0000
    println!(&quot;violets are #{:06x}&quot;, Color::Blue as i32);//0000ff

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#案例-彩色命令行输出优化" id="案例-彩色命令行输出优化">案例 彩色命令行输出优化</a></h3>
<pre><code class="language-rs">use std::convert::From;
use std::str::FromStr;
use std::string::String;
use std::fmt;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum Color {
    Red,
    Yellow,
    Blue,
}

impl Color {
    pub fn to_fg_str(&amp;self) -&gt; &amp;str {
        match *self {
            Color::Red =&gt; &quot;31&quot;,
            Color::Yellow =&gt; &quot;33&quot;,
            Color::Blue =&gt; &quot;34&quot;,
        }
    }
    pub fn to_bg_str(&amp;self) -&gt; &amp;str {
        match *self {
            Color::Red =&gt; &quot;41&quot;,
            Color::Yellow =&gt; &quot;43&quot;,
            Color::Blue =&gt; &quot;44&quot;,
        }
    }
}

impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Color {
    fn from(src: &amp;str) -&gt; Self {
        // parse 方法，要求目标类型必须实现 FromStr
        src.parse().unwrap_or(Color::Red)
    }
}
impl From&lt;String&gt; for Color {
    fn from(src: String) -&gt; Self {
        src.parse().unwrap_or(Color::Red)
    }
}
impl FromStr for Color {
    type Err = ();
    //  from s仕 方法包含了 错误处理相关的代码
    fn from_str(src: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let src = src.to_lowercase();
        match src.as_ref() {
            &quot;red&quot; =&gt; Ok(Color::Red),
            &quot;yellow&quot; =&gt; Ok(Color::Yellow),
            &quot;blue&quot; =&gt; Ok(Color::Blue),
            _ =&gt; Err(()),
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
struct ColoredString {
    input: String,
    fgcolor: Option&lt;Color&gt;,
    bgcolor: Option&lt;Color&gt;,
}

impl ColoredString {
    fn compute_style(&amp;self) -&gt; String {
        let mut res = String::from(&quot;\x1B[&quot;);
        let mut has_wrote = false;
        if let Some(ref bgcolor) = self.bgcolor {
            if has_wrote {
                res.push(';');
            }
            res.push_str(bgcolor.to_bg_str());
            has_wrote = true;
        }
        if let Some(ref fgcolor) = self.fgcolor {
            if has_wrote {
                res.push(';');
            }
            res.push_str(fgcolor.to_fg_str());
        }
        res.push('m');
        res
    }
}

impl Default for ColoredString {
    fn default() -&gt; Self {
        ColoredString {
            input: String::default(),
            fgcolor: None,
            bgcolor: None,
        }
    }
}

// impl&lt;'a&gt; From&lt;&amp;'a str&gt; for ColoredString {
//     fn from(s: &amp;'a str) -&gt; Self {
//         ColoredString { input: String::from(s), ..ColoredString::default() }
//     }
// }

trait Colorize {
    fn red(self) -&gt; ColoredString;
    fn yellow(self) -&gt; ColoredString;
    fn blue(self) -&gt; ColoredString;
    // Color实现了 From，所以对于 String和&amp;’a str类型的字符串均可通 过 into 方法转换为 Color
    fn color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString;
    fn on_red(self) -&gt; ColoredString;
    fn on_yellow(self) -&gt; ColoredString;
    fn on_blue(self) -&gt; ColoredString;
    fn on_color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString;
}
impl Colorize for ColoredString {
    fn red(self) -&gt; ColoredString {self.color(Color::Red)}
    fn yellow(self) -&gt; ColoredString {self.color(Color::Yellow)}
    fn blue(self) -&gt; ColoredString {self.color(Color::Blue)}
    fn color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString {
        ColoredString { fgcolor: Some(color.into()), ..self }
    }
    fn on_red(self) -&gt; ColoredString {self.on_color(Color::Red)}
    fn on_yellow(self) -&gt; ColoredString {self.on_color(Color::Yellow)}
    fn on_blue(self) -&gt; ColoredString {self.on_color(Color::Blue)}
    fn on_color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString {
        ColoredString { bgcolor: Some(color.into()), ..self }
    }
}
impl&lt;'a&gt; Colorize for &amp;'a str {
    fn red(self) -&gt; ColoredString {self.color(Color::Red)}
    fn yellow(self) -&gt; ColoredString {self.color(Color::Yellow)}
    fn blue(self) -&gt; ColoredString {self.color(Color::Blue)}
    fn color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString {
        ColoredString {
            fgcolor: Some(color.into()),
            input: String::from(self),
            ..ColoredString::default()
        }
    }
    fn on_red(self) -&gt; ColoredString {self.on_color(Color::Red)}
    fn on_yellow(self) -&gt; ColoredString {self.on_color(Color::Yellow)}
    fn on_blue(self) -&gt; ColoredString {self.on_color(Color::Blue)}
    fn on_color&lt;S: Into&lt;Color&gt;&gt;(self, color: S) -&gt; ColoredString {
        ColoredString {
            bgcolor: Some(color.into()),
            input: String::from(self),
            ..ColoredString::default()
        }
    }
}

impl fmt::Display for ColoredString {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let mut input = &amp;self.input.clone();

        try!(f.write_str(&amp;self.compute_style()));
        try!(f.write_str(input));
        try!(f.write_str(&quot;\x1B[0m&quot;));
        Ok(())
    }
}

fn main() {
    let red = &quot;red&quot;.red();
    println!(&quot;{}&quot;, red);
    let yellow = &quot;yellow&quot;.yellow().on_blue();
    println!(&quot;{}&quot;, yellow);
    let blue = &quot;blue&quot;.blue();
    println!(&quot;{}&quot;, blue);
    let red = &quot;red&quot;.color(&quot;red&quot;);
    println!(&quot;{}&quot;, red);
    let yellow = &quot;yellow&quot;.on_color(&quot;yellow&quot;);
    println!(&quot;{}&quot;, yellow);
}
</code></pre>
<h3><a class="header" href="#实例-创建链表" id="实例-创建链表">实例 创建链表</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>    //
    //
    // enum 的一个常见用法就是创建链表（linked-list）
    //
    //
    //
    use List::*;

    enum List {
        // Cons：元组结构体，包含链表的一个元素和一个指向下一节点的指针
        Cons(u32, Box&lt;List&gt;),
        // Nil：末结点，表明链表结束
        Nil,
    }

    // 可以为 enum 定义方法
    impl List {
        // 创建一个空的 List 实例
        fn new() -&gt; List {
            Nil
        }

        // 处理一个 List，在其头部插入新元素，并返回该 List
        // self 不加 &amp;
        fn prepend(self, elem: u32) -&gt; List {
            // `Cons` 同样为 List 类型
            Cons(elem, Box::new(self))
        }

        // 返回 List 的长度
        fn len(&amp;self) -&gt; u32 {
            // `self` 为 `&amp;List` 类型，`*self` 为 `List` 类型，匹配一个具体的 `T`
            // 类型要好过匹配引用 `&amp;T`。
            match *self {
                // 不能得到 tail 的所有权，因为 `self` 是借用的；所以要使用引用
                // 因此使用一个对 tail 的引用
                Cons(_, ref tail) =&gt; 1 + tail.len(),
                // （递归的）基准情形（base case）：一个长度为 0 的空列表
                Nil =&gt; 0
            }
        }

        // 返回列表的字符串表示（该字符串是堆分配的）
        fn stringify(&amp;self) -&gt; String {
            match *self {
                Cons(head, ref tail) =&gt; {
                    // `format!` 和 `print!` 类似，但返回的是一个堆分配的字符串，
                    format!(&quot;{}, {}&quot;, head, tail.stringify())
                },
                Nil =&gt; {
                    format!(&quot;Nil&quot;)
                },
            }
        }
        // // 创建一个空链表
        // let mut list = List::new();

        // // 追加一些元素
        // list = list.prepend(1);
        // list = list.prepend(2);
        // list = list.prepend(3);

        // // 显示链表的最后状态
        // println!(&quot;linked list has length: {}&quot;, list.len());
        // println!(&quot;{}&quot;, list.stringify());
    }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#match-模式匹配" id="match-模式匹配">match 模式匹配</a></h2>
<h3><a class="header" href="#模式匹配简单使用" id="模式匹配简单使用">模式匹配简单使用</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// match 模式匹配
/// 类似 Java 中的 switch
/// 
/// 必须穷尽所有分支 (使用 _ 忽略某个情况), 每个分支返回同个类型 
///
fn match_demo() {

    println!(&quot;------------------------ match demo ------------------------&quot;);

    // 可以对枚举类, 对整数、浮点数、字符和字符串切片引用（&amp;str）类型的数据进行分支选择,    

    // match 返回的变量
    let a = match &quot;hello&quot;.len() {
        5 =&gt; &quot;len = 5&quot;,
        0 =&gt; &quot;len = 0&quot;,
        _ =&gt; &quot;unkonwn len&quot;,
    };
    println!(&quot;{}&quot;, a);


    // 作为函数返回值
    //
    // 实现一个缓存, 保存第一次处理后的值
    //
    struct Cache&lt;T&gt; where T: Fn(i32) -&gt; i32 {  // 函数类型作为泛型, Fn 是一个 trait
        calc: T, 
        value: Option&lt;i32&gt;,
    }
    impl&lt;T: Fn(i32) -&gt; i32&gt; Cache&lt;T&gt;{
        fn new(caculator: T) -&gt; Self {
            Cache {
                caculator: caculator,
                value: None,
            }
        }
        
        fn value(&amp;mut self, arg: i32) -&gt; i32 { 
            // 外层 match 没有 return, 没有 分号 
            match self.value {
                Some(v) =&gt; v, // 返回值只是返回给 match 表达式, 不是直接返回给了外层的函数, 若想直接返回给函数, 需要 return 关键字
                None =&gt; {
                    println!(&quot;第一次, arg = {}&quot;, arg);
                    let v = (self.caculator)(arg);// 必须有括号
                    self.value = Some(v);// self 必须可变
                    v
                }
            }
        }
    }
    let mut ca = Cache::new(|x| x+1);// 这里可以省略参数类型是因为类型信息定义在前面的泛型中了
    println!(&quot;arg = 1, v = {}&quot;, ca.value(1));
    println!(&quot;arg = 1, v = {}&quot;, ca.value(1));

    // 和 if 合用的匹配
    match value.log2() {
       x if x.is_normal() =&gt; Some(x),
       _                      =&gt; None
   }

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#if-lef-while-let-语法糖" id="if-lef-while-let-语法糖">if lef while let 语法糖</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    // if let 语法糖
    //适用于只区分两种情况的 match 语句
    // 语法:
    // if let 匹配值 = 源变量 {
    //    语句块
    // }
    //
    //
    enum Book {
        Papery(u32),
        Electronic(String)
    }
    let book = Book::Electronic(String::from(&quot;url&quot;));
    if let Book::Papery(index) = book {
        println!(&quot;Papery {}&quot;, index);
    } else {
        println!(&quot;Not papery book&quot;);
    }


    // 类似的还有 while let 语法糖
    while let Some(v) = xx_vec.pop() {
        println!(&quot;{}&quot;, v);
    }

    

}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#错误处理" id="错误处理">错误处理</a></h2>
<h3><a class="header" href="#断言" id="断言">断言</a></h3>
<pre><code class="language-rs">// assert 系列宏在调试( Debug)和发布( Release)模式下均可用， 并且不能被禁用。 debug_assert系列宏只在调试模式下起作用
// 尽量使用 debug_assert 系列宏较小性能开销
// 底层实际也是使用 panic! 宏引发线程恐慌

// • assert!， 用于断言布尔表达式在运行时一定返回 true。
// • assert_eq!， 用于断 言两个表达式是否相等(使用 PartialEq)。
// • assert_ne!， 用于断言两个表达式是否不相等(使用 PartialEq)。
// • debug_assert!， 等价于 asse此!，只能用于调试模式。
// • debug assert_eq!， 等价于 asse此一eq!，只能用于调试模式。
// • debug_assert_ne!， 等价于 assert ne!，只能用于调试模式 。

// 均会引发线程恐慌, 同时输出错误信息
assert! (x,&quot;x wasn’t true&quot;);
debug_assert!(a + b == 30,&quot;a={), b = {}&quot;, a, b);
</code></pre>
<h3><a class="header" href="#panic-和-abort" id="panic-和-abort">panic 和 Abort</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// panic 为线程恐慌, 会造成应用程 序以非零退出码退出进程， 也就是发生崩溃
// Abort 为线程终止, 将进程 正常中止 
// 
/// RUST_BACKTRACE=1 cargo run 这种方式运行带有回溯, 碰到 panic!(&quot;xxx&quot;) 会显示 backtrace
/// 
/// 如果想使一个可恢复错误按不可恢复错误处理(类比java 中 将 exceptin 转为 runtime exception)，Result 类提供了两个办法：unwrap() 和 expect(message: &amp;str) 
//  
/// 
/// https://rust-cli.github.io/book/tutorial/errors.html
/// 
fn error_handling() {

    // 使用 panic!() 宏: 对于不可恢复错误使用 panic! 宏来处理
    //
    let f = File::open(&quot;hello.txt&quot;);
    match f {
        Ok(file) =&gt; {
            println!(&quot;File opened successfully.&quot;);
        },
        Err(err) =&gt; {
            println!(&quot;Failed to open the file.&quot;);
            panic!(&quot;{:?}&quot;, err);
        }
    }
    //
    // if let 语法糖
    let f = File::open(&quot;hello.txt&quot;);
    if let Ok(file) = f {
        println!(&quot;File opened successfully.&quot;);
    } else {
        println!(&quot;Failed to open the file.&quot;);
       panic!(&quot;error&quot;); // panic 会中断程序, 若不希望中断程序, 不要 panic
    }

    // 简化写法: 直接解包装, 可恢复异常也会 panic
    //
    //不会为函数产生返回值, 而是直接 panic
    //
    let f1 = File::open(&quot;hello.txt&quot;).unwrap(); //原理: 在 Result 为 Err 时调用 panic! 宏
    let f2 = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open.&quot;);//expect 能够向 panic! 宏发送一段指定的错误信息
    // 自己控制是否 panic
    unwrap_or_else(|e| {  panic!(&quot;failed to execute process: {}&quot;, e)})
    //
  



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#result--和-问号操作符" id="result--和-问号操作符">Result  和 问号操作符</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// 可恢复错误, 用 Result&lt;T, E&gt; 类来处理，,类比 java 中 的 exception
/// //在 Rust 标准库中可能产生异常的函数的返回值都是 Result 类型的
/// enum Result&lt;T, E&gt; { 
///   Ok(T),
///   Err(E),
/// }


    // 异常传递, 函数返回值
    //
    fn func(i: i32) -&gt; Result&lt;i32, bool&gt; {
        if i &gt;= 0 { Ok(i) }
        else { Err(false) }
    }
    fn g(i: i32) -&gt; Result&lt;i32, bool&gt; {
        let t = func(i);
        return match t { // 或者省略 return 和分号
            Ok(i) =&gt; Ok(i), // 原样传给 match, match作为最终结构传给函数返回值
            Err(b) =&gt; Err(b)
        };
    }
    // 更好的写法: 
    //? 符的实际作用是将 Result 类非异常的值直接取出，如果有异常就将异常 Result 返回出去。所以，? 符仅用于返回值类型为 Result&lt;T, E&gt; 的函数
    //?号 是 “要么 unwrap 要么 return Err(From::from(err))”。
    //
    // 会为函数产生返回值
    //
    fn g1(i: i32) -&gt; Result&lt;i32, bool&gt; {
        let t = func(i)?;
        Ok(t) // 因为确定 t 不是 Err, t 在这里已经是 i32 类型
    }
    let r = g1(10000);
    if let Ok(v) = r {println!(&quot;ok, r = {}&quot;, v)}
    else { println!(&quot;Err&quot;)}



    // 获取 error 类型, 处理异常
    fn read_text_from_file(path: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
        let mut f = File::open(path)?;
        let mut s = String::new();
        f.read_to_string(&amp;mut s)?;
        Ok(s)
    }
    let str_file = read_text_from_file(&quot;hello.txt&quot;);
    match str_file {
        Ok(s) =&gt; println!(&quot;{}&quot;, s),
        Err(e) =&gt; {
            match e.kind() {
                io::ErrorKind::NotFound =&gt; {
                    println!(&quot;No such file&quot;);
                },
                _ =&gt; {
                    println!(&quot;Cannot read the file&quot;);
                }
            }
        }
    }

    // Result 的 map, and_then
    //
    // 类似 option, result也有自己的链式处理方法
    //
    use std::num::ParseIntError;
    fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
        // parse() 返回的是 result 类型
        first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
            second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
        })
    }
    // 更推荐的写法
    //
    // 推荐给 太长的类型起个别名
    type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;
    fn multiply1(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
        let first_number = first_number_str.parse::&lt;i32&gt;()?;
        let second_number = second_number_str.parse::&lt;i32&gt;()?;
    
        Ok(first_number * second_number)
    }

    //
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#错误装箱-自定义异常" id="错误装箱-自定义异常">错误装箱 自定义异常</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>    

<span class="boring">fn main() {
</span>    //
    //
    // 
    //装箱可以保存原始错误信息, 坏处就是，被包装的错误类型只能在运行时了解，而不能被静态地 判别。
    //
    //对任何实现了 Error trait 的类型，标准库的 Box 通过 From 为它们提供了 到 Box&lt;Error&gt; 的转换, 只要调用 XxxError.into() 即装箱
    //
    use std::error;
    use std::fmt;
    // 为 `Box&lt;error::Error&gt;` 取别名。
    type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;;
    // 自定义异常 /////////////////////////////
    // 还必须同时实现 Debug 和 Display
    #[derive(Debug, Clone)]
    struct EmptyVec;
    impl fmt::Display for EmptyVec {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            write!(f, &quot;invalid first item to double&quot;)
        }
    }
    impl error::Error for EmptyVec {
        fn description(&amp;self) -&gt; &amp;str {
            &quot;invalid first item to double&quot;
        }
        fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
            // 泛型错误。没有记录其内部原因。
            None
        }
    }
    // 将第一个数字乘以2
    fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
        vec.first()
        .ok_or_else(|| EmptyVec.into())  // 装箱
        .and_then(|s| {
                s.parse::&lt;i32&gt;()
                    .map_err(|e| e.into())  // 装箱
                    .map(|i| 2 * i)
            })
    }
    
    // 更好的写法: 使用 ? 号
    // ?号 是 “要么 unwrap 要么 return Err(From::from(err))”。From::from 是 不同类型间的转换工具，
    fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
        let first = vec.first().ok_or(EmptyVec)?;
        let parsed = first.parse::&lt;i32&gt;()?;
        Ok(2 * parsed)
    }



}


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#捕获异常" id="捕获异常">捕获异常</a></h3>
<pre><code class="language-rs">// 恐慌安全: 发生 panic后, 代码终止执行, 后续的资源回收相关的代码不会执行, 可能引发问题, 防止这样的问题就是保证恐慌安全

// rust 通过 raii机制, 保证了基本的恐慌安全, 即使在 safe rust 中发生 panic, 也能保证资源回收
// 但是若 panic 发生在 unsafe rust 里面, 就无法保证恐慌安全了

// catch_unwind 方法来让开发者捕获恐慌，恢复当前线程。
// 
// 接收的是一个正常的闭包，在该闭包中 并未发生恐慌，所 以正常执行
let result = panic::catch_unwind(|| { println!(&quot;hello!&quot;); });
assert!(result.is_ok());
// 捕获此恐慌，并恢复当前线程
let result = panic::catch_unwind(|| { panic!(&quot;oh no!&quot;); });// 输 出 结果 中打印 了恐慌信息，但是并没有影 响 到后续代码 的执行
assert!(result.is_err());
println!(&quot;{}&quot;, sum(1, 2));

// 使用 set_hook 自定义panic 消息消息
// set_hook 是全局性设置， 并不是只针对单个代码模块的, 可以和 take_hook 配合使用
// 
panic::set_hook(Box::new(|panic_info| {
    if let Some(location) = panic_info.location() {
        println!(&quot;panic occurred '{}' at {}&quot;,
            location.file(), location.line()
        );
    } else {
        println!(&quot;can't get location information...&quot;);
    }
}));
let result = panic::catch_unwind(|| { panic!(&quot;oh no!&quot;); });
assert!(result.is_err());
</code></pre>
<h3><a class="header" href="#错误处理进化过程" id="错误处理进化过程">错误处理进化过程</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    //
    // 直接解除包装
    // 
  // 读取文件内容, 一步到位
    let content = std::fs::read_to_string(&amp;args.path).unwrap();
// panic
    let content = match std::fs::read_to_string(&amp;args.path) {
        Ok(content) =&gt; content,
        Err(err) =&gt; panic!(&quot;&gt;&gt;&gt; Error occurred: {}&quot;, err),
    };
// 返回 error
    // 需要 main 返回 Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;
    let content = match std::fs::read_to_string(&amp;args.path) {
        Ok(content) =&gt; content,
        Err(error) =&gt; {return Err(error.into())},
    };
    
    // 使用问号
    main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        let content = std::fs::read_to_string(&amp;args.path)?;
    }

    // 添加错误上下文, 自定义异常
    main -&gt; Result&lt;(),SomeErr&gt; {
        let content = std::fs::read_to_string(&amp;args.path)
                .map_err(|err| SomeErr(format!(&quot;Error of reading {}: {}&quot;, &amp;args.path, err)))?;
    }
    
    // 使用第三方库
    use failure::ResultExt;
    use exitfailure::ExitFailure;
    let ref path: PathBuf = args.path;
    let content = std::fs::read_to_string(path)
        .with_context(|_| format!(&quot;could not read file {}&quot;, path.to_str().unwrap()))?;


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#第三方库处理异常" id="第三方库处理异常">第三方库处理异常</a></h3>
<p>error-chain和 failure(更推荐)</p>
<p>error chain 的特色是使用自定义的宏来方便开发者统一管理错误， </p>
<p>而 failure的错误管理思维则是对标准库中 En-or的进一步增强，更加贴近 Rust的错误处理思 想 </p>
<h2><a class="header" href="#io" id="io">io</a></h2>
<h3><a class="header" href="#命令行参数" id="命令行参数">命令行参数</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn io_demo() {
    //
    let args = std::env::args();
    println!(&quot;args: {:?}&quot;, args);//Args { inner: [&quot;target/debug/hello&quot;, &quot;main.rs&quot;] }
    for item in args {
        println!(&quot;arg: {}&quot;, item);
    }
    //arg: target/debug/hello
    //arg: main.rs

    args.next().unwrap();
    let arg0 = args.next().unwrap();// 命令本身, 拿到参数要两个 args.next()

    // 或者一步到位
    let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);

     // 或者通过 vector 收集
    let args: Vec&lt;String&gt; = env::args().collect();


    //
    //
    //命令行输入文本
    //
    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#文件-io" id="文件-io">文件 io</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    // 
    // //////////////////////////  文件 io //////////////
    //
    use std::fs;
    use std::io::prelude::*; //涉及到 write 需要 万能导入 prelude
    // 创建写入文件
    //
    //静态方法，以 可写 模式打开文件。
    //如果文件存在则清空旧内容
    //如果文件不存在则新建                  类似 echo &quot;xxxx&quot; &gt; path
    let mut file = fs::File::create(&quot;./cc.md&quot;).expect(&quot;create file error&quot;);
    file.write_all(&quot;hello &quot;.as_bytes()).expect(&quot;write error&quot;);
    file.write_all(&quot; world&quot;.as_bytes()).expect(&quot;write error&quot;);
    file.write_all(&quot;\n你好&quot;.as_bytes()).expect(&quot;write error&quot;);


    // 读取文件
    //
    // 一次性读取
    //
    //
    // 静态方法
    let text = std::fs::read_to_string(&quot;./Cargo.toml&quot;).unwrap(); // 相对路径是相对于根目录
    println!(&quot;{}&quot;, text);
    //
    // or
    let mut file = fs::File::open(&quot;./cc.md&quot;).expect(&quot;open error&quot;);// 只读模式打开, 相当于 cat &lt;path&gt;
    let mut str_buf = String::new();
    // 实例方法
    file.read_to_string(&amp;mut str_buf).expect(&quot;read error&quot;);
    println!(&quot;{}&quot;, str_buf);


    // 修改
    //  append() 用于将文件的打开模式设置为 追加模式
    //
    //此外还有 .read(true).write(true)
    // 比如  OpenOptions::new().create(true).write(true).open(path) 可创建, 可写模式打开 , 相当于 touch xxx , 有则不动, 无则创建
    //
    let mut file = fs::OpenOptions::new().append(true).open(&quot;./cc.md&quot;).unwrap();
    file.write_all(&quot;\nappend something...&quot;.as_bytes()).unwrap();
    let updated_content = fs::read_to_string(&quot;./cc.md&quot;).unwrap();
    println!(&quot;{}&quot;, updated_content);

    // 读写二进制文件
    // 文件流读取, 多次读取
    // 
    // or
    // 二进制 使用 std::fs::read(&quot;&quot;) 读取 u8 类型集合
    //
    // 复制文件的 demo:
    //
    let mut buffer = [0u8; 5];
    let mut file = fs::File::open(&quot;cc.md&quot;).unwrap();
    println!(&quot;文件打开成功：{:?}&quot;,file);//File { fd: 3, path: &quot;.../data.txt&quot;, read: true, write: false }
    file.read(&amp;mut buffer).unwrap();
    println!(&quot;{:?}&quot;, buffer);
    file.read(&amp;mut buffer).unwrap();
    println!(&quot;{:?}&quot;, buffer);

    // 删除
    fs::remove_file(&quot;cc.md&quot;).unwrap();



    // 其他文件系统操作
    //
    //
    // 创建 目录, 返回 io::Result&lt;()&gt;
    fs::create_dir(&quot;a&quot;) 
    //
    // 递归创建,目录
    fs::create_dir_all(&quot;a/c/d&quot;)

    // 创建符号链接
    //
    unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;)

    //读取目录下的所有的内容，返回 `io::Result&lt;Vec&lt;Path&gt;&gt;`
    //
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    // 移除一个空目录，返回 `io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;)



    println!(&quot;-----------------meta -------------------&quot;);
    // metadata 元数据
    //
    // 遍历目录
    let meta = fs::metadata(&quot;./src&quot;);
    /*
        Ok(Metadata {
            file_type: FileType(FileType {
                mode: 16895
            }),
            is_dir: true,
            is_file: false,
            permissions: Permissions(FilePermissions {
                mode: 16895
            }),
            modified: Ok(SystemTime {
                tv_sec: 1597127845,
                tv_nsec: 217049100
            }),
            accessed: Ok(SystemTime {
                tv_sec: 1597132516,
                tv_nsec: 30962100
            }),
            created: Err(Custom {
                kind: Other,
                error: &quot;creation time is not available for the filesystem&quot;
            })
        })
    */
    println!(&quot;meta = {:?}&quot;, meta);
    println!(&quot;src is dir? {}&quot;, meta.unwrap().is_dir());//true
}

fn copy_file() {
    let mut command_line: std::env::Args = std::env::args();
   command_line.next().unwrap();

   // 跳过程序名
   // 原文件
   let source = command_line.next().unwrap();

   // 新文件
   let destination = command_line.next().unwrap();
   let mut file_in = std::fs::File::open(source).unwrap();
   let mut file_out = std::fs::File::create(destination).unwrap();
   let mut buffer = [0u8; 4096];
   use std::io::Write;
   loop {
      let nbytes = file_in.read(&amp;mut buffer).unwrap();
      file_out.write(&amp;buffer[..nbytes]).unwrap();
      if nbytes &lt; buffer.len() { break; }// 如果某次读取没有将 buf 读满, 则写完后退出循环
   }
}


<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#面向对象-oop" id="面向对象-oop">面向对象 oop</a></h2>
<h3><a class="header" href="#可见性" id="可见性">可见性</a></h3>
<pre><code class="language-rs">// rust 下所有元素都是默认私有的, 无法在外部使用, 通过 pub 声明为 公开, 才能在外部使用
// 
// - pub， 可以对外 暴露 公共接口，隐藏内部实现细节 (可用于任何对象)
// - pub(crate)，对整个 crate 可见 。
// - pub(in Path)，其中 Path是模块路径(以 crate 开头), 表示只能在 Path 指定的模块中访问
// - pub(self)， 等价于 pub(in self)，表示只限当前模块可见/使用
// - pub(super)， 等价于 pub(in super)，表示在当前模块和父模块中可见
// 
// 
// 结构体中的字段, 需要单独使用 pub 关键字来 改变其 可见性 

// 2015 
pub mod outer_mod {
    pub(self) fn outer_mod_fn() {}
    pub mod inner_mod {
        // use outer_mod::outer_mod_fn;
        // 对外层模块 `outer_mod` 可见
        pub(in outer_mod) fn outer_mod_visible_fn() {}
        // 对整个crate可见
        pub(crate) fn crate_visible_fn() {}
        // `outer_mod` 内部可见
        pub(super) fn super_mod_visible_fn() {
            // 访问同一模块的函数
            inner_mod_visible_fn();
            // 访问父模块的函数需要使用“::”前缀
            ::outer_mod::outer_mod_fn();
        }
        // 仅在`inner_mod`可见
        pub(self) fn inner_mod_visible_fn() {}
    }
     
    pub fn foo() {
        inner_mod::outer_mod_visible_fn();
        inner_mod::crate_visible_fn();
        inner_mod::super_mod_visible_fn();
     
        // 不能使用inner_mod 的私有函数
        // inner_mod::inner_mod_visible_fn();
    }
}
fn bar() {
    // 该函数对整个crate可见
    outer_mod::inner_mod::crate_visible_fn();
 
    // 该函数只对outer_mod可见
    // outer_mod::inner_mod::super_mod_visible_fn();
 
    // 该函数只对outer_mod可见
    // outer_mod::inner_mod::outer_mod_visible_fn();
     
    // 通过foo函数调用内部细节
    outer_mod::foo();
}
fn main() { bar() }






// 2018
pub mod outer_mod {
    pub(self) fn outer_mod_fn() {}
     
    pub mod inner_mod {
        // 在Rust 2018 edtion 模块系统必须使用use导入
        use crate::outer_mod::outer_mod_fn;
        // 对外层模块 `outer_mod` 可见
        pub(in crate::outer_mod)  fn outer_mod_visible_fn() {}
        // 对整个crate可见
        pub(crate) fn crate_visible_fn() {}
        // `outer_mod` 内部可见
        pub(super) fn super_mod_visible_fn() {
            // 访问同一模块的函数
            inner_mod_visible_fn();
            // 使用use导入了outer_mod
            outer_mod_fn();
        }
        // 仅在`inner_mod`可见
        pub(self) fn inner_mod_visible_fn() {}
    }
     
    pub fn foo() {
        inner_mod::outer_mod_visible_fn();
        inner_mod::crate_visible_fn();
        inner_mod::super_mod_visible_fn();
     
        // 不能使用inner_mod 的私有函数
        // inner_mod::inner_mod_visible_fn();
    }
}
fn bar() {
    // 该函数对整个crate可见
    outer_mod::inner_mod::crate_visible_fn();
 
    // 该函数只对outer_mod可见
    // outer_mod::inner_mod::super_mod_visible_fn();
 
    // 该函数只对outer_mod可见
    // outer_mod::inner_mod::outer_mod_visible_fn();
     
    // 通过foo函数调用内部细节
    outer_mod::foo();
}
fn main() { bar() }
</code></pre>
<h3><a class="header" href="#多态" id="多态">多态</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>fn oop_demo() {

    // 多态
    //
    pub struct Screen {
        pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,// Box&lt;dyn Draw&gt; 为任何实现了 Draw trait 的类型的替身
    }

    // 另外多态例子
    //
    struct Rectangle {
        width : u32,
        height : u32,
    } 
    struct Circle {
        x : u32,
        y : u32,
        radius : u32,
    }
    trait  IShape  { 
        fn area(&amp;self) -&gt; f32;
        fn to_string(&amp;self) -&gt; String;
    }
    impl IShape  for Rectangle {
        fn area(&amp;self) -&gt; f32 { (self.height * self.width) as f32 }
        fn to_string(&amp;self) -&gt;String {
            format!(&quot;Rectangle -&gt; width={} height={} area={}&quot;, 
                    self.width, self.height, self.area())
        }
    }
    use std::f64::consts::PI;
    impl IShape  for Circle  {
        fn area(&amp;self) -&gt; f32 { (self.radius * self.radius) as f32 * PI as f32}
        fn to_string(&amp;self) -&gt; String {
            format!(&quot;Circle -&gt; x={}, y={}, area={}&quot;, 
                    self.x, self.y, self.area())
        }
    }

    // 使用
    use std::vec::Vec;
    let rect = Box::new( Rectangle { width: 4, height: 6});
    let circle = Box::new( Circle { x: 0, y:0, radius: 5});
    let mut v : Vec&lt;Box&gt; = Vec::new();
    v.push(rect);
    v.push(circle);
    for i in v.iter() {
        println!(&quot;area={}&quot;, i.area() );
        println!(&quot;{}&quot;, i.to_string() );
    }



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#向下转型" id="向下转型">向下转型</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>


<span class="boring">fn main() {
</span>    //向下转型
    //
    //
    //先得让 IShape 继承于 Any ，并增加一个 as_any() 的转型接口
    use std::any::Any;
    trait  IShape : Any + 'static  {
        fn as_any(&amp;self) -&gt; &amp;dyn Any; 
        …… …… …… 
    }
    //然后，在具体类中实现这个接口
    impl IShape  for Rectangle {
        fn as_any(&amp;self) -&gt; &amp;dyn Any { self }
        …… …… …… 
    }
    impl IShape  for Circle  {
        fn as_any(&amp;self) -&gt; &amp;dyn Any { self }
        …… …… …… 
    }
    let mut v : Vec&lt;Box&lt;dyn IShape&gt;&gt; = Vec::new();
    v.push(rect);
    v.push(circle);
    for i in v.iter() {
        if let Some(s) = i.as_any().downcast_ref::&lt;Rectangle&gt;() {
            println!(&quot;downcast - Rectangle w={}, h={}&quot;, s.width, s.height);
        }else if let Some(s) = i.as_any().downcast_ref::&lt;Circle&gt;() {
            println!(&quot;downcast - Circle x={}, y={}, r={}&quot;, s.x, s.y, s.radius);
        }else{
            println!(&quot;invaild type&quot;);
        }
    }



    
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#设计模式" id="设计模式">设计模式</a></h3>
<h4><a class="header" href="#建造者模式" id="建造者模式">建造者模式</a></h4>
<pre><code class="language-rs">// std::process::Command 就使用了 建造者模式


struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}
struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}
impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
    fn new() -&gt; CircleBuilder {
        CircleBuilder {
            x: 0.0, y: 0.0, radius: 1.0,
        }
   }
}
impl CircleBuilder {
   fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
       self.x = coordinate;
       self
   }
   fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
       self.y = coordinate;
       self
   }
   fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {
       self.radius = radius;
      self
   }
   fn build(&amp;self) -&gt; Circle {
       Circle {
           x: self.x, y: self.y, radius: self.radius,
       }
   }
}
</code></pre>
<h4><a class="header" href="#访问者模式" id="访问者模式">访问者模式</a></h4>
<pre><code class="language-rs">// 用于将数据结构和作用于结构上的操作解祸。
// 访问者模式一般包含两个层 次:
// - 定义需要操作的元素。
// - 定义相关的操作. 一般将操作封装到一个 trait 中, 针对不同的元素, 有不同的方法实现
// Serde的架构是访问者模式


use std::any::Any;
trait HouseElement {
    fn accept(&amp;self, visitor: &amp;HouseElementVisitor);
    fn as_any(&amp;self) -&gt; &amp;Any;
}
trait HouseElementVisitor {
    fn visit(&amp;self, element: &amp;HouseElement);
}
struct House {
    components: Vec&lt;Box&lt;HouseElement&gt;&gt;,
}
impl House {
    fn new() -&gt; Self {
        House {
            components: vec![Box::new(Livingroom::new())],
        }
    }
}
impl HouseElement for House {
    fn accept(&amp;self, visitor: &amp;HouseElementVisitor) {
        for component in self.components.iter() {
            component.accept(visitor);
        }
        visitor.visit(self);
    }
    fn as_any(&amp;self) -&gt; &amp;Any { self }
}

struct Livingroom;
impl Livingroom {
    fn new() -&gt; Self { Livingroom }
}
impl HouseElement for Livingroom {
    fn accept(&amp;self, visitor: &amp;HouseElementVisitor) {
        visitor.visit(self);
    }
    fn as_any(&amp;self) -&gt; &amp;Any { self }
}

struct HouseElementListVisitor;
impl HouseElementListVisitor {
    fn new() -&gt; Self { HouseElementListVisitor }
}

impl HouseElementVisitor for  HouseElementListVisitor {
    fn visit(&amp;self, element: &amp;HouseElement) {
        match element.as_any() {
            house if house.is::&lt;House&gt;() =&gt; println!(&quot;Visiting the house...&quot;),
            living if living.is::&lt;Livingroom&gt;() =&gt; println!(&quot;Visiting the Living room...&quot;),
            _ =&gt; {}
        }
    }
}
struct HouseElementDemolishVisitor;
impl HouseElementDemolishVisitor {
    pub fn new() -&gt; Self {
        HouseElementDemolishVisitor
    }
}
impl HouseElementVisitor for HouseElementDemolishVisitor {
    fn visit(&amp;self, element: &amp;HouseElement) {
        match element.as_any() {
            house if house.is::&lt;House&gt;() =&gt; println!(&quot;Annihilating the house...!!!&quot;),
            living if living.is::&lt;Livingroom&gt;() =&gt; println!(&quot;Bombing the Living room...!!!&quot;),
            _ =&gt; {}
        }
    }
}

fn main() {
    let house = House::new();
    // simply print out the house elements
    house.accept(&amp;HouseElementListVisitor::new());
    println!();
    // do something with the elements of a house
    house.accept(&amp;HouseElementDemolishVisitor::new());
}
</code></pre>
<h4><a class="header" href="#raii模式" id="raii模式">raii模式</a></h4>
<p>重构后的代码:</p>
<pre><code class="language-rs">/*
利用Rust的ownership（linear/affine type）来设计接口

Refact

1. 去掉letter的Clone，使用所有权保证其唯一性；并且信封的wrap方法只接受获得所有权的信封，而非引用
2. 使用类型系统来保证信封的唯一性
3. 使用RAII机制来管理收尾逻辑，比如实现Drop

其他示例：

1. http response
2. steaming engine

*/

// #[derive(Clone)]
pub struct Letter {
    text: String,
}
pub struct EmptyEnvelope {}
pub struct ClosedEnvelope {
    letter: Letter,
}
pub struct PickupLorryHandle {
    done: bool,
}
impl Letter {
    pub fn new(text: String) -&gt; Self {
        Letter {text: text}
    }
}
impl EmptyEnvelope {
    pub fn wrap(self, letter: Letter) -&gt; ClosedEnvelope {
        ClosedEnvelope {letter: letter}
    }
}
pub fn buy_prestamped_envelope() -&gt; EmptyEnvelope {
    EmptyEnvelope {}
}
impl PickupLorryHandle {
    pub fn pickup(&amp;mut self, envelope: ClosedEnvelope) {
        /*give letter*/
    }
    pub fn done(self) {}
}
impl Drop for PickupLorryHandle {
    fn drop(&amp;mut self) {
        println!(&quot;sent&quot;);
    }
}
pub fn order_pickup() -&gt; PickupLorryHandle {
    PickupLorryHandle {done: false , /* other handles */}
}
fn main(){
    let letter = Letter::new(String::from(&quot;Dear RustFest&quot;));
    let envelope = buy_prestamped_envelope();
    let closed_envelope = envelope.wrap(letter);
    let mut lorry = order_pickup();
    lorry.pickup(closed_envelope);
}

</code></pre>
<p>有问题的代码:</p>
<pre><code class="language-rs">/*
利用Rust的ownership（linear/affine type）来设计接口

存在的问题：

1. Letter有可能复制多份到多个信封（envelope）里，不安全
2. 信封里有可能有信，也有可能没有信, 可能寄出的是空信封；或者同一个信封装多次不同的信件, 造成信件的覆盖，不安全
3. 有没有把信交给邮车也是无法保证，不安全

*/
// 信纸
#[derive(Clone)]
pub struct Letter {
    text: String,
}
// 信封
pub struct Envelope {
    letter: Option&lt;Letter&gt;,
}
// 信件处理器
pub struct PickupLorryHandle {
    done: bool,//是否寄出
}
impl Letter {
    pub fn new(text: String) -&gt; Self {
        Letter {text: text}
    }
}
impl Envelope {
    // 装信纸进去
    pub fn wrap(&amp;mut self, letter: &amp;Letter){
        self.letter = Some(letter.clone());
    }
}
// 创建空的信封
pub fn buy_prestamped_envelope() -&gt; Envelope {
    Envelope {letter: None}
}
impl PickupLorryHandle {
    // 装车
    pub fn pickup(&amp;mut self, envelope: &amp;Envelope) {
        /*give letter*/
    }
    // 寄出
    pub fn done(&amp;mut self) {
        self.done = true;
        println!(&quot;sent&quot;);
    }
}
// 创建处理器
pub fn order_pickup() -&gt; PickupLorryHandle {
    PickupLorryHandle {done: false , /* other handles */}
}
fn main(){
    let letter = Letter::new(String::from(&quot;Dear RustFest&quot;));
    let mut envelope = buy_prestamped_envelope();
    envelope.wrap(&amp;letter);
    let mut lorry = order_pickup();
    lorry.pickup(&amp;envelope);
    lorry.done();
}

pub fn builder_pattern(){
    unimplemented!();
}
</code></pre>
<h2><a class="header" href="#子进程" id="子进程">子进程</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// 子进程
/// 
/// process::Output 结构体表示已结束的子进程（child process）的输出，而 process::Command 结构体是一个进程创建者
/// 
/// std::Child 结构体代表了一个正在运行的子进程，它暴露了 stdin（标准 输入），stdout（标准输出） 和 stderr（标准错误） 句柄，
/// 从而可以通过管道与 所代表的进程交互
/// 
fn sub_process_command() {
    println!(&quot;-------------sub_process_command--------------&quot;);
    use std::process::Command;

    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;failed to execute process: {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);
    }

    // 管道
    //
    //
    use std::error::Error;
    use std::io::prelude::*; // 隐藏导入 万能导入
    use std::process::{Stdio};

    static PANGRAM: &amp;'static str = &quot;the quick brown fox jumped over the lazy dog\n&quot;;
    // 启动 `wc` 命令
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why.description()),
        Ok(process) =&gt; process,
    };
    // 将字符串写入 `wc` 的 `stdin`。
    //
    // `stdin` 拥有 `Option&lt;ChildStdin&gt;` 类型，不过我们已经知道这个实例不为空值，
    // 因而可以直接 `unwrap 它。
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;, why.description()),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // 因为 `stdin` 在上面调用后就不再存活，所以它被 `drop` 了，管道也被关闭。
    //
    // 若管道不关闭,  `wc` 就不会开始处理我们刚刚发送的输入。

    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;,
                           why.description()),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }

    // 等待
    //
    //如果你想等待一个 process::Child 完成，就必须调用 Child::wait，这会返回 一个 process::ExitStatus。
    //
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap(); // 必须调用 wait() 等待
    println!(&quot;reached end of main&quot;);

}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#ffi-外部语言函数接口" id="ffi-外部语言函数接口">ffi 外部语言函数接口</a></h2>
<p>https://www.cnblogs.com/Jackeyzhe/p/12623689.html</p>
<p>https://rustcc.cn/article?id=3b8241d0-c4ca-4f49-8e07-0a5142b00f59</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>


<span class="boring">fn main() {
</span>///外部语言函数接口
/// 
/// Rust 提供了到 C 语言库的外部语言函数接口（Foreign Function Interface，FFI）。
/// 外 部语言函数必须在一个 extern 代码块中声明，且该代码块要带有一个包含库名称 的 #[link] 属性
/// 
fn ffi() {
    // 单精度复数的最简实现
    #[repr(C)]
    #[derive(Clone, Copy)]
    struct Complex {
        re: f32,
        im: f32,
    }
    impl fmt::Debug for Complex {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            if self.im &lt; 0. {
                write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
            } else {
                write!(f, &quot;{}+{}i&quot;, self.re, self.im)
            }
        }
    }
    // 这个 extern 代码块链接到 libm 库
    #[link(name = &quot;m&quot;)]
    extern {
        // 这个外部函数用于计算单精度复数的平方根
        fn csqrtf(z: Complex) -&gt; Complex;

        // 这个用来计算单精度复数的复变余弦
        fn ccosf(z: Complex) -&gt; Complex;
    }
    // 由于调用其他语言的函数被认为是不安全的，我们通常会给它们写一层安全的封装
    fn cos(z: Complex) -&gt; Complex {
        unsafe { ccosf(z) }
    }

    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };
    // 调用外部语言函数是不安全操作
    let z_sqrt = unsafe { csqrtf(z) };
    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);
    // 调用不安全操作的安全的 API 封装
    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#反射" id="反射">反射</a></h2>
<pre><code class="language-rs">// 标准库提供了 std::any::Any 来支持运行时反射。
// 可以接收任何静态生命周期类型 即 'static 类型, 不能接收非静态生命周期的类型

   let v1 = 0xc0ffee_u32;
    let v2 = E::He;
    let v3 = S { x: 0xde, y: 0xad, z: 0xbeef };
    let v4 = &quot;rust&quot;;
    let mut a: &amp;Any; // trait object
    a = &amp;v1;
    // 判断是否属于某种类型
    assert!(a.is::&lt;u32&gt;());
    // 全局唯一类型标识符
    // 等价 get_type_id()
    // TypeId { t: 12849923012446332737 }
    println!(&quot;{:?}&quot;, TypeId::of::&lt;u32&gt;());   
    a = &amp;v2;
    assert!(a.is::&lt;E&gt;());
    // TypeId { t: 15527215023668350898 }
    println!(&quot;{:?}&quot;, TypeId::of::&lt;E&gt;());   
    a = &amp;v3;
    assert!(a.is::&lt;S&gt;());
    // TypeId { t: 17868507538031848664 }
    println!(&quot;{:?}&quot;, TypeId::of::&lt;S&gt;());   
    a = &amp;v4;
    assert!(a.is::&lt;&amp;str&gt;());
    // TypeId { t: 1229646359891580772 }
    println!(&quot;{:?}&quot;, TypeId::of::&lt;&amp;str&gt;());


    // 向下转型为具体类型
    use std::any::Any;
    #[derive(Debug)]
    enum E { H, He, Li}
    struct S { x: u8, y: u8, z: u16 }
    // 参数除使用&amp;Any外，也可以使用 Box&lt;Any&gt;
    fn print_any(a: &amp;Any) {
        if let Some(v) = a.downcast_ref::&lt;u32&gt;() {
            println!(&quot;u32 {:x}&quot;, v);
        } else if let Some(v) = a.downcast_ref::&lt;E&gt;() {
            println!(&quot;enum E {:?}&quot;, v);
    } else if let Some(v) = a.downcast_ref::&lt;S&gt;() {
        println!(&quot;struct S {:x} {:x} {:x}&quot;, v.x, v.y, v.z);
    } else {
        println!(&quot;else!&quot;);
    }
    }
    fn main() {
        print_any(&amp; 0xc0ffee_u32);                       
        print_any(&amp; E::He);                             
        print_any(&amp; S{ x: 0xde, y: 0xad, z: 0xbeef }); 
        print_any(&amp; &quot;rust&quot;);                           
        print_any(&amp; &quot;hoge&quot;);                           
    }



    // 非静态生命周期的类型未实现Any, 无法被 Any 类型接收
    use std::any::Any;
    struct UnStatic&lt;'a&gt; { x: &amp;'a i32 }
    fn main() {
        let a = 42;
        let v = UnStatic { x: &amp;a };
        let mut any: &amp;Any;
        any = &amp;v;  // Compile Error!
    }
    //ok
    // 因为 使用了 静态生命周期类型来创建 UnStatic, 使得 UnStatic 也变为 了静态生命周期类型
    static ANSWER: i32 = 42;
    fn main() {
        let v = UnStatic { x: &amp;ANSWER };
        let mut a: &amp;Any;
        a = &amp;v;
        assert!(a.is::&lt;UnStatic&gt;());
    }
</code></pre>
<h2><a class="header" href="#宏" id="宏">宏</a></h2>
<h3><a class="header" href="#内置宏" id="内置宏">内置宏</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>todo!()

print!()
println!()
eprintln!(&quot; = {:?}&quot;, );

vec!

panic!



#[derive(Debug)] 调试打印 struct

#[allow(dead_code)] 用于屏蔽对未使用代码的警告


// 通过这个属性屏蔽警告。
#[allow(non_camel_case_types)]

#[cfg(test)]

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#创建宏" id="创建宏">创建宏</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>/// 创建宏
/// 可进行元编程（metaprogramming）
/// 宏并不产 生函数调用，而是展开成源码，并和程序的其余部分一起被编译
/// 
/// 使用场景:
/// - 避免重复代码 (https://doc.rust-lang.org/stable/rust-by-example/macros/dry.html)
/// - 领域专用语言（DSL，domain-specific language）。宏允许你为特定的目的创造特定的 语法
/// - 可变接口（variadic interface）。有时你需要能够接受不定数目参数的接口，比如 println!
/// 
fn macro_demo() {
    // 这是一个简单的宏，名为 `say_hello`。
    macro_rules! say_hello {
        // `()` 表示此宏不接受任何参数。
        () =&gt; (
            // 此宏将会展开成这个代码块里面的内容。
            println!(&quot;Hello cacro!&quot;);
        )
    }

    // 这个调用将会展开成 `println(&quot;Hello&quot;);`!
    say_hello!();



    // 指示符
    /*
    block
    expr 用于表达式
    ident 用于变量名或函数名
    item
    pat (模式 pattern)
    path
    stmt (语句 statement)
    tt (标记树 token tree)
    ty (类型 type)
    
    */
    //宏的参数使用一个美元符号 $ 作为前缀，并使用一个指示符（designator）来 注明类型
    macro_rules! create_function {
        // `ident` 指示符, 标识 func_name 是变量名或函数名
        ($func_name:ident) =&gt; (
            fn $func_name() {
                // `stringify!` 宏把 `ident` 转换成字符串。
                println!(&quot;You called {:?}()&quot;, stringify!($func_name))
            }
        )
    }
    // 借助上述宏来创建名为 `foo` 和 `bar` 的函数。
    create_function!(foo);
    create_function!(bar);
    
    macro_rules! print_result {
        // `expr` 指示符表示输入参数为一个表达式。
        ($expression:expr) =&gt; (
            println!(&quot;{:?} = {:?}&quot;,
                     stringify!($expression),// `stringify!` 把表达式*原样*转换成一个字符串。
                     $expression)// 执行表达式
        )
    }
    foo();
    bar();
    print_result!(1u32 + 1);
    //代码块也是表达式！
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });


<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#宏重载" id="宏重载">宏重载</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>    // 宏重载
    //宏可以重载，从而接受不同的参数组合。在这方面，macro_rules! 的作用类似于 匹配（match）代码块
    //
    // 根据你调用它的方式，`test!` 将以不同的方式来比较 `$left` 和 `$right`。
    macro_rules! test {
        // 参数不需要使用逗号隔开。
        // 参数可以任意组合！
        ($left:expr; and $right:expr) =&gt; (
            println!(&quot;{:?} and {:?} is {:?}&quot;,
                    stringify!($left),
                    stringify!($right),
                    $left &amp;&amp; $right)
        );
        // ^ 每个分支都必须以分号结束。
        ($left:expr; or $right:expr) =&gt; (
            println!(&quot;{:?} or {:?} is {:?}&quot;,
                    stringify!($left),
                    stringify!($right),
                    $left || $right)
        )// 最后一个分支可以省略分号
    }
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);




    // 不定参数 可变接口
    //宏在参数列表中可以使用 + 来表示一个参数可能出现一次或多次，使用 * 来表示该 参数可能出现零次或多次
    //
    // `min!` 将求出任意数量的参数的最小值。
    macro_rules! find_min {
        // 基本情形：
        ($x:expr) =&gt; ($x);
        // `$x` 后面跟着至少一个 `$y,`
        ($x:expr, $($y:expr),+) =&gt; (
            // 对 `$x` 后面的 `$y` 们调用 `find_min!` 
            std::cmp::min($x, find_min!($($y),+))
        )
    }
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2 , 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));

    // 创造 dsl
    //
    macro_rules! calculate {
        (eval $e:expr) =&gt; {{
            {
                let val: usize = $e; // 强制类型为整型
                println!(&quot;{} = {}&quot;, stringify!{$e}, val);
            }
        }};
    }
    calculate! {
        eval 1 + 2 // `eval` 可并不是 Rust 的关键字！
    }
    calculate! {
        eval (1 + 2) * (3 / 4)
    }

    // 升级版 dsl
    // 可接受多个参数
    //
    macro_rules! calculate {
        // 单个 `eval` 的模式
        (eval $e:expr) =&gt; {{
            {
                let val: usize = $e; // Force types to be integers
                println!(&quot;{} = {}&quot;, stringify!{$e}, val);
            }
        }};
    
        // 递归地拆解多重的 `eval`
        (eval $e:expr, $(eval $es:expr),+) =&gt; {{
            calculate! { eval $e }
            calculate! { $(eval $es),+ }
        }};
    }
    calculate! { // 妈妈快看，可变参数的 `calculate!`！
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }



<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#过程宏" id="过程宏">过程宏</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>


<span class="boring">fn main() {
</span>    // 过程宏
    //
    // 接受 rust 代码作为输入,  修改后, 输出;
    // 前面的声明宏: 输入代码, 通过 match 匹配, 以另外的代码替换输出

    // 自定义 derive 宏
    //
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unsafe-屏蔽内存安全检查" id="unsafe-屏蔽内存安全检查">unsafe 屏蔽内存安全检查</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>/// 屏蔽内存安全检查
/// - 解引用裸指针 (创建裸指针无需在 unsafe 中)
/// - 调用不安全的函数
/// - 访问修改可变静态变量
/// - 实现不安全的 trait
fn unsafe_demo() {

    // 裸指针 (raw pointer)
    //
    // 分为:
    // 不可变裸指针   *const T
    // 可变裸指针     *mut T
    //
    // - 裸指针允许忽略借用规则: 某个对象可以同时拥有可变不可变裸指针, 或者多个同时指向相同位置的可变裸指针
    // - 不保证指向的内存是有效的
    // - 允许为空
    // - 没有任何自动清理的功能
    // 
    let mut a = 1;
    let rp1 = &amp; a as *const i32;
    let rp2 = &amp;mut a as *mut i32;
    unsafe {
        println!(&quot;rp1 = {}&quot;, *rp1);
        println!(&quot;rp2 = {}&quot;, *rp2);
    }

    // 
    //
    unsafe fn danger() {
        println!(&quot;dangerous&quot;);
    }
    unsafe {
        danger();
    }

}


<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#内存管理" id="内存管理">内存管理</a></h1>
<h2><a class="header" href="#堆-和-栈" id="堆-和-栈">堆 和 栈</a></h2>
<p>手动管理内存 -&gt; bug (内存泄漏, 垂悬指针)</p>
<p>gc -&gt; 性能问题(stop the world, 因为GC 在工作的 时候必须保证程序不会引入新的“垃圾&quot;, 所以要使运行中的程序暂停)</p>
<ul>
<li>
<p>虚拟内存管理技术: 对物理存储设备的抽象, 方便同时运行 多道程序 ，使得每个进程都有各自独立的进程地址空间</p>
</li>
<li>
<p>虚拟地址空间: (用户所接触到的地址都是虚拟地址，而不是真实 的物理地址)</p>
<ul>
<li>
<p>是线性空间, 分为 用户空 间和内核空间 (它们的比例是 3:1 (Linux系统中)或 2:2 (Windows系统中))</p>
<p>32 位计算机Linux的地址空间大小是 4GB</p>
</li>
<li>
<p>好处:</p>
<ul>
<li>
<p>用户程序可以使用比物理内存更大的地址空间</p>
</li>
<li>
<p>保护操作系统，让进程在各自的地址空间内操作内存</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用户空间中的 栈 (stack), 堆 (heap)</p>
<ul>
<li>
<p>栈 (堆栈): 用 于支持 CPU 入栈或出栈的指令操作, 如函数嵌套调用时需要存储方法栈帧</p>
<p>stack 内存中保存的数据，生命周期都比较短，会随着函数调用的完成而消亡, </p>
<p>对于基本原生数据类型来说， Rust 是默认将其分配到栈中的</p>
<p>结构体或枚举, 联合体只是定义，看它们被分配在哪 ，主要是看其类型实例如 何使用</p>
</li>
<li>
<p>堆: 一块巨大的内存空间, 长久地保存在内存中的数据，以便跨函数使用;程序不可以主动申请桔 内存，但可以主动申请堆内存</p>
</li>
<li>
<p>堆分配算法: 空闲链表 (Free List)和位图标记 (Bitmap)。</p>
<p>空闲链表实际上就是把堆中空闲的内存地址记录为链表 ， 当系统收到程序申请时，会遍 历该链表:当找到适合的空间堆节点 时， 会将此节点从链表中删除;当空间被回收以后 ， 再 将其加到空闲链表中。空闲链表的优势是实现简单，但如果链表遭到破坏 ， 整个堆就无法正 常工作。</p>
<p>位图的核心思想是将整个堆划分为大量大小相等的块。 当程序申请内存时，总是分配整 数个块的空间。每块内存都用一个二进制位来表示其状态，如果该内存被占用 ，则相应位图 中的位置置为 1;如果该内存空闲，则相应位图中的位置置为 0。位图的优势是速度快，如 果单个内存块数据遭到破坏， 也不会影响整个堆，但缺点是容易产生内存碎片</p>
</li>
<li>
<p>内存释放: 分配的都是虚拟地址空 间 。 所以当堆空间被释放时，并不代表指物理 空 间也 马上被释放, 只是内存被归还给了内存分配器。 内存分配 器会对空闲的 内存进行统一 “整理”, 在适合( 比如空闲内存达到 2048KB)的时候，才会把 内存归还给系统 ，也就是指释放物理空 间</p>
<p>Rust 编译器目前自带两个默认分配 器: alloc_system 和 alloc_jemalloc, Rust 2018 版本 下， 默认使用 alloc_system, 可以自己指定</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#内存对齐" id="内存对齐">内存对齐</a></h2>
<p>内存对齐, 即字节对齐, 减少 cpu 读取内存次数</p>
<p>CPU在单位时间/一次计算能处理的位数 -&gt; 字长, 32位CPU， 其字长为32位，也就是一次读取4个字节, 所以每次只能对 4 的 倍数的 地址 进行读取</p>
<p>现有一整数类型的数据，首地址并不是 4 的倍数，不妨设为 Ox3, 存储在 地址范围是 Ox3~Ox7 的存储空间, cpu 需要分别在 Ox1 和 Ox5 处进行两次读取, 采取内存对齐策略后, 数据的首地址变为 0x5, CPU只需要读取一次。</p>
<pre><code class="language-rs">// 对应到代码层面:
struct A {
    a: u8,// 1byte
    b: u32,// 4byte
    c: u16,  // 2 byte
}
println!(&quot;{:?}&quot;, std :: mem::size o f : : &lt; A &gt; ( );// 8 , 单位 字节

// 分析:
// 总共是 7, 为什么打印 8 ?
// 因为存在内存对齐策略
// 
// 内存对齐包括基本数据对齐和结构体(或联合体)数据对齐
// 对于基本数据类型，默认 对齐方式是按其大小进行对齐，也被称作自然对齐。 比如Rust中u32类型占4字节，则它默 认对齐方式为 4 字节对齐
</code></pre>
<h1><a class="header" href="#工程管理-模块" id="工程管理-模块">工程管理 模块</a></h1>
<h2><a class="header" href="#概念简单解释" id="概念简单解释">概念简单解释</a></h2>
<p>https://www.jianshu.com/p/51693602114a
https://zhuanlan.zhihu.com/p/73544030
or
https://privaterookie.github.io/2019-07-14-Rust%E6%A8%A1%E5%9D%97%E4%B8%8E%E6%96%87%E4%BB%B6/</p>
<pre><pre class="playpen"><code class="language-rust">/// - 箱（Crate）: 二进制程序文件or 库文件, 位于包中
/// 
/// - 包（Package）: cargo new xxx 新建的 就是 包; 包必须由一个 Cargo.toml 文件来管理，该文件描述了包的基本信息以及依赖项。
///
///    一个 package 最少有一个 crate
///
///    当使用 cargo new 命令创建完包之后，src 目录下会生成一个 main.rs 源文件，Cargo 默认这个文件为二进制箱的根，编译之后的二进制箱将与包名相同。
///
/// - 模块（Module）: 使用 mod 声明一个模块, 一个文件默认就是一个 module, 文件名就是 module name
// 
//      每个包都拥有一个顶级 (top level) 模块 src/lib.rs 或 src/main.rs。
/// 
///     每个 rust 文件都是一个 module, 比如: 
//      (若想在同个文件定义多个 module , 只需 mod xx_module {...} mod yy_module {...})
///     ```
///     // main.rs
///     mod second_module; // 声明一个模块
///     fn main() {
///         println!(&quot;This is the main module.&quot;);
///         println!(&quot;{}&quot;, second_module::message());
///     }
///     // second_module.rs, 模块名就是文件名
///     pub fn message() -&gt; String {
///         String::from(&quot;This is the 2nd module.&quot;)
///     }
///     ```
// 
//      若希望多个 文件, 组成一个 module,
//      需要:
//      合并到一个文件夹, 新建一个 mod.rs (2018 中可以省略了), 然后在其中导出即可 (pub use sub1; pub use sub2;), 新 module name = 文件夹名
// 
//      若文件夹 和某个文件 aa.rs 同名, 则文件夹下定义的 module 都是 aa.rs 的子模块 (2015 中则不允许文件与目录同名)
// 
// 
fn mod_package_crate() {

    // 路径:
    // Rust 中的路径分隔符是 ::
    
    //绝对路径从 crate 关键字开始描述。
    // 相对路径从 self 或 super 关键字或一个标识符开始描述

    // 如: 导入外部依赖
    use super::{deserial, serial}; //导入 parent 指定资源
    use super::*; // 导入 parent 的所有
    use crate::codec::{serial, deserial}; // 绝对路径, codec 为依赖 (不论是自定义模块还是第三方依赖, 若为第三方模块, 则 crate 关键字可选), codec 也能是 同个项目的其他 module (rust 文件)

//  标准库 默认导入了, 所以以下两句可选
    extern crate std; // 导入 标准库 std crate, 这是 2015 中的语法, 2018 中可选了, 只需要 cargo.toml 中导入即可, 无需再代码中显式指定
    use std : :prelude: :vl: :* ; // 标准库的 prelude module

    // 在 module 开头声明不需要 标准库, 使用 核心库(嵌入式开发必须)
    #[no_std]




    // govern 函数的绝对路径
    crate::nation::government::govern();
    // 相对路径
    nation::government::govern();


    //Rust 中有两种简单的访问权：公共（pub）和私有（模块成员默认都是私有）。
    // 私有 模块中的元素都需要 pub 修饰才能在外部访问到 , 但是 枚举类的字段不受这个限制
    //对于私有的模块，只有在与其平级的位置或下级的位置才能访问，不能从其外部访问。
    mod nation {
        pub mod government {
            pub fn govern() {println!(&quot;govern()&quot;)}
        }
    
        mod congress {
            pub fn legislate() {
                println!(&quot;legislate()&quot;);
            }
        }
       
        pub mod court {
            pub fn judicial() {
                print!(&quot;judicial - &quot;);
                super::congress::legislate();
            }
        }

        // use 关键字可以与 pub 关键字配合使用：
        pub use congress::legislate as le;

    }
    
    nation::government::govern();
    nation::court::judicial();

    // 导入 and 简化路径
    use nation::court::judicial as  ju;
    // 现在可以直接使用
    ju();

    nation::le();
}

</code></pre></pre>
<h2><a class="header" href="#编译器版本管理" id="编译器版本管理">编译器版本管理</a></h2>
<p>在项目根目录下, 放 rust-toolchain 文件, 指定编译器版本</p>
<h2><a class="header" href="#为项目单独指定config-配置" id="为项目单独指定config-配置">为项目单独指定config 配置</a></h2>
<pre><code>cargo 全局配置 : /.cargo/confg
当前用户全局配置: $HOME/.cargo/config
项目单独配置:     $proj/.cargo/config (子模块亦可继续指定)

</code></pre>
<h2><a class="header" href="#依赖管理-cargo" id="依赖管理-cargo">依赖管理 cargo</a></h2>
<h3><a class="header" href="#cargo-基本命令" id="cargo-基本命令">cargo 基本命令</a></h3>
<pre><code class="language-sh"># 新建可执行程序, 默认是 --bin
# 生成 main.rs 启动类
cargo new [--bin] &lt;proj&gt;

# 不初始化 git
cargo new &lt;proj&gt; --vcs none

# 新建库, 在项目根目录下
# 生成 的库下, 有 src, toml, lib_name.rs (带有基本的测试)
cargo new --lib &lt;lib name&gt;


# 在当前文件夹下新建项目
cargo init [--bin]
cargo init --lib




# 构建, 更新依赖, 依赖在这里找 https://crates.io/
# 默认是以 debug 方式编译, 编译速度快, 但是生成的可执行文件未优化
# build 后会生成 Cargo.lock
#  ./target/debug/project_name 中找到编译后的 可执行文件(exe) 运行
cargo build 

# 使用 --release 参数编译最终发布版本。
# 编译器会对代码进行优化， 使得编译时间变慢， 但是代码运行速度会变快。
cargo build --release

# 指定条件编译属性 (可以在 Cargo.toml 中指定)
# 会给 rustc 传递 --cfg features=&quot;xxx&quot;, 表示 会编译 aa_module 模块, 不指定 xxx feature 则不会编译 该模块
cargo build --features &quot;xxx&quot;
# 在代码中这么使用
#   # 表示若没有指定 xxx feature, 则编译报错
#   #[cfg(not(feature = &quot;xxx&quot;))]
#   compile_error!(&quot;xxx feature is required to build this crate&quot;)
#   
#   # 表示 只有指定 了 xxx feature, 编译时才会包含 aa_module 进去
#   #[cfg(feature = &quot;xxx&quot;)]
#   mod aa_module



cargo check # 迅速检查错误, 时间短




cargo run 
# 运行 example 文件夹下的 server.rs 的 main()
cargo run --example server
# 运行指定子模块
cargo run -p &lt;xxx&gt;




# 从中心仓库安装
cargo install &lt;package&gt;
# 从 GitHub 安装
cargo install orz --git https://github.com/richox/orz --tag v1.6.1 





cargo doc # 生成html文档
cargo doc --open # 同时打开文档预览
cargo doc --target-doc ./ #输出文档时指定target目录





# # 测试, 
# 会跑 #cfg[test] 下的 #[test]; 也会跑文档注释 (单元测试)
# and  tests/ 下的测试 (集成测试)
cargo test 
cargo test xxx # 过滤, 运行任何名字中包含 xxx 的测试




cargo publish # publish a library to crates.io
cargo --version




# This will write out a new Cargo.lock with the new version information
cargo update           # updates all dependencies
cargo update -p rand   # updates just “rand”

# 第三方插件扩展:

# 需要 rustup component add rustfmt [一toolchain nightly]
cargo fmt # 格式化项目代码, 在项目根目录下执行, 会生成备份文件, .bk结尾, 跳过格式化 #[rustfmt_skip]
cargo fix # 自动修复代码警告
cargo clippy #捕捉常见错误，改善代码 (需要安装 clippy)
</code></pre>
<p>自定义格式化:  在项目根目录 rustfmt.tomI</p>
<pre><code class="language-t">max_width = 90 # 最大宽度
fn_call_width = 90 # 函数宽度
chain_one_line_max = 80 # 链式调用最大宽度
condense_wildcard_suffixes = true # 压缩通配符前缀
</code></pre>
<h3><a class="header" href="#cargotoml" id="cargotoml">Cargo.toml</a></h3>
<p>Cargo.toml 项目元信息, 包括版本, 依赖</p>
<pre><code class="language-t">[package]
...
build = &quot;build.rs&quot; # 构建脚本, 相对于根目录
workspace = &quot;..&quot; # 这是 sub crate 中的配置
member = [&quot;&quot;, &quot;&quot;] # 这是 parent crate 中的配置

[[bin]]
name = &quot;run-main&quot; # 生成的可执行文件的名字
path = &quot;src/main.rs&quot; # 当想在一个作为库的包里同时包含 main.rs , 需要配置这个, 文件名必须为 main.rs, 若放在 src/bin 下则可以自定义文件名
bench = false # 生成 可执行文件时不执行性能测试


[[bench]]
name = &quot;bench&quot;
path = &quot;src/bench.rs&quot; # 性能测试代码
test = false
bench = true


# 依赖
#  [dependencies] 专门用于设置第三方包的依赖，这些依赖会在执行 cargo build命令编译 时使用。
[dependencies]
uuid = &quot;0.0.1&quot; # 会从中心仓库下载
ferris-says = &quot;0.1&quot;

# 版本号规则


[dependencies]
gfx-hal = { version = &quot;0.1.0&quot;, git = &quot;https://github.com/gfx-rs/gfx&quot;, rev = &quot;bd7f058efe78d7626a1cc6fbc0c1d3702fb6d2e7&quot; }
#  或者写成多行 (使用点 &quot;.&quot; 表示json 中的嵌套)
[dependencies.gfx-hal]
git = &quot;https://github.com/gfx-rs/gfx&quot;
version = &quot;0.1.0&quot; 
rev = &quot;bd7f058efe78d7626a1cc6fbc0c1d3702fb6d2e7&quot;

# 本地项目导入
[dependencies]
hello_utils = { path = &quot;../hello_utils&quot;, version = &quot;0.1.0&quot; }

 
# [dev-dependencies]表的作用用来设置测试( tests)、示例 (examples)和基准测试( benchmarks)时使用的依赖, 在执行 cargo test 或 cargo bench 命 令 时使用 。
[dev-dependencies]


# 条件编译功能 (选择性地编 译 代 码)
[features]
default=[&quot;use_std&quot;] # 这里的
use_std=[]
unstable= [&quot;pattern&quot;]
patter=[]


# 最终编译目标库的信息
[lib]
name = foo # 表示将来编译的库名字为“libfooa” 或 “libfoo.so&quot;等。
crate-type = dylib # 比如 crate-type = [”dylib”, ”staticlib”]，表示可 以同时编译生成动态库和静态库。
path = &quot;src/lib.rs&quot; # 表示库文件入口 ， 如果不指定， 则默认是 src/lib.rs。
test=true # 表示可以使用单元测试
bench = true # 表示可以使用性能基准测试, 若代码中没有提供性能基准测试, 则可设置为  false


# 双中括号 -&gt; 数组
[[test]]
path = &quot;tests/test_default.rs&quot; 
name = &quot;default&quot;
[[test]]
name = &quot;aa&quot;
path = &quot;tests/aa.rs&quot;




# 使用本地仓库中的代码build
[patch.crates-io]
uuid = { path = &quot;../path/to/uuid&quot; }
# 默认 master 分支, # 手动指定 commit id, 不过有了 lock 文件, 就不必这么干了
uuid = {git = &quot;https://github.com/uuid-rs/uuid.git&quot;,  rev = &quot;9f35b8e&quot;} 

# rustc 相关的编译配置
# 分别代表对 Release、 Bench 和 Test, debug 四种 编译模式进行配置
[profile.release]
debug=true # 编译时, 包含 debug 信息
# 优化级别
opt-level = 3 # 编译优化, 耗时更长

[profile.bench]
debug=true

[profile.test]
debug=true

[profile.dev]
opt-level = 0 # 优先级
lto= # 连接时间优化





</code></pre>
<h3><a class="header" href="#cargolock" id="cargolock">cargo.lock</a></h3>
<p>锁定依赖版本</p>
<h3><a class="header" href="#workspace" id="workspace">workspace</a></h3>
<p>工作空间可以管理多个 proj 和 lib</p>
<p>新建 Cargo.toml 作为根包的元数据 (工作空间中的子包 也都有自己的 Cargo.toml 配置，各自独立， 互不影响)</p>
<pre><code class="language-t">[workspace]
members = [
    &quot;main&quot;, # 可执行 主程序
    &quot;core&quot;, # 核心类库
    &quot;util&quot;, # 工具库
]
</code></pre>
<p>不管是编译根包还是子包，最终的编译结 果永远都会输出到根包的 target 目录下，并且整个工作空间只允许有一个 Cargo.lock 文件。</p>
<p><code>cargo new [--bin] main</code>, <code>cargo new --lib core</code>, <code>cargo new --lib util</code>; 由于每次创建时, cargo 都会检查 顶层 Cargo 配置文件中的 member 是否都存在, 所以中间可能检查出现错误, 不必担心, 全部创建完错误就消失了</p>
<p>lib 类型类型需要将新建的 module (即rs文件) 在 lib.rs 中声明 <code>pub mod xxx</code>, pub 可选</p>
<h3><a class="header" href="#依赖的版本号规则" id="依赖的版本号规则">依赖的版本号规则</a></h3>
<pre><code class="language-rs">// Rust 包使用的是语义化版本号 (SemVer)。基本格式为“X卫Z”

// • x，主版本号 当做了不兼容或颠覆性的更新时 ， 修改此版本号。
// • y， ;欠版本号 (minor)。当做了向下兼容的功能性修改时，修改此版本号 。 
// • z，修订版本号 (patch)。当做了向下兼容的问题修正时，修改此版本号。

// 符号:
// ^: 版本号必须大于指定版本, 新的版本必须满足不修改[major, minor, patch]中最左边非零数字。如指定 ^1.0.0, 等价于 &gt;=1.0.0 &lt;2.0.0
// *: 通配符, 可以用在[major, minor,patch]的任何一个上面。 
// ~: 允许修改[major, minor, patch]中没有明确指定的版本号
// 手动指定， 通过 &gt;, &lt;, =, &gt;=, &lt;= 来指定版本号 。

</code></pre>
<h2><a class="header" href="#buildrs" id="buildrs">build.rs</a></h2>
<p>build.rs可实现本项目编译前的额外操作，比如代码生成、调用cmake/clang/gcc/ndk-build等编译所依赖的C/C++库、读取C/C++头文件生成FFI文件给Rust项目使用等等，相当于Rust写的shell脚本</p>
<p>先于 cargo build 被编 译</p>
<pre><code class="language-rs">
</code></pre>
<h2><a class="header" href="#项目管理案例" id="项目管理案例">项目管理案例</a></h2>
<h3><a class="header" href="#导入自定义-crate" id="导入自定义-crate">导入自定义 crate</a></h3>
<p><code>cargo new web-server</code></p>
<p><code>cd web-server</code></p>
<p><code>cargo new --lib thread-pool</code></p>
<p>修改 web-server 的 cargo.toml:</p>
<pre><code class="language-t">[dependencies]
thread-pool = {path = &quot;./thread-pool&quot; } # 必须为 thread-pool, 和库名一致; thread_pool 错误, threadpool错误
                                    # 使用: use thread_pool::xxxx (变为下划线)
</code></pre>
<h3><a class="header" href="#执行子目录中的-module" id="执行子目录中的-module">执行子目录中的 module</a></h3>
<pre><code class="language-t">
[[example]]
name = &quot;udp_server&quot;
path = &quot;examples/udp_server.rs&quot;

[[example]]
name = &quot;udp_client&quot;
path = &quot;examples/udp_client.rs&quot;

[[example]]
name = &quot;tcp_server&quot;
path = &quot;examples/tcp_server.rs&quot;

[[example]]
name = &quot;tcp_client&quot;
path = &quot;examples/tcp_client.rs&quot;

</code></pre>
<p>然后在 /examples 下新建 rs 文件, 写 main 方法即可</p>
<h3><a class="header" href="#导入自定义-module" id="导入自定义-module">导入自定义 module</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//ferris_says  为自定义 module

mod ferris_says; // 方法 1: 通过声明导入 module
use ferris_says::say;// 方法 2: 导入模块的方法  // 支持 as , 如 use xxx as yyy
use std::io::{stdout, BufWriter}; 

fn demo() {
    let stdout = stdout();
    let message = String::from(&quot;Hello fellow Rustaceans!&quot;);
    let width = message.chars().count();

    let mut writer = BufWriter::new(stdout.lock());
    say(message.as_bytes(), width, &amp;mut writer).unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#导入第三方-crate" id="导入第三方-crate">导入第三方 crate</a></h3>
<pre><code class="language-rs">// Rust 2015 版本的写法
// 在 Rust2018 版本中，可以省略掉 extern erate, 因为在 Cargo.toml 中已经添加了依赖 
// extern crate 声明包的名称 是 linked_list， 用的是下画线“_”， 而在 Cargo.tom! 中用的是连字符&quot;-&quot;。这是怎么回事呢?其实 Cargo 默认会把连字符转换成 下画线 
extern crate linked_list，
</code></pre>
<h1><a class="header" href="#单元测试" id="单元测试">单元测试</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// 单元测试
/// 
/// 使用 cargo test 运行
/// 
/// 运行某个特定的测试方法 cargo test test_any_panic
/// 
/// cargo test panic 方法名中含有 panic 的测试方法会运行
/// 


#[cfg(test)]// 条件编译 ， 告诉编译器只在运行测试( cargo test 命令)时才编译执行
mod tests {
    // 注意这个惯用法：在 tests 模块中，从外部作用域导入所有名字。
    use super::*;

    #[test]
    fn test_xx() {
        println!(&quot;hello unit test&quot;);
    }

    // 测试 panic
    #[test]
    #[ignore] // 忽略测试, 或者使用 cargo test -- --ignored 命令来运行它们。
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    // 测试 带有输出文本的panic
    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    
}



<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#交叉编译-and-条件编译" id="交叉编译-and-条件编译">交叉编译 and 条件编译</a></h1>
<p>https://github.com/japaric/rust-cross#tldr-ubuntu-example
https://zhuanlan.zhihu.com/p/76611800
https://zhuanlan.zhihu.com/p/128626720</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>///条件编译
/// 
/// cfg 属性：在属性位置中使用 #[cfg(...)]
///cfg! 宏：在布尔表达式中使用 cfg!(...)
/// 
fn condition_compile() {
    // 这个函数仅当目标系统是 Linux 的时候才会编译
    #[cfg(target_os = &quot;linux&quot;)]
    fn are_you_on_linux() {
        println!(&quot;You are running linux!&quot;)
    }
    // 而这个函数仅当目标系统 **不是** Linux 时才会编译
    #[cfg(not(target_os = &quot;linux&quot;))]
    fn are_you_on_linux() {
        println!(&quot;You are *not* running linux!&quot;)
    }

    are_you_on_linux();

    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Yes. It's definitely linux!&quot;);
    } else {
        println!(&quot;Yes. It's definitely *not* linux!&quot;);
    }

    // 自定义条件
    //
    // `rustc --cfg some_condition custom.rs &amp;&amp; ./custom`
    //
    // #[cfg(some_condition)]
    // fn conditional_function() {
    //     println!(&quot;condition met!&quot;)
    // }

    // conditional_function();
}

<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#异步编程" id="异步编程">异步编程</a></h1>
<p>https://rust-lang.github.io/async-book/
https://learnku.com/docs/async-book/2018
https://www.rectcircle.cn/posts/rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/
https://cloud.tencent.com/developer/article/1589757
https://zhuanlan.zhihu.com/p/244047486</p>
<h2><a class="header" href="#为什么使用异步-单线程-webserver" id="为什么使用异步-单线程-webserver">为什么使用异步 单线程 webserver</a></h2>
<p>想要同时运行多个任务, 可以使用多线程, 但是在不同线程之间的切换和线程之间的数据共享过程中，涉及到很多开销。即使是一个只是坐着什么都不做的线程，也会消耗宝贵的系统资源</p>
<p>异步可以在不创建多个线程的情况下同时运行多个任务</p>
<p>例子: 从两个 server下载, 第一个资源 耗时 3s, 第二个资源耗时 1s , 总共耗时 4s, 改为 多线程可以缩短为 3s, 但是有线程切换的开销, 最好的是 改为异步</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>// client
fn start_client() -&gt; Result&lt;()&gt; {
    // 顺序执行, 耗时长, 4s
    // connect_to_server(&quot;localhost&quot;, 8080, &quot;send to server0: 8080&quot;)?;
    // connect_to_server(&quot;localhost&quot;, 8081, &quot;send to server1: 8081&quot;)?;




    // 多线程, 进一步, 可以考虑 使用线程池
    let mut handles = Vec::new();
    let handle_server0 = spawn(move || {
        connect_to_server(&quot;localhost&quot;, 8080, &quot;send to server0: 8080&quot;);
    });
    handles.push(handle_server0);
    let handle_server1 = spawn(move || {
        connect_to_server(&quot;localhost&quot;, 8081, &quot;send to server0: 8081&quot;);
    });
    handles.push(handle_server1);
    for handle in handles {
        handle.join();
    }





    Ok(())
}

fn connect_to_server(host: &amp;str, port: u16, content: &amp;str) -&gt; Result&lt;()&gt; {
    let mut s = TcpStream::connect((host, port))?;
    s.write(content.as_bytes())?;

    let mut buf_reader = BufReader::new(&amp;s);
    let mut buf = Vec::new();
    buf_reader.read_until(b'\n', &amp;mut buf)?;

    println!(&quot;&gt;&gt;&gt; recv from server : {}&quot;, std::str::from_utf8(&amp;buf).unwrap());
    Ok(())
}



// server1
fn start_server1() -&gt; Result&lt;()&gt; {
    let tcp_listener = TcpListener::bind(&quot;localhost:8080&quot;)?;
    for stream in tcp_listener.incoming() {
        handle_conn(&amp;mut stream?, 3)?
    }
    Ok(())
}

//server2
fn start_server2() -&gt; Result&lt;()&gt; {
    let tcp_listener = TcpListener::bind(&quot;localhost:8081&quot;)?;
    for stream in tcp_listener.incoming() {
        handle_conn(&amp;mut stream?, 1)?
    }
    Ok(())
}

fn handle_conn(s: &amp;mut TcpStream, wait_seconds: u64) -&gt; Result&lt;()&gt; {
    let mut buf = [0; 512];
    loop {
        let len = s.read(&amp;mut buf)?;
        if len == 0 {
            return Ok(());
        }

        sleep(Duration::from_secs(wait_seconds));
        s.write(&amp;buf[..len])?;
        s.write(&quot;\n&quot;.as_bytes())?;
    }
}


<span class="boring">}
</span></code></pre></pre>
<p>改进后的异步版本</p>
<pre><code class="language-rs">use std::{
    io::{BufRead, BufReader, Read, Result, Write},
    net::{TcpListener, TcpStream},
    str::from_utf8,
};

use futures::{executor::block_on, join};

fn main() {
    block_on(conn_all_async())
}

async fn conn_all_async() {
    let f0 = conn_server_async(&quot;localhost&quot;, 8080, &quot;send to server0: 8080&quot;);
    let f1 = conn_server_async(&quot;localhost&quot;, 8081, &quot;send to server0: 8081&quot;);
    join!(f0, f1);// 等待 f0, f1 完成
}

async fn conn_server_async(host: &amp;str, port: u16, content: &amp;str) -&gt; Result&lt;()&gt; {
    conn_serve(host, port, content)
}

fn conn_serve(host: &amp;str, port: u16, content: &amp;str) -&gt; Result&lt;()&gt; {
    let mut s = TcpStream::connect((host, port))?;
    s.write(content.as_bytes())?;

    let mut buf = Vec::new();
    let mut buf_reader = BufReader::new(&amp;s);
    buf_reader.read_until(b'\n', &amp;mut buf)?;

    println!(&quot;recv from server: {}&quot;, from_utf8(&amp;buf).unwrap());

    Ok(())
}

</code></pre>
<h2><a class="header" href="#基本使用" id="基本使用">基本使用</a></h2>
<h3><a class="header" href="#block_on" id="block_on">block_on</a></h3>
<p>定义异步函数, 使用 block_on 阻塞主线程:</p>
<pre><pre class="playpen"><code class="language-rust">// futures = &quot;0.3&quot;

use futures::executor::block_on;

fn main() {
    let hello_future = hello();// 异步执行 (不会等待执行完), hello_future 代表结果的代理
    println!(&quot;main finish&quot;);

    // 阻塞 main thread,
    // 接受一个 future, 返回真实结果
    block_on(hello_future);
}

// 异步函数
async fn hello() {
    println!(&quot;hello async&quot;);
}

</code></pre></pre>
<h3><a class="header" href="#await" id="await">await</a></h3>
<p>使用 .await 等待异步函数执行完</p>
<pre><pre class="playpen"><code class="language-rust">use futures::executor::block_on;

fn main() {
    block_on(hello2());// 阻塞等待 hello2 执行完
}

async fn hello() {
    println!(&quot;hello async&quot;);
}

async fn hello1() {
    hello().await;// 等待 hello() 执行完
    println!(&quot;hello 1&quot;);
}

async fn hello2() {
    hello1().await; //等待 hello1 执行完
    println!(&quot;hello 2&quot;);
}



</code></pre></pre>
<h3><a class="header" href="#join" id="join">join</a></h3>
<p>并行执行异步函数</p>
<pre><pre class="playpen"><code class="language-rust">use futures::executor::block_on;
use std::time::Duration;

fn main() {
    let main = async_main();
    block_on(main);//阻塞
}

#[derive(Debug)]
struct Song;

async fn learn_song() -&gt; Song {
    // 不能使用 thread::sleep
    async_std::task::sleep(Duration::from_secs(1)).await; //async-std = &quot;1.5&quot;
    println!(&quot;learn song&quot;);
    Song
}

async fn sing_song(song: Song) {
    async_std::task::sleep(Duration::from_secs(1)).await;
    println!(&quot;sing song: {:?}&quot;, song);
}

async fn dance() {
    println!(&quot;dance&quot;);
}

async fn learn_and_sing() {
    let song = learn_song().await;// 等待执行完
    sing_song(song).await;// 也要加 await, 否则主线程不会等待 sing_song() 执行完就继续前进了
}

async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();

    // `join!` 类似于 `.await` ，但是可以等待多个 future 并发完成
    futures::join!(f1, f2); //  f1, f2 并行完成, 返回 (f1, f2)
    
    //dance
    //learn song
    //sing song: Song

}



</code></pre></pre>
<h2><a class="header" href="#async-std" id="async-std">async-std</a></h2>
<h2><a class="header" href="#future-trait" id="future-trait">Future trait</a></h2>
<pre><code>观察 Future 特质，包含一个核心函数，poll。该函数传递一个 &amp;mut Context&lt;'_&gt; 类型参数， 返回一个 Poll 类型参数

Context 主要包含一个 Waker 对象，由执行器提供，用于告诉执行器，重新执行当前 poll 函数
Poll 是一个枚举类型包含两个枚举
Ready&lt;Output&gt; 当任务已经就绪，返回该对象
Pending 任务没有就绪时返回该对象，此Future将让出CPU，直到在其他线程或者任务执行调用Waker为止
实现者需要保证 poll 是非阻塞，如果是阻塞的话会导致循环进行不下去

实现一个 Future 类型的方式

方式1：使用 async fn，编译器会自动生成实现 Future 特质的类型
方式2：自定义 结构体，并实现 Future 特质

</code></pre>
<h2><a class="header" href="#动手实现-future-类型" id="动手实现-future-类型">动手实现 Future 类型</a></h2>
<h2><a class="header" href="#动手实现-异步-sleep" id="动手实现-异步-sleep">动手实现 异步 sleep</a></h2>
<p>通过自定义类型的方式实现一个异步的sleep, 类似于async_std::task:sleep</p>
<pre><pre class="playpen"><code class="language-rust">use futures::executor::block_on;
use std::time::Duration;
use async_std::sync::Arc;
use std::sync::Mutex;
use futures::task::{Waker, Context, Poll};
use futures::Future;
use std::pin::Pin;
use std::thread::{spawn, sleep};

fn main() {
    block_on(async { // 异步代码块
        println!(&quot;start&quot;);
        TimerFuture::new(Duration::from_secs(2)).await;
        println!(&quot;end&quot;);
    });
}

struct TimerFuture {
    shared_state: Arc&lt;Mutex&lt;SharedState&gt;&gt;,
}

struct SharedState {
    completed: bool,
    waker: Option&lt;Waker&gt;,
}

impl Future for TimerFuture {
    type Output = ();

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            Poll::Ready(())
        } else {
            shared_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}

impl TimerFuture {
    fn new(du: Duration) -&gt; Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        let thread_shared_state = shared_state.clone();
        spawn(move || {
            sleep(du);
            let mut state = thread_shared_state.lock().unwrap();
            state.completed = true;
            if let Some(waker) = state.waker.take() {
                waker.wake();
            }
        });

        TimerFuture {
            shared_state,
        }
    }
}



</code></pre></pre>
<h1><a class="header" href="#并发-多线程" id="并发-多线程">并发 多线程</a></h1>
<h2><a class="header" href="#crossbeam-开源库" id="crossbeam-开源库">CrossBeam 开源库</a></h2>
<p>无锁的数据结构</p>
<h2><a class="header" href="#arc-和-rc" id="arc-和-rc">Arc 和 Rc</a></h2>
<pre><code class="language-rs">
/// Rc&lt;T&gt; 只能用于单线程场景   
// Arc&lt;T&gt;是线程安全版本的 Rc&lt;T&gt;。
</code></pre>
<h2><a class="header" href="#rwlock-和-refcell" id="rwlock-和-refcell">RwLock 和 RefCell</a></h2>
<pre><code class="language-rs">// RwLock&lt;T&gt;相当于线程安全版本的 RefCell&lt;T&gt;，同时运行多个 reader或者一个 writer
// RwLock 读写锁，是多读单写锁，也 叫共享独占锁 。 它允许多个线程读，单个线程写 。 但是在写的时候 ， 只能有一个线程占有写锁 ; 而在读的时候， 允许任意线程获取读锁 。 读锁和写锁不能被同时获取
// 所以在度多写少的场景, 使用 读写锁可以有更高的并发支持
</code></pre>
<h2><a class="header" href="#mutex" id="mutex">Mutex</a></h2>
<pre><code class="language-rs">// Mutex&lt;T&gt;是锁，同一时间仅允许有-个线程进行操作, 不管是读还是写。
// 本质是一个 struct

</code></pre>
<h2><a class="header" href="#atomicptr-和-cell" id="atomicptr-和-cell">AtomicPtr 和 Cell</a></h2>
<pre><code class="language-rs">// Atomic 系列类型: AtomicBool、 Atomiclsize、 AtomicUsize和AtomicPtr
// 可以用 AtomicPtr 来模拟其他想要的类型
// AtomicPtr 相当于线程安全版本 的 Cell&lt;T&gt;
</code></pre>
<h2><a class="header" href="#线程基本使用" id="线程基本使用">线程基本使用</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// 并发 闭包
/// Rust 中通过 std::thread::spawn 函数创建本地操作系统（native OS）线程
/// 
/// spawn() 返回新线程的句柄（handle），我们必须拥有句柄，才能获取线程的返回值, 通过 handle.join().unwrap();
/// 
fn concurrent() {
    use std::thread;
    use std::time::Duration;

    // 普通函数的写法, 不推荐写法
    //
    fn spawn_function() {
        for i in 0..5 {
            println!(&quot;spawned thread print {}&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    }
    let t = thread::spawn(spawn_function);

    //
    // 闭包的写法
    let t = thread::spawn(|| {
        for i in 0..5 {
            println!(&quot;spawned thread print {}&quot;, i);
            thread::sleep(Duration::from_millis(1));// 睡眠
        }
    });

    t.join().unwrap();// 等待线程结束



    //move 强制所有权迁移
    //
    //在子线程中尝试使用当前函数的资源, 这一定是错误的！因为所有权机制禁止这种危险情况的产生
    // 这是需要使用 move, 将资源所有权移动到子线程内部使得外部资源失效
    //
    
    // let s = &quot;hello&quot;; // 若是 &amp;str 类型, 则 move 执行的是 copy, 闭包外层 s 还是有效的
    let s = &quot;hello&quot;.to_owned();
   
    let handle = thread::spawn(move || {// 一定要加 move
        println!(&quot;sub thread, s = {}&quot;, s);
    });
    // 错误, s已经 失效了
    println!(&quot;main thread, s= {}&quot;, s);
    handle.join().unwrap();

}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#多线程小例子" id="多线程小例子">多线程小例子</a></h2>
<h3><a class="header" href="#实现-map-reduce-算法" id="实现-map-reduce-算法">实现 map-reduce 算法</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>    //例子:
    //实现 map-reduce 算法
    //
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

     // 创建一个向量，用于储存将要创建的子线程
    let mut children = vec![];

    let chunked_data = data.split_whitespace();
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        children.push(thread::spawn(move || -&gt; u32 {
            // 计算该段的每一位的和：
            let result = data_segment
                        // 对该段中的字符进行迭代..
                        .chars()
                        // ..把字符转成数字..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // ..对返回的数字类型的迭代器求和
                        .sum();

            // println! 会锁住标准输出，这样各线程打印的内容不会交错在一起
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // 不需要 “return”，因为 Rust 是一种 “表达式语言”，每个代码块中
            // 最后求值的表达式就是代码块的值。
            result

        }));
    }

    // 把每个线程产生的中间结果收入一个新的向量中
    let mut intermediate_sums = vec![];
    for child in children {
        // 收集每个子线程的返回值
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();
    println!(&quot;Final sum result: {}&quot;, final_result);

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#多线程统计和" id="多线程统计和">多线程统计和</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>
<span class="boring">fn main() {
</span>    // 
    //
    //
    const TOTAL_SIZE:usize = 100 * 1000; //数组长度
    const NTHREAD:usize = 6; //线程数
    let data : Vec&lt;i32&gt; = (1..(TOTAL_SIZE+1) as i32).collect(); //初始化一个数据从1到n数组
    let arc_data = Arc::new(data); //data 的所有权转给了 ar_data
    let result  = Arc::new(AtomicU64::new(0)); //收集结果的数组(原子操作)
    let mut thread_handlers = vec![]; // 用于收集线程句柄
    for i in 0..NTHREAD {
        // clone Arc 准备move到线程中，只增加引用计数，不会深拷贝内部数据
        let test_data = arc_data.clone(); 
        let res = result.clone(); 
        thread_handlers.push( 
            thread::spawn(move || {
                let id = i;
                //找到自己的分区
                let chunk_size = TOTAL_SIZE / NTHREAD + 1;
                let start = id * chunk_size;
                let end = std::cmp::min(start + chunk_size, TOTAL_SIZE);
                //进行求和运算
                let mut sum = 0;
                for  i in start..end  {
                    sum += test_data[i];
                }
                //原子操作
                res.fetch_add(sum as u64, Ordering::SeqCst);
                println!(&quot;id={}, sum={}&quot;, id, sum );
            }
        ));
    }
    //等所有的线程执行完
    for th in thread_handlers {
        th.join().expect(&quot;The sender thread panic!!!&quot;);
    }
    //输出结果
    println!(&quot;result = {}&quot;,result.load(Ordering::SeqCst));
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#多线程-线程池-webserver" id="多线程-线程池-webserver">多线程 线程池 webserver</a></h3>
<p>main.rs 是项目启动入口</p>
<p>lib.rs 为 项目内部的 子库</p>
<p>main.rs :</p>
<pre><code class="language-rs">mod lib;

use std::net::{TcpListener, TcpStream};
use std::io::{Read, Write};
use std::fs::read_to_string;
use std::thread;
use std::time::Duration;
use thread_pool::ThreadPool;// 横线变为下划线了

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).unwrap();
    let pool = ThreadPool::new(4);
    for stream in listener.incoming().take(2) {
        match stream {
            Ok(stream) =&gt; {
                pool.execute(|| {
                    handle_conn_quick(stream);
                });
                // handle_conn_quick(stream);
            }
            Err(_) =&gt; eprintln!(&quot;error of connection&quot;),
        }
    }
}

// 
fn handle_conn_quick(mut stream: TcpStream) {
    let mut buf = [0u8; 512];
    stream.read(&amp;mut buf).unwrap();

    println!(&quot;************** req ***************&quot;);
    println!(&quot;{}\n&quot;, String::from_utf8_lossy(&amp;buf));

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
    let (status_line, html_path) = if buf.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;resources/hello.html&quot;)// 相对于根路径
    } else if buf.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;resources/hello.html&quot;)
    }
    else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;resources/404.html&quot;)
    };
    let resp = format!(&quot;{}{}&quot;, status_line, read_to_string(html_path).unwrap());

    println!(&quot;************** resp ***************&quot;);
    println!(&quot;{}\n&quot;, resp);

    stream.write(resp.as_bytes()).unwrap();
    stream.flush().unwrap();
}


//  这是单线程 webserver 的代码
#[allow(dead_code)]
fn handle_conn(mut stream: TcpStream) {
    let mut buf = [0u8; 1024];
    let mut content = String::new();
    loop {
        let len = stream.read(&amp;mut buf).unwrap();
        content.push_str(&amp;String::from_utf8_lossy(&amp;buf)[..]);
        if len &lt; buf.len() {
            break;
        }
    }

    let get = &quot;GET / HTTP/1.1\r\n&quot;;
    let (status_line, html_path) = if content.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;resources/hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;resources/404.html&quot;)
    };

    let html = read_to_string(html_path).unwrap();
    let resp = format!(&quot;{}{}&quot;, status_line, html);
    stream.write(resp.as_bytes()).unwrap();
    stream.flush().unwrap();
}


</code></pre>
<p>lib.rs:</p>
<pre><code class="language-rs">use std::thread::{JoinHandle, spawn};
use std::sync::mpsc::{Sender, channel, Receiver};
use std::sync::{Arc, Mutex};

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}

pub struct ThreadPool {
    // 要实现的行为是创建线程并稍后发送任务代码
    // 所以不能直接存 Thread, 而要引入中间层 worker
    // 若直接使用 Thread, 创建线程后, 任务会直接立即执行, 不行
    workers: Vec&lt;Worker&gt;,
    sender: Sender&lt;Msg&gt;,
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        // 向每个 worker发送终止消息, 使得任务代码跳出receive循环
        // 为什么要分为两个for循环?
        //如果尝试在同一循环中发送消息并立即 join 线程，则无法保证当前迭代的 worker 是从通道收到终止消息的 worker
        for _ in &amp;mut self.workers {
            self.sender.send(Msg::TerminateMsg).unwrap();
        }
        for w in &amp;mut self.workers {// 需要获取workers的可变引用
            println!(&quot;worker {} stop&quot;, w.id);
            // join 调用者需要是 非引用
            // 那么, 需要一个方法将 thread 移动出拥有其所有权的 Worker 实例以便 join 可以消费这个线程。
            //
            // w.thread.join().unwrap();
            if let Some(thread) = w.thread.take() {//take 方法会取出 Some 而留下 None
                thread.join().unwrap();
            }
        }
    }
}

enum Msg {
    JobMsg(Job),
    TerminateMsg,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    /// 创建线程池。
    ///
    /// # Panics
    ///
    /// `new` 函数在 size 为 0 时会 panic。
    pub fn new(size: usize) -&gt; Self {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        let (sender, receiver) = channel();
        let receiver = Arc::new(Mutex::new(receiver));

        //多 生产者，单 消费者 的。这意味着不能简单的克隆通道的消费端来解决问题
        //我们希望通过在所有的 worker 中共享单一 receiver，在线程间分发任务
        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        // 没参数, 没返回值的闭包
        where F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);
        self.sender.send(Msg::JobMsg(job)).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;JoinHandle&lt;()&gt;&gt;,// &quot;()&quot; 表示线程中的任务没有返回值
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;Receiver&lt;Msg&gt;&gt;&gt;) -&gt; Self {
        let thread = spawn(move|| {
            // 不可使用 while let, 因为while 表达式中的值还有块都一直处于作用域中, 锁无法释放
            //
            // 只能使用 loop 循环,
            //使用 loop 并在循环块之内而不是之外获取锁和任务，
            // lock 方法返回的 MutexGuard 在 let job 语句结
            // 束之后立刻就被丢弃了。这确保了 recv 调用过程中持有锁，
            // 而在 job() 调用前锁就被释放了，这就允许并发处理多个请求
            loop {
                let msg = receiver.lock().unwrap().recv().unwrap();
                match msg {
                    Msg::JobMsg(job) =&gt; {
                        println!(&quot;worker {} running&quot;, id);
                        job();
                    },
                    Msg::TerminateMsg =&gt; {
                        println!(&quot;worker {} receive terminate msg&quot;, id);
                        break;
                    },
                }

            }
        });
        Self {
            id,
            thread: Some(thread),
        }
    }
}

</code></pre>
<h2><a class="header" href="#channel" id="channel">channel</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>/// channel 消息传递
/// 
/// Rust 为线程之间的通信提供了异步的通道（channel）。通道允许两个端点之间信息的 单向流动：Sender（发送端） 和 Receiver（接收端）
/// 
fn channel_demo() {
    println!(&quot;-------------channel_demo -----------------&quot;);
    use std::sync::mpsc;// mpsc 是 多个生产者，单个消费者（multiple producer, single consumer）的缩写
    use std::thread;

    //一个发送者（transmitter）和一个接收者（receiver）
    //
    let (tx, rx) = mpsc::channel();// 此时还无法编译, 因为 Rust 不知道我们想要在通道中发送什么类型

    //创建一个新线程
    thread::spawn(move || {//使用 move 将 tx 移动到闭包中这样新建线程就拥有 tx 了
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    //这个方法会阻塞主线程执行直到从通道中接收一个值, 
    //当通道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了
    //
    //try_recv 不会阻塞，相反它立刻返回一个 Result&lt;T, E&gt;：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息
    //可以编写一个循环来频繁调用 try_recv，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查
    //
    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);

    //也可以迭代接收器, 当通道被关闭时，迭代器也将结束
    //
    // for received in rx {
    //     println!(&quot;Got: {}&quot;, received);
    // }


    //通过克隆发送者来创建多个生产者
    //
    // 
    use std::sync::mpsc::{Sender, Receiver};
    static NTHREADS: i32 = 3;

    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();// 手动指定传输数据的类型

    for id in 0..NTHREADS {
        // sender 端可被复制
        let thread_tx = tx.clone();
        // 或者
        // let tx1 = mpsc::Sender::clone(&amp;tx);


        // 每个线程都将通过通道来发送它的 id
        thread::spawn(move || {
            // 被创建的线程取得 `thread_tx` 的所有权
            thread_tx.send(id).unwrap();

            println!(&quot;thread {} finished&quot;, id);
        });
    }

    let mut ids = Vec::with_capacity(NTHREADS as usize);

    for _ in 0..NTHREADS {
        // 若无可用消息的话，`recv` 将阻止当前线程
        ids.push(rx.recv());
    }

    // 显示消息被发送的次序
    println!(&quot;{:?}&quot;, ids);
}


<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#互斥-锁" id="互斥-锁">互斥 锁</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>

<span class="boring">fn main() {
</span>///
/// 通道都类似于单所有权，因为一旦将一个值传送到通道中，将无法再使用这个值。
/// 共享内存类似于多所有权: 多个线程可以同时访问相同的内存位置 (可通过智能指针实现, 现在通过互斥锁实现状态共享)
///
///
///
///Mutex&lt;T&gt; 互斥器, 同一时间只允许一个线程访问内部数据
/// 通过 lock() 返回内部数据的可变引用
///
///  Arc&lt;T&gt; 原子引用计数, 线程安全的 Rc&lt;T&gt;
///
/// RefCell&lt;T&gt; and Rc&lt;T&gt;: 前者可使得内部数据可变, 后者允许多引用
///
/// Mutex&lt;T&gt; and Arc&lt;T&gt;: 类似的, 前者提供内部数据可变引用, 后者允许多线程下的多引用
///
fn lock_demo() {
    use std::sync::{Mutex, Arc};
    use std::thread;

    // 不能使用 Mutex::new(0), 因为有多个 Thread需要它, counter移动进入某个Thread后其他Thread就没法拥有counter了
    //
    // 也不能用Rc::new(Mutex::new(0)), 因为Rc&lt;T&gt;的引用计数, 在多线程下不安全
    //
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            // lock() 这个调用会阻塞当前线程, 直到获取锁为止
            //
            //如果另一个线程拥有锁，并且那个线程 panic 了，
            // 则本线程 lock 调用会失败。在这种情况下，没人能够再获取锁，
            // 所以这里选择 unwrap 并在遇到这种情况时使本线程 panic
            //
            //返回 result, 拆包后是 MutexGuard&lt;T&gt;, 是个智能指针, 实现了 Deref所以可以解引用
            // 实现了 Drop ,当 MutexGuard 离开作用域时自动释放锁
            //
            let mut num = counter.lock().unwrap();
            // 解引用后, 数据是可变的
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());


    // 可拓展的并发
    //并不需要手动实现 Send 和 Sync trait，因为由 Send 和 Sync 的类型组成的类型，自动就是 Send 和 Sync 的。
    // 他们是标记 trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的。
    //
    //rust 语言本身对并发没什么限制, 还提供trait支持自定义并发实现 (std::marker 中的 Sync 和 Send trait)
    //并发方案不受标准库或语言所限：我们可以编写自己的或使用别人编写的并发功能。
    //
    //
    //Send 标记 trait 表明该类型的所有权可以在线程间传递。
    //
    // 几乎所有的 Rust 类型都是Send 的，不过有一些例外，
    // - 包括 Rc&lt;T&gt;：这是不能 Send 的，因为如果克隆了 Rc&lt;T&gt; 的值并尝试将克隆的所有权转移到另一个线程，
    // 这两个线程都可能同时更新引用计数。为此，Rc&lt;T&gt; 被实现为用于单线程场景;
    // - 裸指针（raw pointer）也不可被多线程传递
    //
    //Sync 标记 trait 表明一个实现了 Sync 的类型可以安全的在多个线程中拥有其值的引用 &quot;可以安全的被多线程访问&quot;
    //or 对于任意类型 T，如果 &amp;T（T 的引用）是 Send 的话 T 就是 Sync 的
    //
    // Rc&lt;T&gt; 也不是 Sync 的, RefCell&lt;T&gt;和 Cell&lt;T&gt; 系列类型不是 Sync 的
    //Mutex&lt;T&gt; 是 Sync 的
}



<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#简单文件系统" id="简单文件系统">简单文件系统</a></h1>
<p>https://zhuanlan.zhihu.com/p/115464045</p>
<h1><a class="header" href="#网络编程" id="网络编程">网络编程</a></h1>
<h2><a class="header" href="#tcp" id="tcp">tcp</a></h2>
<pre><code class="language-rs">use std::net::TcpListener;
use std::io::Read;

// server
fn main() -&gt; std::io::Result&lt;()&gt; {
    let listener = TcpListener::bind(&quot;127.0.0.1:1080&quot;)?;
    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) =&gt; {
                let mut buf = [0u8; 512];
                let len = stream.read(&amp;mut buf)?;
                println!(&quot;{}&quot;, String::from_utf8_lossy(&amp;buf));
            },
            Err(_) =&gt; eprintln!(&quot;Error of accept request.&quot;),
        }
    }

    Ok(())
}


// client

fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:1080&quot;)?;
    for index in 0..3 {
        let msg = format!(&quot;tcp msg {}&quot;, index);
        stream.write_all(msg.as_bytes());
        debug!(&quot;send: {}&quot;, msg);
        let mut buf = [0u8; 512];
        stream.read(&amp;mut buf);
    }

    Ok(())
}
</code></pre>
<h2><a class="header" href="#udp" id="udp">udp</a></h2>
<pre><code class="language-rs">// server
use std::net::UdpSocket;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let socket = UdpSocket::bind(&quot;127.0.0.1:1080&quot;)?;

    loop {
        let mut buf = [0u8; 512];

        // receive from client
        // len: data length
        // src_addr: source address
        let (len, src_addr) = socket.recv_from(&amp;mut buf)?;

        println!(&quot;recv: {}&quot;, String::from_utf8_lossy(&amp;buf));

        let resp_buf = &amp;mut buf[..len];
        resp_buf.reverse();
        socket.send_to(resp_buf, src_addr)?;// send data to client
        println!(&quot;send: {}&quot;, String::from_utf8_lossy(resp_buf));
    }

    Ok(())
}

// client

fn main() -&gt; std::io::Result&lt;()&gt; {
    let socket = UdpSocket::bind(&quot;127.0.0.1:34254&quot;)?;
    socket.connect(&quot;127.0.0.1:8080&quot;);

    for index in 0..3 {
        let msg = format!(&quot;udp msg {}&quot;, index);
        socket.send(msg.as_bytes());
        println!(&quot;send: {}&quot;, msg);

        let mut buf = [0u8; 512];
        socket.recv(&amp;mut buf);
        println!(&quot;recv: {}&quot;, String::from_utf8_lossy(&amp;buf));
    }

    Ok(())
}
</code></pre>
<h1><a class="header" href="#消息中间件" id="消息中间件">消息中间件</a></h1>
<p>https://github.com/nkbai/learnrustbynats</p>
<p>TODO</p>
<h1><a class="header" href="#游戏开发" id="游戏开发">游戏开发</a></h1>
<p>https://www.yuque.com/quaint/rust/ldnc5g
TODO</p>
<h1><a class="header" href="#爬虫" id="爬虫">爬虫</a></h1>
<p>Hyper ：一个快速和正确的 Rust HTTP实现。 https://github.com/hyperium/hyper
reqwest : rust http client实现 https://github.com/seanmonstar/reqwest
html5ever：Rust html解析库 https://github.com/servo/html5ever
select :基于html5ever 的html解析库，类似于python的 beautifulsoap https://github.com/utkarshkukreti/select.rs
crates.io https://crates.io/crates/select
附：https：//github.com/carllerche/curl-rust</p>
<h1><a class="header" href="#rpc-框架" id="rpc-框架">rpc 框架</a></h1>
<p>https://zhuanlan.zhihu.com/p/36528189</p>
<h1><a class="header" href="#编写代理" id="编写代理">编写代理</a></h1>
<p>https://github.com/gwuhaolin/blog/issues/12
https://cloud.tencent.com/developer/article/1484318
https://github.com/importcjj/rust-miniproxy
https://github.com/zhxie/pcap2socks</p>
<p>https://github.com/importcjj/gkd-rs
https://github.com/wangyuntao/pinfo-rs</p>
<p>https://zhuanlan.zhihu.com/p/28645724
https://www.jianshu.com/p/d1048d0b687f
https://doc.rust-lang.org/std/net/
https://zhuanlan.zhihu.com/p/97200083
https://www.mojidong.com/post/2015-03-07-socket5-1/
https://www.zhihu.com/search?type=content&amp;q=rust%20socket</p>
<p>TODO</p>
<p>https://lowlvl.org/ 使用 rust 学习 tcp</p>
<h2><a class="header" href="#http-代理" id="http-代理">http 代理</a></h2>
<p>http 代理: 基于 HTTP 协议. 属于应用层协议，一般只会代理转发 HTTP 请求，当然也可以使用 CONNECT 方法来实现一般 TCP 的代理转发
https://github.com/linmx0130/rust-http-proxy</p>
<h2><a class="header" href="#socket-代理" id="socket-代理">socket 代理</a></h2>
<p>Socket是一套标准，它完成了对TCP/IP的高度封装; Socket = IP地址 + 端口 + 协议。</p>
<p>socket5代理: socket5 是一个tcp、udp的代理协议(socket4不支持udp), 传输层代理协议, 它直接通过协议握手来进行连接，并直接修改报头来实现转发，所以速度非常快,大部分软件都支持socket5代理。</p>
<p>https://github.com/importcjj
https://github.com/zhboner/realm 流量转发
https://cloud.tencent.com/developer/article/1484318
https://github.com/gwuhaolin/blog/issues/12</p>
<h1><a class="header" href="#webassembly" id="webassembly">webassembly</a></h1>
<p>https://rustwasm.github.io/</p>
<h1><a class="header" href="#和-java-交互" id="和-java-交互">和 java 交互</a></h1>
<h2><a class="header" href="#rust-调用-java" id="rust-调用-java">rust 调用 java</a></h2>
<p>j4rs，一个在 Rust 中调用 Java 代码的 Crate</p>
<p>https://github.com/benanders/rjni</p>
<p>https://github.com/jni-rs/jni-rs Rust bindings to the JNI </p>
<h2><a class="header" href="#java-调用-rust" id="java-调用-rust">java 调用 rust</a></h2>
<p>https://github.com/drrb/java-rust-example</p>
<p>https://github.com/jnr/jnr-ffi</p>
<p>https://github.com/drrb/java-rust-example
https://stackoverflow.com/questions/30258427/calling-rust-from-java</p>
<p>https://blog.csdn.net/abcamus/article/details/81017325</p>
<p>https://rustcc.cn/article?id=98b96e69-7a5f-4bba-a38e-35bdd7a0a7dd 各种库区别</p>
<p>https://rustcc.cn/article?id=f371a5f1-08fa-4ab8-99a4-21d307223f82 rust 导出共享库</p>
<h1><a class="header" href="#开发微信小程序-web-游戏" id="开发微信小程序-web-游戏">开发微信小程序-web 游戏</a></h1>
<p>https://github.com/planet0104</p>
<h1><a class="header" href="#第三方-crates" id="第三方-crates">第三方 crates</a></h1>
<p>https://crates.io/
https://s0docs0rs.icopy.site/</p>
<p>https://rust-lang-nursery.github.io/rust-cookbook/</p>
<h2><a class="header" href="#web-开发" id="web-开发">web 开发</a></h2>
<h3><a class="header" href="#web框架" id="web框架">web框架</a></h3>
<p>rocket https://rocket.rs/</p>
<p>https://github.com/actix/actix-web</p>
<p>https://github.com/iron/iron</p>
<p>tiny_http</p>
<p>对比选型 http://jiagoushi.pro/book/export/html/334</p>
<p>https://users.rust-lang.org/t/video-series-build-a-smart-bookmarking-tool-with-rust-and-rocket/47601 rocket 实例</p>
<h3><a class="header" href="#orm" id="orm">orm</a></h3>
<p>Diesel ORM</p>
<h3><a class="header" href="#http-client" id="http-client">http client</a></h3>
<p>http - HTTP标准相关的基础类型，如Request<T> 、Response<T>以及StatusCode和常用的Header</p>
<p>hyper -  HTTP底层库，它封装了HTTP的报文解析、报文编码处理、连接控制</p>
<h2><a class="header" href="#序列化反序列化" id="序列化反序列化">序列化反序列化</a></h2>
<p>serde 库</p>
<h3><a class="header" href="#toml" id="toml">toml</a></h3>
<pre><code class="language-rs">use std::env::args;

fn main() {
    let config = {
        let config_path = args().nth(1).unwrap();
        let content = std::fs::read_to_string(config_path).unwrap();
        content.parse::&lt;toml::Value&gt;().unwrap()
    };
    println!(&quot;{:#?}&quot;, config);
    // let tbl = config.as_table().unwrap();
    let input = config.get(&quot;input&quot;).unwrap();
    println!(&quot;{:#?}&quot;, input);
    let json_file = input.get(&quot;json_file&quot;).unwrap().as_str().unwrap();
    println!(&quot;{:#?}&quot;, json_file);
}


</code></pre>
<h3><a class="header" href="#json" id="json">json</a></h3>
<p>serde_json 是基于 serde 实现的</p>
<h2><a class="header" href="#日志系统" id="日志系统">日志系统</a></h2>
<p>日志 https://segmentfault.com/a/1190000021681959</p>
<p>log 提供 api, 如果只是开发一个 lib , 无需导入实现, 如果是在一个可执行程序里, 必须有实现才能打印</p>
<p>具体实现有多种</p>
<h3><a class="header" href="#env_logger" id="env_logger">env_logger</a></h3>
<p><code>RUST_LOG=info ./bin_file</code></p>
<pre><code class="language-rs">#[macro_use]
extern crate log;

fn main() {
    env_logger::init();

    debug!(&quot;debug&quot;);
    info!(&quot;info&quot;);
    warn!(&quot;warn&quot;);
    trace!(&quot;trace&quot;);
    error!(&quot;error&quot;); // default
}


</code></pre>
<h3><a class="header" href="#log4rs-and-log" id="log4rs-and-log">log4rs and log</a></h3>
<pre><code class="language-t">[dependencies]
log = &quot;0.4.11&quot;
log4rs = &quot;0.13.0&quot;
</code></pre>
<p>log4rs.yml</p>
<pre><code class="language-yml">refresh_rate: 30 seconds
appenders:
  stdout:
    kind: console
  requests:
    kind: file
    path: &quot;log/requests.log&quot; # 相对于项目根目录
    encoder:
      pattern: &quot;{d} - {m}{n}&quot;
root:
  level: debug
  appenders:
    - stdout
    - requests

#loggers:
#  app::backend::db:
#    level: info
#  app::requests:
#    level: info
#    appenders:
#      - requests
#    additive: false

</code></pre>
<pre><code class="language-rs">
fn main() {
    let log_file = &quot;config/log4rs.yml&quot;; // 相对于 项目根目录
    log4rs::init_file(log_file, Default::default()).unwrap();
    debug!(&quot;&gt;&gt;&gt; load log config file: {}&quot;, log_file);

    let listener = TcpListener::bind(&quot;127.0.0.1:8090&quot;).unwrap();
    info!(&quot;visit ==&gt; http://127.0.0.1:8090&quot;);
}

</code></pre>
<h2><a class="header" href="#文本解析器" id="文本解析器">文本解析器</a></h2>
<p>https://github.com/Geal/nom
https://zhuanlan.zhihu.com/p/115017849</p>
<h2><a class="header" href="#lazy-static-延迟初始化" id="lazy-static-延迟初始化">lazy static 延迟初始化</a></h2>
<p>可以把定义全局静态变量延迟到运行时，而非编译时</p>
<p>在运行时初始化静态变量, 即静态变量延迟初始化</p>
<p>例如, 某些静态变量由命令行参数决定, 得等到运行时才能确定静态变量</p>
<pre><code class="language-rs">use std::collections::HashMap;

use lazy_static::lazy_static;
// or
// #[macro_use]
// extern crate lazy_static;

lazy_static! {
    static ref HASH_MAP: HashMap&lt;u32, &amp;'static str&gt; = {
        let mut m = HashMap::new();
        m.insert(1, &quot;hello&quot;);
        m.insert(2, &quot;world&quot;);
        println!(&quot;hash map init&quot;);
        m
    };
}

fn main() {
    println!(&quot;{}&quot;, HASH_MAP.get(&amp;1).unwrap());
    print!(&quot;{}&quot;, HASH_MAP.get(&amp;2).unwrap());
}


</code></pre>
<h2><a class="header" href="#电子书" id="电子书">电子书</a></h2>
<p>mdBook 生成电子书</p>
<h2><a class="header" href="#命令行程序" id="命令行程序">命令行程序</a></h2>
<p>indicatif 进度条</p>
<p>clap 命令行参数解析</p>
<p>借助第三方解析库:</p>
<p>https://rust-cli.github.io/book/tutorial/cli-args.html
http://llever.com/cli-wg-zh/tutorial/cli-args.zh.html</p>
<p>https://github.com/rust-cli</p>
<p>ansi_term 彩色输出</p>
<p>https://github.com/fdehau/tui-rs</p>
<p>https://github.com/cjbassi/ytop 命令行系统监控程序</p>
<h3><a class="header" href="#structopt" id="structopt">structopt</a></h3>
<p>整合 clap, 将参数直接解析为 struct, 更加方便</p>
<pre><code class="language-rs">use std::path::PathBuf;
use structopt::StructOpt;

#[derive(StructOpt, Debug)]
#[structopt(name = &quot;basic&quot;)]
struct Opt {
    // 不指定 short long, 会使用 field name
    #[structopt(short = &quot;v&quot;, long)]
    verbose: bool,

    #[structopt(short = &quot;r&quot;, long = &quot;result&quot;, parse(from_os_str))]
    result: PathBuf,

    #[structopt(parse(from_os_str))]
    files: Vec&lt;PathBuf&gt;,


}


fn main() {
    // result this cmd: cargo run input.txt input2.txt -v --result res.xy
    let opt = Opt::from_args();
    println!(&quot;{:#?}&quot;, opt);
}

</code></pre>
<h3><a class="header" href="#clap" id="clap">clap</a></h3>
<p>功能强大, 使用不够简单</p>
<h2><a class="header" href="#异步编程-1" id="异步编程-1">异步编程</a></h2>
<p>tokio</p>
<h2><a class="header" href="#websocket" id="websocket">websocket</a></h2>
<p>https://github.com/websockets-rs/rust-websocket</p>
<p>wsl 中可能 build 失败, 如下解决:</p>
<pre><code class="language-sh">apt install -y openssl
apt install -y libssl-dev
apt install -y pkg-config

</code></pre>
<h2><a class="header" href="#缩小体积" id="缩小体积">缩小体积</a></h2>
<p>cargo-bloat</p>
<h2><a class="header" href="#http-client-1" id="http-client-1">http client</a></h2>
<p>chttp</p>
<h2><a class="header" href="#容错运行时" id="容错运行时">容错运行时</a></h2>
<p>bastion</p>
<h2><a class="header" href="#分发工具" id="分发工具">分发工具</a></h2>
<p>Cargo-release</p>
<h2><a class="header" href="#错误处理-1" id="错误处理-1">错误处理</a></h2>
<p>https://github.com/rust-cli/human-panic</p>
<h2><a class="header" href="#并发编程" id="并发编程">并发编程</a></h2>
<p>https://github.com/crossbeam-rs/crossbeam</p>
<p>Rayon 并行流</p>
<h2><a class="header" href="#gui-图形库" id="gui-图形库">gui 图形库</a></h2>
<p>https://github.com/PistonDevelopers/conrod 2d</p>
<h2><a class="header" href="#底层网络-api" id="底层网络-api">底层网络 api</a></h2>
<p>libpnet, 如 <code>pnet = &quot;0.25.0&quot;</code></p>
<h2><a class="header" href="#正则" id="正则">正则</a></h2>
<ul>
<li>regex 官方实现, 不支持环视 ( look-around ) 和 反向引用 ( backreference)</li>
<li>fancy-regex , 支持 支持环视 ( look-around ) 和 反向引用 ( backreference)</li>
</ul>
<h2><a class="header" href="#随机" id="随机">随机</a></h2>
<h3><a class="header" href="#rand-随机数字" id="rand-随机数字">rand 随机数字</a></h3>
<pre><code class="language-rs">
use rand::prelude::*;

fn main() {
    let mut rng = rand::thread_rng();

    let i = rng.gen_range(0..3); // 0/1/2
    println!(&quot;{}&quot;, i);

    // error
    // let s: &amp;str = rng.gen();

    let boo = rng.gen::&lt;bool&gt;();
    println!(&quot;bool true from gen() : {}&quot;, boo);
    let rate = rng.gen_ratio(1, 2);
    if rng.gen_bool(1.0 / 2.0) {
        println!(&quot;percent of true&quot;);
    }
    if rng.gen() {
        println!(&quot;bool from gen() without turbofish&quot;);
    }
    if rand::random() {
        println!(&quot;rand bool from random()&quot;);
    }
}

</code></pre>
<h1><a class="header" href="#开源项目" id="开源项目">开源项目</a></h1>
<p>https://zhuanlan.zhihu.com/p/62325234
https://zhuanlan.zhihu.com/p/139180791
https://www.zhihu.com/question/30511494</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="java-note.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="git-note.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="java-note.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="git-note.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
